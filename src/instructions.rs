use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo, entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey, program_error::ProgramError,
};
use std::io::Read;
use crate::*;
#[derive(Clone, Debug, PartialEq)]
pub enum DriftProgramIx {
    InitializeUser(InitializeUserIxArgs),
    InitializeUserStats,
    InitializeReferrerName(InitializeReferrerNameIxArgs),
    Deposit(DepositIxArgs),
    Withdraw(WithdrawIxArgs),
    TransferDeposit(TransferDepositIxArgs),
    PlacePerpOrder(PlacePerpOrderIxArgs),
    CancelOrder(CancelOrderIxArgs),
    CancelOrderByUserId(CancelOrderByUserIdIxArgs),
    CancelOrders(CancelOrdersIxArgs),
    CancelOrdersByIds(CancelOrdersByIdsIxArgs),
    ModifyOrder(ModifyOrderIxArgs),
    ModifyOrderByUserId(ModifyOrderByUserIdIxArgs),
    PlaceAndTakePerpOrder(PlaceAndTakePerpOrderIxArgs),
    PlaceAndMakePerpOrder(PlaceAndMakePerpOrderIxArgs),
    PlaceSwiftTakerOrder(PlaceSwiftTakerOrderIxArgs),
    PlaceSpotOrder(PlaceSpotOrderIxArgs),
    PlaceAndTakeSpotOrder(PlaceAndTakeSpotOrderIxArgs),
    PlaceAndMakeSpotOrder(PlaceAndMakeSpotOrderIxArgs),
    PlaceOrders(PlaceOrdersIxArgs),
    BeginSwap(BeginSwapIxArgs),
    EndSwap(EndSwapIxArgs),
    AddPerpLpShares(AddPerpLpSharesIxArgs),
    RemovePerpLpShares(RemovePerpLpSharesIxArgs),
    RemovePerpLpSharesInExpiringMarket(RemovePerpLpSharesInExpiringMarketIxArgs),
    UpdateUserName(UpdateUserNameIxArgs),
    UpdateUserCustomMarginRatio(UpdateUserCustomMarginRatioIxArgs),
    UpdateUserMarginTradingEnabled(UpdateUserMarginTradingEnabledIxArgs),
    UpdateUserDelegate(UpdateUserDelegateIxArgs),
    UpdateUserReduceOnly(UpdateUserReduceOnlyIxArgs),
    UpdateUserAdvancedLp(UpdateUserAdvancedLpIxArgs),
    DeleteUser,
    ReclaimRent,
    EnableUserHighLeverageMode(EnableUserHighLeverageModeIxArgs),
    FillPerpOrder(FillPerpOrderIxArgs),
    RevertFill,
    FillSpotOrder(FillSpotOrderIxArgs),
    TriggerOrder(TriggerOrderIxArgs),
    ForceCancelOrders,
    UpdateUserIdle,
    DisableUserHighLeverageMode,
    UpdateUserFuelBonus,
    UpdateUserOpenOrdersCount,
    AdminDisableUpdatePerpBidAskTwap(AdminDisableUpdatePerpBidAskTwapIxArgs),
    SettlePnl(SettlePnlIxArgs),
    SettleMultiplePnls(SettleMultiplePnlsIxArgs),
    SettleFundingPayment,
    SettleLp(SettleLpIxArgs),
    SettleExpiredMarket(SettleExpiredMarketIxArgs),
    LiquidatePerp(LiquidatePerpIxArgs),
    LiquidatePerpWithFill(LiquidatePerpWithFillIxArgs),
    LiquidateSpot(LiquidateSpotIxArgs),
    LiquidateBorrowForPerpPnl(LiquidateBorrowForPerpPnlIxArgs),
    LiquidatePerpPnlForDeposit(LiquidatePerpPnlForDepositIxArgs),
    SetUserStatusToBeingLiquidated,
    ResolvePerpPnlDeficit(ResolvePerpPnlDeficitIxArgs),
    ResolvePerpBankruptcy(ResolvePerpBankruptcyIxArgs),
    ResolveSpotBankruptcy(ResolveSpotBankruptcyIxArgs),
    SettleRevenueToInsuranceFund(SettleRevenueToInsuranceFundIxArgs),
    UpdateFundingRate(UpdateFundingRateIxArgs),
    UpdatePrelaunchOracle,
    UpdatePerpBidAskTwap,
    UpdateSpotMarketCumulativeInterest,
    UpdateAmms(UpdateAmmsIxArgs),
    UpdateSpotMarketExpiry(UpdateSpotMarketExpiryIxArgs),
    UpdateUserQuoteAssetInsuranceStake,
    UpdateUserGovTokenInsuranceStake,
    InitializeInsuranceFundStake(InitializeInsuranceFundStakeIxArgs),
    AddInsuranceFundStake(AddInsuranceFundStakeIxArgs),
    RequestRemoveInsuranceFundStake(RequestRemoveInsuranceFundStakeIxArgs),
    CancelRequestRemoveInsuranceFundStake(CancelRequestRemoveInsuranceFundStakeIxArgs),
    RemoveInsuranceFundStake(RemoveInsuranceFundStakeIxArgs),
    TransferProtocolIfShares(TransferProtocolIfSharesIxArgs),
    UpdatePythPullOracle(UpdatePythPullOracleIxArgs),
    PostPythPullOracleUpdateAtomic(PostPythPullOracleUpdateAtomicIxArgs),
    PostMultiPythPullOracleUpdatesAtomic(PostMultiPythPullOracleUpdatesAtomicIxArgs),
    Initialize,
    InitializeSpotMarket(InitializeSpotMarketIxArgs),
    DeleteInitializedSpotMarket(DeleteInitializedSpotMarketIxArgs),
    InitializeSerumFulfillmentConfig(InitializeSerumFulfillmentConfigIxArgs),
    UpdateSerumFulfillmentConfigStatus(UpdateSerumFulfillmentConfigStatusIxArgs),
    InitializeOpenbookV2FulfillmentConfig(InitializeOpenbookV2FulfillmentConfigIxArgs),
    OpenbookV2FulfillmentConfigStatus(OpenbookV2FulfillmentConfigStatusIxArgs),
    InitializePhoenixFulfillmentConfig(InitializePhoenixFulfillmentConfigIxArgs),
    PhoenixFulfillmentConfigStatus(PhoenixFulfillmentConfigStatusIxArgs),
    UpdateSerumVault,
    InitializePerpMarket(InitializePerpMarketIxArgs),
    InitializePredictionMarket,
    DeleteInitializedPerpMarket(DeleteInitializedPerpMarketIxArgs),
    MoveAmmPrice(MoveAmmPriceIxArgs),
    RecenterPerpMarketAmm(RecenterPerpMarketAmmIxArgs),
    UpdatePerpMarketAmmSummaryStats(UpdatePerpMarketAmmSummaryStatsIxArgs),
    UpdatePerpMarketExpiry(UpdatePerpMarketExpiryIxArgs),
    SettleExpiredMarketPoolsToRevenuePool,
    DepositIntoPerpMarketFeePool(DepositIntoPerpMarketFeePoolIxArgs),
    DepositIntoSpotMarketVault(DepositIntoSpotMarketVaultIxArgs),
    DepositIntoSpotMarketRevenuePool(DepositIntoSpotMarketRevenuePoolIxArgs),
    RepegAmmCurve(RepegAmmCurveIxArgs),
    UpdatePerpMarketAmmOracleTwap,
    ResetPerpMarketAmmOracleTwap,
    UpdateK(UpdateKIxArgs),
    UpdatePerpMarketMarginRatio(UpdatePerpMarketMarginRatioIxArgs),
    UpdatePerpMarketHighLeverageMarginRatio(
        UpdatePerpMarketHighLeverageMarginRatioIxArgs,
    ),
    UpdatePerpMarketFundingPeriod(UpdatePerpMarketFundingPeriodIxArgs),
    UpdatePerpMarketMaxImbalances(UpdatePerpMarketMaxImbalancesIxArgs),
    UpdatePerpMarketLiquidationFee(UpdatePerpMarketLiquidationFeeIxArgs),
    UpdateInsuranceFundUnstakingPeriod(UpdateInsuranceFundUnstakingPeriodIxArgs),
    UpdateSpotMarketLiquidationFee(UpdateSpotMarketLiquidationFeeIxArgs),
    UpdateWithdrawGuardThreshold(UpdateWithdrawGuardThresholdIxArgs),
    UpdateSpotMarketIfFactor(UpdateSpotMarketIfFactorIxArgs),
    UpdateSpotMarketRevenueSettlePeriod(UpdateSpotMarketRevenueSettlePeriodIxArgs),
    UpdateSpotMarketStatus(UpdateSpotMarketStatusIxArgs),
    UpdateSpotMarketPausedOperations(UpdateSpotMarketPausedOperationsIxArgs),
    UpdateSpotMarketAssetTier(UpdateSpotMarketAssetTierIxArgs),
    UpdateSpotMarketMarginWeights(UpdateSpotMarketMarginWeightsIxArgs),
    UpdateSpotMarketBorrowRate(UpdateSpotMarketBorrowRateIxArgs),
    UpdateSpotMarketMaxTokenDeposits(UpdateSpotMarketMaxTokenDepositsIxArgs),
    UpdateSpotMarketMaxTokenBorrows(UpdateSpotMarketMaxTokenBorrowsIxArgs),
    UpdateSpotMarketScaleInitialAssetWeightStart(
        UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
    ),
    UpdateSpotMarketOracle(UpdateSpotMarketOracleIxArgs),
    UpdateSpotMarketStepSizeAndTickSize(UpdateSpotMarketStepSizeAndTickSizeIxArgs),
    UpdateSpotMarketMinOrderSize(UpdateSpotMarketMinOrderSizeIxArgs),
    UpdateSpotMarketOrdersEnabled(UpdateSpotMarketOrdersEnabledIxArgs),
    UpdateSpotMarketIfPausedOperations(UpdateSpotMarketIfPausedOperationsIxArgs),
    UpdateSpotMarketName(UpdateSpotMarketNameIxArgs),
    UpdatePerpMarketStatus(UpdatePerpMarketStatusIxArgs),
    UpdatePerpMarketPausedOperations(UpdatePerpMarketPausedOperationsIxArgs),
    UpdatePerpMarketContractTier(UpdatePerpMarketContractTierIxArgs),
    UpdatePerpMarketImfFactor(UpdatePerpMarketImfFactorIxArgs),
    UpdatePerpMarketUnrealizedAssetWeight(UpdatePerpMarketUnrealizedAssetWeightIxArgs),
    UpdatePerpMarketConcentrationCoef(UpdatePerpMarketConcentrationCoefIxArgs),
    UpdatePerpMarketCurveUpdateIntensity(UpdatePerpMarketCurveUpdateIntensityIxArgs),
    UpdatePerpMarketTargetBaseAssetAmountPerLp(
        UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
    ),
    UpdatePerpMarketPerLpBase(UpdatePerpMarketPerLpBaseIxArgs),
    UpdateLpCooldownTime(UpdateLpCooldownTimeIxArgs),
    UpdatePerpFeeStructure(UpdatePerpFeeStructureIxArgs),
    UpdateSpotFeeStructure(UpdateSpotFeeStructureIxArgs),
    UpdateInitialPctToLiquidate(UpdateInitialPctToLiquidateIxArgs),
    UpdateLiquidationDuration(UpdateLiquidationDurationIxArgs),
    UpdateLiquidationMarginBufferRatio(UpdateLiquidationMarginBufferRatioIxArgs),
    UpdateOracleGuardRails(UpdateOracleGuardRailsIxArgs),
    UpdateStateSettlementDuration(UpdateStateSettlementDurationIxArgs),
    UpdateStateMaxNumberOfSubAccounts(UpdateStateMaxNumberOfSubAccountsIxArgs),
    UpdateStateMaxInitializeUserFee(UpdateStateMaxInitializeUserFeeIxArgs),
    UpdatePerpMarketOracle(UpdatePerpMarketOracleIxArgs),
    UpdatePerpMarketBaseSpread(UpdatePerpMarketBaseSpreadIxArgs),
    UpdateAmmJitIntensity(UpdateAmmJitIntensityIxArgs),
    UpdatePerpMarketMaxSpread(UpdatePerpMarketMaxSpreadIxArgs),
    UpdatePerpMarketStepSizeAndTickSize(UpdatePerpMarketStepSizeAndTickSizeIxArgs),
    UpdatePerpMarketName(UpdatePerpMarketNameIxArgs),
    UpdatePerpMarketMinOrderSize(UpdatePerpMarketMinOrderSizeIxArgs),
    UpdatePerpMarketMaxSlippageRatio(UpdatePerpMarketMaxSlippageRatioIxArgs),
    UpdatePerpMarketMaxFillReserveFraction(UpdatePerpMarketMaxFillReserveFractionIxArgs),
    UpdatePerpMarketMaxOpenInterest(UpdatePerpMarketMaxOpenInterestIxArgs),
    UpdatePerpMarketNumberOfUsers(UpdatePerpMarketNumberOfUsersIxArgs),
    UpdatePerpMarketFeeAdjustment(UpdatePerpMarketFeeAdjustmentIxArgs),
    UpdateSpotMarketFeeAdjustment(UpdateSpotMarketFeeAdjustmentIxArgs),
    UpdatePerpMarketFuel(UpdatePerpMarketFuelIxArgs),
    UpdateSpotMarketFuel(UpdateSpotMarketFuelIxArgs),
    InitUserFuel(InitUserFuelIxArgs),
    UpdateAdmin(UpdateAdminIxArgs),
    UpdateWhitelistMint(UpdateWhitelistMintIxArgs),
    UpdateDiscountMint(UpdateDiscountMintIxArgs),
    UpdateExchangeStatus(UpdateExchangeStatusIxArgs),
    UpdatePerpAuctionDuration(UpdatePerpAuctionDurationIxArgs),
    UpdateSpotAuctionDuration(UpdateSpotAuctionDurationIxArgs),
    InitializeProtocolIfSharesTransferConfig,
    UpdateProtocolIfSharesTransferConfig(UpdateProtocolIfSharesTransferConfigIxArgs),
    InitializePrelaunchOracle(InitializePrelaunchOracleIxArgs),
    UpdatePrelaunchOracleParams(UpdatePrelaunchOracleParamsIxArgs),
    DeletePrelaunchOracle(DeletePrelaunchOracleIxArgs),
    InitializePythPullOracle(InitializePythPullOracleIxArgs),
    InitializeHighLeverageModeConfig(InitializeHighLeverageModeConfigIxArgs),
    UpdateHighLeverageModeConfig(UpdateHighLeverageModeConfigIxArgs),
}
impl DriftProgramIx {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        match maybe_discm {
            INITIALIZE_USER_IX_DISCM => {
                Ok(Self::InitializeUser(InitializeUserIxArgs::deserialize(&mut reader)?))
            }
            INITIALIZE_USER_STATS_IX_DISCM => Ok(Self::InitializeUserStats),
            INITIALIZE_REFERRER_NAME_IX_DISCM => {
                Ok(
                    Self::InitializeReferrerName(
                        InitializeReferrerNameIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            DEPOSIT_IX_DISCM => {
                Ok(Self::Deposit(DepositIxArgs::deserialize(&mut reader)?))
            }
            WITHDRAW_IX_DISCM => {
                Ok(Self::Withdraw(WithdrawIxArgs::deserialize(&mut reader)?))
            }
            TRANSFER_DEPOSIT_IX_DISCM => {
                Ok(
                    Self::TransferDeposit(
                        TransferDepositIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_PERP_ORDER_IX_DISCM => {
                Ok(Self::PlacePerpOrder(PlacePerpOrderIxArgs::deserialize(&mut reader)?))
            }
            CANCEL_ORDER_IX_DISCM => {
                Ok(Self::CancelOrder(CancelOrderIxArgs::deserialize(&mut reader)?))
            }
            CANCEL_ORDER_BY_USER_ID_IX_DISCM => {
                Ok(
                    Self::CancelOrderByUserId(
                        CancelOrderByUserIdIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            CANCEL_ORDERS_IX_DISCM => {
                Ok(Self::CancelOrders(CancelOrdersIxArgs::deserialize(&mut reader)?))
            }
            CANCEL_ORDERS_BY_IDS_IX_DISCM => {
                Ok(
                    Self::CancelOrdersByIds(
                        CancelOrdersByIdsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            MODIFY_ORDER_IX_DISCM => {
                Ok(Self::ModifyOrder(ModifyOrderIxArgs::deserialize(&mut reader)?))
            }
            MODIFY_ORDER_BY_USER_ID_IX_DISCM => {
                Ok(
                    Self::ModifyOrderByUserId(
                        ModifyOrderByUserIdIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_AND_TAKE_PERP_ORDER_IX_DISCM => {
                Ok(
                    Self::PlaceAndTakePerpOrder(
                        PlaceAndTakePerpOrderIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_AND_MAKE_PERP_ORDER_IX_DISCM => {
                Ok(
                    Self::PlaceAndMakePerpOrder(
                        PlaceAndMakePerpOrderIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_SWIFT_TAKER_ORDER_IX_DISCM => {
                Ok(
                    Self::PlaceSwiftTakerOrder(
                        PlaceSwiftTakerOrderIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_SPOT_ORDER_IX_DISCM => {
                Ok(Self::PlaceSpotOrder(PlaceSpotOrderIxArgs::deserialize(&mut reader)?))
            }
            PLACE_AND_TAKE_SPOT_ORDER_IX_DISCM => {
                Ok(
                    Self::PlaceAndTakeSpotOrder(
                        PlaceAndTakeSpotOrderIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_AND_MAKE_SPOT_ORDER_IX_DISCM => {
                Ok(
                    Self::PlaceAndMakeSpotOrder(
                        PlaceAndMakeSpotOrderIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            PLACE_ORDERS_IX_DISCM => {
                Ok(Self::PlaceOrders(PlaceOrdersIxArgs::deserialize(&mut reader)?))
            }
            BEGIN_SWAP_IX_DISCM => {
                Ok(Self::BeginSwap(BeginSwapIxArgs::deserialize(&mut reader)?))
            }
            END_SWAP_IX_DISCM => {
                Ok(Self::EndSwap(EndSwapIxArgs::deserialize(&mut reader)?))
            }
            ADD_PERP_LP_SHARES_IX_DISCM => {
                Ok(
                    Self::AddPerpLpShares(
                        AddPerpLpSharesIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            REMOVE_PERP_LP_SHARES_IX_DISCM => {
                Ok(
                    Self::RemovePerpLpShares(
                        RemovePerpLpSharesIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_DISCM => {
                Ok(
                    Self::RemovePerpLpSharesInExpiringMarket(
                        RemovePerpLpSharesInExpiringMarketIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_USER_NAME_IX_DISCM => {
                Ok(Self::UpdateUserName(UpdateUserNameIxArgs::deserialize(&mut reader)?))
            }
            UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_DISCM => {
                Ok(
                    Self::UpdateUserCustomMarginRatio(
                        UpdateUserCustomMarginRatioIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_USER_MARGIN_TRADING_ENABLED_IX_DISCM => {
                Ok(
                    Self::UpdateUserMarginTradingEnabled(
                        UpdateUserMarginTradingEnabledIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_USER_DELEGATE_IX_DISCM => {
                Ok(
                    Self::UpdateUserDelegate(
                        UpdateUserDelegateIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_USER_REDUCE_ONLY_IX_DISCM => {
                Ok(
                    Self::UpdateUserReduceOnly(
                        UpdateUserReduceOnlyIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_USER_ADVANCED_LP_IX_DISCM => {
                Ok(
                    Self::UpdateUserAdvancedLp(
                        UpdateUserAdvancedLpIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            DELETE_USER_IX_DISCM => Ok(Self::DeleteUser),
            RECLAIM_RENT_IX_DISCM => Ok(Self::ReclaimRent),
            ENABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM => {
                Ok(
                    Self::EnableUserHighLeverageMode(
                        EnableUserHighLeverageModeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            FILL_PERP_ORDER_IX_DISCM => {
                Ok(Self::FillPerpOrder(FillPerpOrderIxArgs::deserialize(&mut reader)?))
            }
            REVERT_FILL_IX_DISCM => Ok(Self::RevertFill),
            FILL_SPOT_ORDER_IX_DISCM => {
                Ok(Self::FillSpotOrder(FillSpotOrderIxArgs::deserialize(&mut reader)?))
            }
            TRIGGER_ORDER_IX_DISCM => {
                Ok(Self::TriggerOrder(TriggerOrderIxArgs::deserialize(&mut reader)?))
            }
            FORCE_CANCEL_ORDERS_IX_DISCM => Ok(Self::ForceCancelOrders),
            UPDATE_USER_IDLE_IX_DISCM => Ok(Self::UpdateUserIdle),
            DISABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM => {
                Ok(Self::DisableUserHighLeverageMode)
            }
            UPDATE_USER_FUEL_BONUS_IX_DISCM => Ok(Self::UpdateUserFuelBonus),
            UPDATE_USER_OPEN_ORDERS_COUNT_IX_DISCM => Ok(Self::UpdateUserOpenOrdersCount),
            ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_DISCM => {
                Ok(
                    Self::AdminDisableUpdatePerpBidAskTwap(
                        AdminDisableUpdatePerpBidAskTwapIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            SETTLE_PNL_IX_DISCM => {
                Ok(Self::SettlePnl(SettlePnlIxArgs::deserialize(&mut reader)?))
            }
            SETTLE_MULTIPLE_PNLS_IX_DISCM => {
                Ok(
                    Self::SettleMultiplePnls(
                        SettleMultiplePnlsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            SETTLE_FUNDING_PAYMENT_IX_DISCM => Ok(Self::SettleFundingPayment),
            SETTLE_LP_IX_DISCM => {
                Ok(Self::SettleLp(SettleLpIxArgs::deserialize(&mut reader)?))
            }
            SETTLE_EXPIRED_MARKET_IX_DISCM => {
                Ok(
                    Self::SettleExpiredMarket(
                        SettleExpiredMarketIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            LIQUIDATE_PERP_IX_DISCM => {
                Ok(Self::LiquidatePerp(LiquidatePerpIxArgs::deserialize(&mut reader)?))
            }
            LIQUIDATE_PERP_WITH_FILL_IX_DISCM => {
                Ok(
                    Self::LiquidatePerpWithFill(
                        LiquidatePerpWithFillIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            LIQUIDATE_SPOT_IX_DISCM => {
                Ok(Self::LiquidateSpot(LiquidateSpotIxArgs::deserialize(&mut reader)?))
            }
            LIQUIDATE_BORROW_FOR_PERP_PNL_IX_DISCM => {
                Ok(
                    Self::LiquidateBorrowForPerpPnl(
                        LiquidateBorrowForPerpPnlIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_DISCM => {
                Ok(
                    Self::LiquidatePerpPnlForDeposit(
                        LiquidatePerpPnlForDepositIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_DISCM => {
                Ok(Self::SetUserStatusToBeingLiquidated)
            }
            RESOLVE_PERP_PNL_DEFICIT_IX_DISCM => {
                Ok(
                    Self::ResolvePerpPnlDeficit(
                        ResolvePerpPnlDeficitIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            RESOLVE_PERP_BANKRUPTCY_IX_DISCM => {
                Ok(
                    Self::ResolvePerpBankruptcy(
                        ResolvePerpBankruptcyIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            RESOLVE_SPOT_BANKRUPTCY_IX_DISCM => {
                Ok(
                    Self::ResolveSpotBankruptcy(
                        ResolveSpotBankruptcyIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            SETTLE_REVENUE_TO_INSURANCE_FUND_IX_DISCM => {
                Ok(
                    Self::SettleRevenueToInsuranceFund(
                        SettleRevenueToInsuranceFundIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_FUNDING_RATE_IX_DISCM => {
                Ok(
                    Self::UpdateFundingRate(
                        UpdateFundingRateIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PRELAUNCH_ORACLE_IX_DISCM => Ok(Self::UpdatePrelaunchOracle),
            UPDATE_PERP_BID_ASK_TWAP_IX_DISCM => Ok(Self::UpdatePerpBidAskTwap),
            UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_DISCM => {
                Ok(Self::UpdateSpotMarketCumulativeInterest)
            }
            UPDATE_AMMS_IX_DISCM => {
                Ok(Self::UpdateAmms(UpdateAmmsIxArgs::deserialize(&mut reader)?))
            }
            UPDATE_SPOT_MARKET_EXPIRY_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketExpiry(
                        UpdateSpotMarketExpiryIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_DISCM => {
                Ok(Self::UpdateUserQuoteAssetInsuranceStake)
            }
            UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_DISCM => {
                Ok(Self::UpdateUserGovTokenInsuranceStake)
            }
            INITIALIZE_INSURANCE_FUND_STAKE_IX_DISCM => {
                Ok(
                    Self::InitializeInsuranceFundStake(
                        InitializeInsuranceFundStakeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            ADD_INSURANCE_FUND_STAKE_IX_DISCM => {
                Ok(
                    Self::AddInsuranceFundStake(
                        AddInsuranceFundStakeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM => {
                Ok(
                    Self::RequestRemoveInsuranceFundStake(
                        RequestRemoveInsuranceFundStakeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM => {
                Ok(
                    Self::CancelRequestRemoveInsuranceFundStake(
                        CancelRequestRemoveInsuranceFundStakeIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            REMOVE_INSURANCE_FUND_STAKE_IX_DISCM => {
                Ok(
                    Self::RemoveInsuranceFundStake(
                        RemoveInsuranceFundStakeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            TRANSFER_PROTOCOL_IF_SHARES_IX_DISCM => {
                Ok(
                    Self::TransferProtocolIfShares(
                        TransferProtocolIfSharesIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PYTH_PULL_ORACLE_IX_DISCM => {
                Ok(
                    Self::UpdatePythPullOracle(
                        UpdatePythPullOracleIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_DISCM => {
                Ok(
                    Self::PostPythPullOracleUpdateAtomic(
                        PostPythPullOracleUpdateAtomicIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_DISCM => {
                Ok(
                    Self::PostMultiPythPullOracleUpdatesAtomic(
                        PostMultiPythPullOracleUpdatesAtomicIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            INITIALIZE_IX_DISCM => Ok(Self::Initialize),
            INITIALIZE_SPOT_MARKET_IX_DISCM => {
                Ok(
                    Self::InitializeSpotMarket(
                        InitializeSpotMarketIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            DELETE_INITIALIZED_SPOT_MARKET_IX_DISCM => {
                Ok(
                    Self::DeleteInitializedSpotMarket(
                        DeleteInitializedSpotMarketIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_DISCM => {
                Ok(
                    Self::InitializeSerumFulfillmentConfig(
                        InitializeSerumFulfillmentConfigIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_DISCM => {
                Ok(
                    Self::UpdateSerumFulfillmentConfigStatus(
                        UpdateSerumFulfillmentConfigStatusIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_DISCM => {
                Ok(
                    Self::InitializeOpenbookV2FulfillmentConfig(
                        InitializeOpenbookV2FulfillmentConfigIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_DISCM => {
                Ok(
                    Self::OpenbookV2FulfillmentConfigStatus(
                        OpenbookV2FulfillmentConfigStatusIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_DISCM => {
                Ok(
                    Self::InitializePhoenixFulfillmentConfig(
                        InitializePhoenixFulfillmentConfigIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_DISCM => {
                Ok(
                    Self::PhoenixFulfillmentConfigStatus(
                        PhoenixFulfillmentConfigStatusIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SERUM_VAULT_IX_DISCM => Ok(Self::UpdateSerumVault),
            INITIALIZE_PERP_MARKET_IX_DISCM => {
                Ok(
                    Self::InitializePerpMarket(
                        InitializePerpMarketIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            INITIALIZE_PREDICTION_MARKET_IX_DISCM => Ok(Self::InitializePredictionMarket),
            DELETE_INITIALIZED_PERP_MARKET_IX_DISCM => {
                Ok(
                    Self::DeleteInitializedPerpMarket(
                        DeleteInitializedPerpMarketIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            MOVE_AMM_PRICE_IX_DISCM => {
                Ok(Self::MoveAmmPrice(MoveAmmPriceIxArgs::deserialize(&mut reader)?))
            }
            RECENTER_PERP_MARKET_AMM_IX_DISCM => {
                Ok(
                    Self::RecenterPerpMarketAmm(
                        RecenterPerpMarketAmmIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketAmmSummaryStats(
                        UpdatePerpMarketAmmSummaryStatsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_EXPIRY_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketExpiry(
                        UpdatePerpMarketExpiryIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_DISCM => {
                Ok(Self::SettleExpiredMarketPoolsToRevenuePool)
            }
            DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_DISCM => {
                Ok(
                    Self::DepositIntoPerpMarketFeePool(
                        DepositIntoPerpMarketFeePoolIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_DISCM => {
                Ok(
                    Self::DepositIntoSpotMarketVault(
                        DepositIntoSpotMarketVaultIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_DISCM => {
                Ok(
                    Self::DepositIntoSpotMarketRevenuePool(
                        DepositIntoSpotMarketRevenuePoolIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            REPEG_AMM_CURVE_IX_DISCM => {
                Ok(Self::RepegAmmCurve(RepegAmmCurveIxArgs::deserialize(&mut reader)?))
            }
            UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM => {
                Ok(Self::UpdatePerpMarketAmmOracleTwap)
            }
            RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM => {
                Ok(Self::ResetPerpMarketAmmOracleTwap)
            }
            UPDATE_K_IX_DISCM => {
                Ok(Self::UpdateK(UpdateKIxArgs::deserialize(&mut reader)?))
            }
            UPDATE_PERP_MARKET_MARGIN_RATIO_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMarginRatio(
                        UpdatePerpMarketMarginRatioIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketHighLeverageMarginRatio(
                        UpdatePerpMarketHighLeverageMarginRatioIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketFundingPeriod(
                        UpdatePerpMarketFundingPeriodIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMaxImbalances(
                        UpdatePerpMarketMaxImbalancesIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketLiquidationFee(
                        UpdatePerpMarketLiquidationFeeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_DISCM => {
                Ok(
                    Self::UpdateInsuranceFundUnstakingPeriod(
                        UpdateInsuranceFundUnstakingPeriodIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketLiquidationFee(
                        UpdateSpotMarketLiquidationFeeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_DISCM => {
                Ok(
                    Self::UpdateWithdrawGuardThreshold(
                        UpdateWithdrawGuardThresholdIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_IF_FACTOR_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketIfFactor(
                        UpdateSpotMarketIfFactorIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketRevenueSettlePeriod(
                        UpdateSpotMarketRevenueSettlePeriodIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_STATUS_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketStatus(
                        UpdateSpotMarketStatusIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketPausedOperations(
                        UpdateSpotMarketPausedOperationsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_ASSET_TIER_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketAssetTier(
                        UpdateSpotMarketAssetTierIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketMarginWeights(
                        UpdateSpotMarketMarginWeightsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_BORROW_RATE_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketBorrowRate(
                        UpdateSpotMarketBorrowRateIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketMaxTokenDeposits(
                        UpdateSpotMarketMaxTokenDepositsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketMaxTokenBorrows(
                        UpdateSpotMarketMaxTokenBorrowsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketScaleInitialAssetWeightStart(
                        UpdateSpotMarketScaleInitialAssetWeightStartIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_ORACLE_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketOracle(
                        UpdateSpotMarketOracleIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketStepSizeAndTickSize(
                        UpdateSpotMarketStepSizeAndTickSizeIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketMinOrderSize(
                        UpdateSpotMarketMinOrderSizeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketOrdersEnabled(
                        UpdateSpotMarketOrdersEnabledIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketIfPausedOperations(
                        UpdateSpotMarketIfPausedOperationsIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_NAME_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketName(
                        UpdateSpotMarketNameIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_STATUS_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketStatus(
                        UpdatePerpMarketStatusIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketPausedOperations(
                        UpdatePerpMarketPausedOperationsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_CONTRACT_TIER_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketContractTier(
                        UpdatePerpMarketContractTierIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_IMF_FACTOR_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketImfFactor(
                        UpdatePerpMarketImfFactorIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketUnrealizedAssetWeight(
                        UpdatePerpMarketUnrealizedAssetWeightIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketConcentrationCoef(
                        UpdatePerpMarketConcentrationCoefIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketCurveUpdateIntensity(
                        UpdatePerpMarketCurveUpdateIntensityIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketTargetBaseAssetAmountPerLp(
                        UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_PER_LP_BASE_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketPerLpBase(
                        UpdatePerpMarketPerLpBaseIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_LP_COOLDOWN_TIME_IX_DISCM => {
                Ok(
                    Self::UpdateLpCooldownTime(
                        UpdateLpCooldownTimeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_FEE_STRUCTURE_IX_DISCM => {
                Ok(
                    Self::UpdatePerpFeeStructure(
                        UpdatePerpFeeStructureIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_FEE_STRUCTURE_IX_DISCM => {
                Ok(
                    Self::UpdateSpotFeeStructure(
                        UpdateSpotFeeStructureIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_DISCM => {
                Ok(
                    Self::UpdateInitialPctToLiquidate(
                        UpdateInitialPctToLiquidateIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_LIQUIDATION_DURATION_IX_DISCM => {
                Ok(
                    Self::UpdateLiquidationDuration(
                        UpdateLiquidationDurationIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_DISCM => {
                Ok(
                    Self::UpdateLiquidationMarginBufferRatio(
                        UpdateLiquidationMarginBufferRatioIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_ORACLE_GUARD_RAILS_IX_DISCM => {
                Ok(
                    Self::UpdateOracleGuardRails(
                        UpdateOracleGuardRailsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_STATE_SETTLEMENT_DURATION_IX_DISCM => {
                Ok(
                    Self::UpdateStateSettlementDuration(
                        UpdateStateSettlementDurationIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_DISCM => {
                Ok(
                    Self::UpdateStateMaxNumberOfSubAccounts(
                        UpdateStateMaxNumberOfSubAccountsIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_DISCM => {
                Ok(
                    Self::UpdateStateMaxInitializeUserFee(
                        UpdateStateMaxInitializeUserFeeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_ORACLE_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketOracle(
                        UpdatePerpMarketOracleIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_BASE_SPREAD_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketBaseSpread(
                        UpdatePerpMarketBaseSpreadIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_AMM_JIT_INTENSITY_IX_DISCM => {
                Ok(
                    Self::UpdateAmmJitIntensity(
                        UpdateAmmJitIntensityIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_MAX_SPREAD_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMaxSpread(
                        UpdatePerpMarketMaxSpreadIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketStepSizeAndTickSize(
                        UpdatePerpMarketStepSizeAndTickSizeIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_NAME_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketName(
                        UpdatePerpMarketNameIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMinOrderSize(
                        UpdatePerpMarketMinOrderSizeIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMaxSlippageRatio(
                        UpdatePerpMarketMaxSlippageRatioIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMaxFillReserveFraction(
                        UpdatePerpMarketMaxFillReserveFractionIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketMaxOpenInterest(
                        UpdatePerpMarketMaxOpenInterestIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketNumberOfUsers(
                        UpdatePerpMarketNumberOfUsersIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketFeeAdjustment(
                        UpdatePerpMarketFeeAdjustmentIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketFeeAdjustment(
                        UpdateSpotMarketFeeAdjustmentIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_MARKET_FUEL_IX_DISCM => {
                Ok(
                    Self::UpdatePerpMarketFuel(
                        UpdatePerpMarketFuelIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_MARKET_FUEL_IX_DISCM => {
                Ok(
                    Self::UpdateSpotMarketFuel(
                        UpdateSpotMarketFuelIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            INIT_USER_FUEL_IX_DISCM => {
                Ok(Self::InitUserFuel(InitUserFuelIxArgs::deserialize(&mut reader)?))
            }
            UPDATE_ADMIN_IX_DISCM => {
                Ok(Self::UpdateAdmin(UpdateAdminIxArgs::deserialize(&mut reader)?))
            }
            UPDATE_WHITELIST_MINT_IX_DISCM => {
                Ok(
                    Self::UpdateWhitelistMint(
                        UpdateWhitelistMintIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_DISCOUNT_MINT_IX_DISCM => {
                Ok(
                    Self::UpdateDiscountMint(
                        UpdateDiscountMintIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_EXCHANGE_STATUS_IX_DISCM => {
                Ok(
                    Self::UpdateExchangeStatus(
                        UpdateExchangeStatusIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PERP_AUCTION_DURATION_IX_DISCM => {
                Ok(
                    Self::UpdatePerpAuctionDuration(
                        UpdatePerpAuctionDurationIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_SPOT_AUCTION_DURATION_IX_DISCM => {
                Ok(
                    Self::UpdateSpotAuctionDuration(
                        UpdateSpotAuctionDurationIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM => {
                Ok(Self::InitializeProtocolIfSharesTransferConfig)
            }
            UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM => {
                Ok(
                    Self::UpdateProtocolIfSharesTransferConfig(
                        UpdateProtocolIfSharesTransferConfigIxArgs::deserialize(
                            &mut reader,
                        )?,
                    ),
                )
            }
            INITIALIZE_PRELAUNCH_ORACLE_IX_DISCM => {
                Ok(
                    Self::InitializePrelaunchOracle(
                        InitializePrelaunchOracleIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_DISCM => {
                Ok(
                    Self::UpdatePrelaunchOracleParams(
                        UpdatePrelaunchOracleParamsIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            DELETE_PRELAUNCH_ORACLE_IX_DISCM => {
                Ok(
                    Self::DeletePrelaunchOracle(
                        DeletePrelaunchOracleIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            INITIALIZE_PYTH_PULL_ORACLE_IX_DISCM => {
                Ok(
                    Self::InitializePythPullOracle(
                        InitializePythPullOracleIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM => {
                Ok(
                    Self::InitializeHighLeverageModeConfig(
                        InitializeHighLeverageModeConfigIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM => {
                Ok(
                    Self::UpdateHighLeverageModeConfig(
                        UpdateHighLeverageModeConfigIxArgs::deserialize(&mut reader)?,
                    ),
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::Other,
                        format!("discm {:?} not found", maybe_discm),
                    ),
                )
            }
        }
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        match self {
            Self::InitializeUser(args) => {
                writer.write_all(&INITIALIZE_USER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializeUserStats => {
                writer.write_all(&INITIALIZE_USER_STATS_IX_DISCM)
            }
            Self::InitializeReferrerName(args) => {
                writer.write_all(&INITIALIZE_REFERRER_NAME_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Deposit(args) => {
                writer.write_all(&DEPOSIT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Withdraw(args) => {
                writer.write_all(&WITHDRAW_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::TransferDeposit(args) => {
                writer.write_all(&TRANSFER_DEPOSIT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlacePerpOrder(args) => {
                writer.write_all(&PLACE_PERP_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CancelOrder(args) => {
                writer.write_all(&CANCEL_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CancelOrderByUserId(args) => {
                writer.write_all(&CANCEL_ORDER_BY_USER_ID_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CancelOrders(args) => {
                writer.write_all(&CANCEL_ORDERS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CancelOrdersByIds(args) => {
                writer.write_all(&CANCEL_ORDERS_BY_IDS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ModifyOrder(args) => {
                writer.write_all(&MODIFY_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ModifyOrderByUserId(args) => {
                writer.write_all(&MODIFY_ORDER_BY_USER_ID_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceAndTakePerpOrder(args) => {
                writer.write_all(&PLACE_AND_TAKE_PERP_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceAndMakePerpOrder(args) => {
                writer.write_all(&PLACE_AND_MAKE_PERP_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceSwiftTakerOrder(args) => {
                writer.write_all(&PLACE_SWIFT_TAKER_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceSpotOrder(args) => {
                writer.write_all(&PLACE_SPOT_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceAndTakeSpotOrder(args) => {
                writer.write_all(&PLACE_AND_TAKE_SPOT_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceAndMakeSpotOrder(args) => {
                writer.write_all(&PLACE_AND_MAKE_SPOT_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PlaceOrders(args) => {
                writer.write_all(&PLACE_ORDERS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::BeginSwap(args) => {
                writer.write_all(&BEGIN_SWAP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::EndSwap(args) => {
                writer.write_all(&END_SWAP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::AddPerpLpShares(args) => {
                writer.write_all(&ADD_PERP_LP_SHARES_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RemovePerpLpShares(args) => {
                writer.write_all(&REMOVE_PERP_LP_SHARES_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RemovePerpLpSharesInExpiringMarket(args) => {
                writer.write_all(&REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserName(args) => {
                writer.write_all(&UPDATE_USER_NAME_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserCustomMarginRatio(args) => {
                writer.write_all(&UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserMarginTradingEnabled(args) => {
                writer.write_all(&UPDATE_USER_MARGIN_TRADING_ENABLED_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserDelegate(args) => {
                writer.write_all(&UPDATE_USER_DELEGATE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserReduceOnly(args) => {
                writer.write_all(&UPDATE_USER_REDUCE_ONLY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserAdvancedLp(args) => {
                writer.write_all(&UPDATE_USER_ADVANCED_LP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DeleteUser => writer.write_all(&DELETE_USER_IX_DISCM),
            Self::ReclaimRent => writer.write_all(&RECLAIM_RENT_IX_DISCM),
            Self::EnableUserHighLeverageMode(args) => {
                writer.write_all(&ENABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::FillPerpOrder(args) => {
                writer.write_all(&FILL_PERP_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RevertFill => writer.write_all(&REVERT_FILL_IX_DISCM),
            Self::FillSpotOrder(args) => {
                writer.write_all(&FILL_SPOT_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::TriggerOrder(args) => {
                writer.write_all(&TRIGGER_ORDER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ForceCancelOrders => writer.write_all(&FORCE_CANCEL_ORDERS_IX_DISCM),
            Self::UpdateUserIdle => writer.write_all(&UPDATE_USER_IDLE_IX_DISCM),
            Self::DisableUserHighLeverageMode => {
                writer.write_all(&DISABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM)
            }
            Self::UpdateUserFuelBonus => {
                writer.write_all(&UPDATE_USER_FUEL_BONUS_IX_DISCM)
            }
            Self::UpdateUserOpenOrdersCount => {
                writer.write_all(&UPDATE_USER_OPEN_ORDERS_COUNT_IX_DISCM)
            }
            Self::AdminDisableUpdatePerpBidAskTwap(args) => {
                writer.write_all(&ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SettlePnl(args) => {
                writer.write_all(&SETTLE_PNL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SettleMultiplePnls(args) => {
                writer.write_all(&SETTLE_MULTIPLE_PNLS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SettleFundingPayment => {
                writer.write_all(&SETTLE_FUNDING_PAYMENT_IX_DISCM)
            }
            Self::SettleLp(args) => {
                writer.write_all(&SETTLE_LP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SettleExpiredMarket(args) => {
                writer.write_all(&SETTLE_EXPIRED_MARKET_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::LiquidatePerp(args) => {
                writer.write_all(&LIQUIDATE_PERP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::LiquidatePerpWithFill(args) => {
                writer.write_all(&LIQUIDATE_PERP_WITH_FILL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::LiquidateSpot(args) => {
                writer.write_all(&LIQUIDATE_SPOT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::LiquidateBorrowForPerpPnl(args) => {
                writer.write_all(&LIQUIDATE_BORROW_FOR_PERP_PNL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::LiquidatePerpPnlForDeposit(args) => {
                writer.write_all(&LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SetUserStatusToBeingLiquidated => {
                writer.write_all(&SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_DISCM)
            }
            Self::ResolvePerpPnlDeficit(args) => {
                writer.write_all(&RESOLVE_PERP_PNL_DEFICIT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ResolvePerpBankruptcy(args) => {
                writer.write_all(&RESOLVE_PERP_BANKRUPTCY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ResolveSpotBankruptcy(args) => {
                writer.write_all(&RESOLVE_SPOT_BANKRUPTCY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SettleRevenueToInsuranceFund(args) => {
                writer.write_all(&SETTLE_REVENUE_TO_INSURANCE_FUND_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateFundingRate(args) => {
                writer.write_all(&UPDATE_FUNDING_RATE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePrelaunchOracle => {
                writer.write_all(&UPDATE_PRELAUNCH_ORACLE_IX_DISCM)
            }
            Self::UpdatePerpBidAskTwap => {
                writer.write_all(&UPDATE_PERP_BID_ASK_TWAP_IX_DISCM)
            }
            Self::UpdateSpotMarketCumulativeInterest => {
                writer.write_all(&UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_DISCM)
            }
            Self::UpdateAmms(args) => {
                writer.write_all(&UPDATE_AMMS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketExpiry(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_EXPIRY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateUserQuoteAssetInsuranceStake => {
                writer.write_all(&UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_DISCM)
            }
            Self::UpdateUserGovTokenInsuranceStake => {
                writer.write_all(&UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_DISCM)
            }
            Self::InitializeInsuranceFundStake(args) => {
                writer.write_all(&INITIALIZE_INSURANCE_FUND_STAKE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::AddInsuranceFundStake(args) => {
                writer.write_all(&ADD_INSURANCE_FUND_STAKE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RequestRemoveInsuranceFundStake(args) => {
                writer.write_all(&REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CancelRequestRemoveInsuranceFundStake(args) => {
                writer.write_all(&CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RemoveInsuranceFundStake(args) => {
                writer.write_all(&REMOVE_INSURANCE_FUND_STAKE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::TransferProtocolIfShares(args) => {
                writer.write_all(&TRANSFER_PROTOCOL_IF_SHARES_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePythPullOracle(args) => {
                writer.write_all(&UPDATE_PYTH_PULL_ORACLE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PostPythPullOracleUpdateAtomic(args) => {
                writer.write_all(&POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PostMultiPythPullOracleUpdatesAtomic(args) => {
                writer.write_all(&POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Initialize => writer.write_all(&INITIALIZE_IX_DISCM),
            Self::InitializeSpotMarket(args) => {
                writer.write_all(&INITIALIZE_SPOT_MARKET_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DeleteInitializedSpotMarket(args) => {
                writer.write_all(&DELETE_INITIALIZED_SPOT_MARKET_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializeSerumFulfillmentConfig(args) => {
                writer.write_all(&INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSerumFulfillmentConfigStatus(args) => {
                writer.write_all(&UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializeOpenbookV2FulfillmentConfig(args) => {
                writer.write_all(&INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::OpenbookV2FulfillmentConfigStatus(args) => {
                writer.write_all(&OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializePhoenixFulfillmentConfig(args) => {
                writer.write_all(&INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::PhoenixFulfillmentConfigStatus(args) => {
                writer.write_all(&PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSerumVault => writer.write_all(&UPDATE_SERUM_VAULT_IX_DISCM),
            Self::InitializePerpMarket(args) => {
                writer.write_all(&INITIALIZE_PERP_MARKET_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializePredictionMarket => {
                writer.write_all(&INITIALIZE_PREDICTION_MARKET_IX_DISCM)
            }
            Self::DeleteInitializedPerpMarket(args) => {
                writer.write_all(&DELETE_INITIALIZED_PERP_MARKET_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::MoveAmmPrice(args) => {
                writer.write_all(&MOVE_AMM_PRICE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RecenterPerpMarketAmm(args) => {
                writer.write_all(&RECENTER_PERP_MARKET_AMM_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketAmmSummaryStats(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketExpiry(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_EXPIRY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SettleExpiredMarketPoolsToRevenuePool => {
                writer.write_all(&SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_DISCM)
            }
            Self::DepositIntoPerpMarketFeePool(args) => {
                writer.write_all(&DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DepositIntoSpotMarketVault(args) => {
                writer.write_all(&DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DepositIntoSpotMarketRevenuePool(args) => {
                writer.write_all(&DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::RepegAmmCurve(args) => {
                writer.write_all(&REPEG_AMM_CURVE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketAmmOracleTwap => {
                writer.write_all(&UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM)
            }
            Self::ResetPerpMarketAmmOracleTwap => {
                writer.write_all(&RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM)
            }
            Self::UpdateK(args) => {
                writer.write_all(&UPDATE_K_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMarginRatio(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_MARGIN_RATIO_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketHighLeverageMarginRatio(args) => {
                writer
                    .write_all(&UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketFundingPeriod(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMaxImbalances(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketLiquidationFee(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateInsuranceFundUnstakingPeriod(args) => {
                writer.write_all(&UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketLiquidationFee(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateWithdrawGuardThreshold(args) => {
                writer.write_all(&UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketIfFactor(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_IF_FACTOR_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketRevenueSettlePeriod(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketStatus(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_STATUS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketPausedOperations(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketAssetTier(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_ASSET_TIER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketMarginWeights(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketBorrowRate(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_BORROW_RATE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketMaxTokenDeposits(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketMaxTokenBorrows(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketScaleInitialAssetWeightStart(args) => {
                writer
                    .write_all(
                        &UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_DISCM,
                    )?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketOracle(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_ORACLE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketStepSizeAndTickSize(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketMinOrderSize(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketOrdersEnabled(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketIfPausedOperations(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketName(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_NAME_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketStatus(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_STATUS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketPausedOperations(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketContractTier(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_CONTRACT_TIER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketImfFactor(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_IMF_FACTOR_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketUnrealizedAssetWeight(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketConcentrationCoef(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketCurveUpdateIntensity(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketTargetBaseAssetAmountPerLp(args) => {
                writer
                    .write_all(
                        &UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_DISCM,
                    )?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketPerLpBase(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_PER_LP_BASE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateLpCooldownTime(args) => {
                writer.write_all(&UPDATE_LP_COOLDOWN_TIME_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpFeeStructure(args) => {
                writer.write_all(&UPDATE_PERP_FEE_STRUCTURE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotFeeStructure(args) => {
                writer.write_all(&UPDATE_SPOT_FEE_STRUCTURE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateInitialPctToLiquidate(args) => {
                writer.write_all(&UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateLiquidationDuration(args) => {
                writer.write_all(&UPDATE_LIQUIDATION_DURATION_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateLiquidationMarginBufferRatio(args) => {
                writer.write_all(&UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateOracleGuardRails(args) => {
                writer.write_all(&UPDATE_ORACLE_GUARD_RAILS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateStateSettlementDuration(args) => {
                writer.write_all(&UPDATE_STATE_SETTLEMENT_DURATION_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateStateMaxNumberOfSubAccounts(args) => {
                writer.write_all(&UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateStateMaxInitializeUserFee(args) => {
                writer.write_all(&UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketOracle(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_ORACLE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketBaseSpread(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_BASE_SPREAD_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateAmmJitIntensity(args) => {
                writer.write_all(&UPDATE_AMM_JIT_INTENSITY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMaxSpread(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_MAX_SPREAD_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketStepSizeAndTickSize(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketName(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_NAME_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMinOrderSize(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMaxSlippageRatio(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMaxFillReserveFraction(args) => {
                writer
                    .write_all(&UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketMaxOpenInterest(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketNumberOfUsers(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketFeeAdjustment(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketFeeAdjustment(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpMarketFuel(args) => {
                writer.write_all(&UPDATE_PERP_MARKET_FUEL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotMarketFuel(args) => {
                writer.write_all(&UPDATE_SPOT_MARKET_FUEL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitUserFuel(args) => {
                writer.write_all(&INIT_USER_FUEL_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateAdmin(args) => {
                writer.write_all(&UPDATE_ADMIN_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateWhitelistMint(args) => {
                writer.write_all(&UPDATE_WHITELIST_MINT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateDiscountMint(args) => {
                writer.write_all(&UPDATE_DISCOUNT_MINT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateExchangeStatus(args) => {
                writer.write_all(&UPDATE_EXCHANGE_STATUS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePerpAuctionDuration(args) => {
                writer.write_all(&UPDATE_PERP_AUCTION_DURATION_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateSpotAuctionDuration(args) => {
                writer.write_all(&UPDATE_SPOT_AUCTION_DURATION_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializeProtocolIfSharesTransferConfig => {
                writer.write_all(&INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM)
            }
            Self::UpdateProtocolIfSharesTransferConfig(args) => {
                writer.write_all(&UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializePrelaunchOracle(args) => {
                writer.write_all(&INITIALIZE_PRELAUNCH_ORACLE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdatePrelaunchOracleParams(args) => {
                writer.write_all(&UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DeletePrelaunchOracle(args) => {
                writer.write_all(&DELETE_PRELAUNCH_ORACLE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializePythPullOracle(args) => {
                writer.write_all(&INITIALIZE_PYTH_PULL_ORACLE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitializeHighLeverageModeConfig(args) => {
                writer.write_all(&INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::UpdateHighLeverageModeConfig(args) => {
                writer.write_all(&UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
        }
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
fn invoke_instruction<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke(ix, &account_info)
}
fn invoke_instruction_signed<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke_signed(ix, &account_info, seeds)
}
pub const INITIALIZE_USER_IX_ACCOUNTS_LEN: usize = 7;
#[derive(Copy, Clone, Debug)]
pub struct InitializeUserAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub payer: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeUserKeys {
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub state: Pubkey,
    pub authority: Pubkey,
    pub payer: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeUserAccounts<'_, '_>> for InitializeUserKeys {
    fn from(accounts: InitializeUserAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            payer: *accounts.payer.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeUserKeys> for [AccountMeta; INITIALIZE_USER_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeUserKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.payer,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_USER_IX_ACCOUNTS_LEN]> for InitializeUserKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_USER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            user_stats: pubkeys[1],
            state: pubkeys[2],
            authority: pubkeys[3],
            payer: pubkeys[4],
            rent: pubkeys[5],
            system_program: pubkeys[6],
        }
    }
}
impl<'info> From<InitializeUserAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_USER_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeUserAccounts<'_, 'info>) -> Self {
        [
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.payer.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; INITIALIZE_USER_IX_ACCOUNTS_LEN]>
for InitializeUserAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; INITIALIZE_USER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: &arr[0],
            user_stats: &arr[1],
            state: &arr[2],
            authority: &arr[3],
            payer: &arr[4],
            rent: &arr[5],
            system_program: &arr[6],
        }
    }
}
pub const INITIALIZE_USER_IX_DISCM: [u8; 8] = [111, 17, 185, 250, 60, 122, 38, 254];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeUserIxArgs {
    pub sub_account_id: u16,
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeUserIxData(pub InitializeUserIxArgs);
impl From<InitializeUserIxArgs> for InitializeUserIxData {
    fn from(args: InitializeUserIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeUserIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_USER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_USER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeUserIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_USER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_user_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeUserKeys,
    args: InitializeUserIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_USER_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitializeUserIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_user_ix(
    keys: InitializeUserKeys,
    args: InitializeUserIxArgs,
) -> std::io::Result<Instruction> {
    initialize_user_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_user_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeUserAccounts<'_, '_>,
    args: InitializeUserIxArgs,
) -> ProgramResult {
    let keys: InitializeUserKeys = accounts.into();
    let ix = initialize_user_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_user_invoke(
    accounts: InitializeUserAccounts<'_, '_>,
    args: InitializeUserIxArgs,
) -> ProgramResult {
    initialize_user_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_user_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeUserAccounts<'_, '_>,
    args: InitializeUserIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeUserKeys = accounts.into();
    let ix = initialize_user_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_user_invoke_signed(
    accounts: InitializeUserAccounts<'_, '_>,
    args: InitializeUserIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_user_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn initialize_user_verify_account_keys(
    accounts: InitializeUserAccounts<'_, '_>,
    keys: InitializeUserKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.payer.key, keys.payer),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_user_verify_writable_privileges<'me, 'info>(
    accounts: InitializeUserAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.state,
        accounts.payer,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_user_verify_signer_privileges<'me, 'info>(
    accounts: InitializeUserAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority, accounts.payer] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_user_verify_account_privileges<'me, 'info>(
    accounts: InitializeUserAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_user_verify_writable_privileges(accounts)?;
    initialize_user_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct InitializeUserStatsAccounts<'me, 'info> {
    pub user_stats: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub payer: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeUserStatsKeys {
    pub user_stats: Pubkey,
    pub state: Pubkey,
    pub authority: Pubkey,
    pub payer: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeUserStatsAccounts<'_, '_>> for InitializeUserStatsKeys {
    fn from(accounts: InitializeUserStatsAccounts) -> Self {
        Self {
            user_stats: *accounts.user_stats.key,
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            payer: *accounts.payer.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeUserStatsKeys>
for [AccountMeta; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeUserStatsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.payer,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN]> for InitializeUserStatsKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user_stats: pubkeys[0],
            state: pubkeys[1],
            authority: pubkeys[2],
            payer: pubkeys[3],
            rent: pubkeys[4],
            system_program: pubkeys[5],
        }
    }
}
impl<'info> From<InitializeUserStatsAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeUserStatsAccounts<'_, 'info>) -> Self {
        [
            accounts.user_stats.clone(),
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.payer.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN]>
for InitializeUserStatsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user_stats: &arr[0],
            state: &arr[1],
            authority: &arr[2],
            payer: &arr[3],
            rent: &arr[4],
            system_program: &arr[5],
        }
    }
}
pub const INITIALIZE_USER_STATS_IX_DISCM: [u8; 8] = [
    254,
    243,
    72,
    98,
    251,
    130,
    168,
    213,
];
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeUserStatsIxData;
impl InitializeUserStatsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_USER_STATS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_USER_STATS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_USER_STATS_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_user_stats_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeUserStatsKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_USER_STATS_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: InitializeUserStatsIxData.try_to_vec()?,
    })
}
pub fn initialize_user_stats_ix(
    keys: InitializeUserStatsKeys,
) -> std::io::Result<Instruction> {
    initialize_user_stats_ix_with_program_id(crate::ID, keys)
}
pub fn initialize_user_stats_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeUserStatsAccounts<'_, '_>,
) -> ProgramResult {
    let keys: InitializeUserStatsKeys = accounts.into();
    let ix = initialize_user_stats_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_user_stats_invoke(
    accounts: InitializeUserStatsAccounts<'_, '_>,
) -> ProgramResult {
    initialize_user_stats_invoke_with_program_id(crate::ID, accounts)
}
pub fn initialize_user_stats_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeUserStatsAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeUserStatsKeys = accounts.into();
    let ix = initialize_user_stats_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_user_stats_invoke_signed(
    accounts: InitializeUserStatsAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_user_stats_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn initialize_user_stats_verify_account_keys(
    accounts: InitializeUserStatsAccounts<'_, '_>,
    keys: InitializeUserStatsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.payer.key, keys.payer),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_user_stats_verify_writable_privileges<'me, 'info>(
    accounts: InitializeUserStatsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user_stats, accounts.state, accounts.payer] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_user_stats_verify_signer_privileges<'me, 'info>(
    accounts: InitializeUserStatsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority, accounts.payer] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_user_stats_verify_account_privileges<'me, 'info>(
    accounts: InitializeUserStatsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_user_stats_verify_writable_privileges(accounts)?;
    initialize_user_stats_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN: usize = 7;
#[derive(Copy, Clone, Debug)]
pub struct InitializeReferrerNameAccounts<'me, 'info> {
    pub referrer_name: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub payer: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeReferrerNameKeys {
    pub referrer_name: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub payer: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeReferrerNameAccounts<'_, '_>> for InitializeReferrerNameKeys {
    fn from(accounts: InitializeReferrerNameAccounts) -> Self {
        Self {
            referrer_name: *accounts.referrer_name.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            payer: *accounts.payer.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeReferrerNameKeys>
for [AccountMeta; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeReferrerNameKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.referrer_name,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.payer,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN]>
for InitializeReferrerNameKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            referrer_name: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            payer: pubkeys[4],
            rent: pubkeys[5],
            system_program: pubkeys[6],
        }
    }
}
impl<'info> From<InitializeReferrerNameAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeReferrerNameAccounts<'_, 'info>) -> Self {
        [
            accounts.referrer_name.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.payer.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN]>
for InitializeReferrerNameAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            referrer_name: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            payer: &arr[4],
            rent: &arr[5],
            system_program: &arr[6],
        }
    }
}
pub const INITIALIZE_REFERRER_NAME_IX_DISCM: [u8; 8] = [
    235,
    126,
    231,
    10,
    42,
    164,
    26,
    61,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeReferrerNameIxArgs {
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeReferrerNameIxData(pub InitializeReferrerNameIxArgs);
impl From<InitializeReferrerNameIxArgs> for InitializeReferrerNameIxData {
    fn from(args: InitializeReferrerNameIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeReferrerNameIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_REFERRER_NAME_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_REFERRER_NAME_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeReferrerNameIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_REFERRER_NAME_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_referrer_name_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeReferrerNameKeys,
    args: InitializeReferrerNameIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_REFERRER_NAME_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitializeReferrerNameIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_referrer_name_ix(
    keys: InitializeReferrerNameKeys,
    args: InitializeReferrerNameIxArgs,
) -> std::io::Result<Instruction> {
    initialize_referrer_name_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_referrer_name_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeReferrerNameAccounts<'_, '_>,
    args: InitializeReferrerNameIxArgs,
) -> ProgramResult {
    let keys: InitializeReferrerNameKeys = accounts.into();
    let ix = initialize_referrer_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_referrer_name_invoke(
    accounts: InitializeReferrerNameAccounts<'_, '_>,
    args: InitializeReferrerNameIxArgs,
) -> ProgramResult {
    initialize_referrer_name_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_referrer_name_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeReferrerNameAccounts<'_, '_>,
    args: InitializeReferrerNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeReferrerNameKeys = accounts.into();
    let ix = initialize_referrer_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_referrer_name_invoke_signed(
    accounts: InitializeReferrerNameAccounts<'_, '_>,
    args: InitializeReferrerNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_referrer_name_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_referrer_name_verify_account_keys(
    accounts: InitializeReferrerNameAccounts<'_, '_>,
    keys: InitializeReferrerNameKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.referrer_name.key, keys.referrer_name),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.payer.key, keys.payer),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_referrer_name_verify_writable_privileges<'me, 'info>(
    accounts: InitializeReferrerNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.referrer_name,
        accounts.user,
        accounts.user_stats,
        accounts.payer,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_referrer_name_verify_signer_privileges<'me, 'info>(
    accounts: InitializeReferrerNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority, accounts.payer] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_referrer_name_verify_account_privileges<'me, 'info>(
    accounts: InitializeReferrerNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_referrer_name_verify_writable_privileges(accounts)?;
    initialize_referrer_name_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DEPOSIT_IX_ACCOUNTS_LEN: usize = 7;
#[derive(Copy, Clone, Debug)]
pub struct DepositAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub user_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DepositKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
    pub user_token_account: Pubkey,
    pub token_program: Pubkey,
}
impl From<DepositAccounts<'_, '_>> for DepositKeys {
    fn from(accounts: DepositAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            user_token_account: *accounts.user_token_account.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<DepositKeys> for [AccountMeta; DEPOSIT_IX_ACCOUNTS_LEN] {
    fn from(keys: DepositKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DEPOSIT_IX_ACCOUNTS_LEN]> for DepositKeys {
    fn from(pubkeys: [Pubkey; DEPOSIT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            spot_market_vault: pubkeys[4],
            user_token_account: pubkeys[5],
            token_program: pubkeys[6],
        }
    }
}
impl<'info> From<DepositAccounts<'_, 'info>>
for [AccountInfo<'info>; DEPOSIT_IX_ACCOUNTS_LEN] {
    fn from(accounts: DepositAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
            accounts.user_token_account.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; DEPOSIT_IX_ACCOUNTS_LEN]>
for DepositAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; DEPOSIT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            spot_market_vault: &arr[4],
            user_token_account: &arr[5],
            token_program: &arr[6],
        }
    }
}
pub const DEPOSIT_IX_DISCM: [u8; 8] = [242, 35, 198, 137, 82, 225, 242, 182];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DepositIxArgs {
    pub market_index: u16,
    pub amount: u64,
    pub reduce_only: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DepositIxData(pub DepositIxArgs);
impl From<DepositIxArgs> for DepositIxData {
    fn from(args: DepositIxArgs) -> Self {
        Self(args)
    }
}
impl DepositIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DEPOSIT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DEPOSIT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DepositIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DEPOSIT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn deposit_ix_with_program_id(
    program_id: Pubkey,
    keys: DepositKeys,
    args: DepositIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DEPOSIT_IX_ACCOUNTS_LEN] = keys.into();
    let data: DepositIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn deposit_ix(
    keys: DepositKeys,
    args: DepositIxArgs,
) -> std::io::Result<Instruction> {
    deposit_ix_with_program_id(crate::ID, keys, args)
}
pub fn deposit_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DepositAccounts<'_, '_>,
    args: DepositIxArgs,
) -> ProgramResult {
    let keys: DepositKeys = accounts.into();
    let ix = deposit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn deposit_invoke(
    accounts: DepositAccounts<'_, '_>,
    args: DepositIxArgs,
) -> ProgramResult {
    deposit_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn deposit_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DepositAccounts<'_, '_>,
    args: DepositIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DepositKeys = accounts.into();
    let ix = deposit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn deposit_invoke_signed(
    accounts: DepositAccounts<'_, '_>,
    args: DepositIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    deposit_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn deposit_verify_account_keys(
    accounts: DepositAccounts<'_, '_>,
    keys: DepositKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.user_token_account.key, keys.user_token_account),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn deposit_verify_writable_privileges<'me, 'info>(
    accounts: DepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.spot_market_vault,
        accounts.user_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn deposit_verify_signer_privileges<'me, 'info>(
    accounts: DepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn deposit_verify_account_privileges<'me, 'info>(
    accounts: DepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    deposit_verify_writable_privileges(accounts)?;
    deposit_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const WITHDRAW_IX_ACCOUNTS_LEN: usize = 8;
#[derive(Copy, Clone, Debug)]
pub struct WithdrawAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub user_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct WithdrawKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub user_token_account: Pubkey,
    pub token_program: Pubkey,
}
impl From<WithdrawAccounts<'_, '_>> for WithdrawKeys {
    fn from(accounts: WithdrawAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            drift_signer: *accounts.drift_signer.key,
            user_token_account: *accounts.user_token_account.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<WithdrawKeys> for [AccountMeta; WITHDRAW_IX_ACCOUNTS_LEN] {
    fn from(keys: WithdrawKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; WITHDRAW_IX_ACCOUNTS_LEN]> for WithdrawKeys {
    fn from(pubkeys: [Pubkey; WITHDRAW_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            spot_market_vault: pubkeys[4],
            drift_signer: pubkeys[5],
            user_token_account: pubkeys[6],
            token_program: pubkeys[7],
        }
    }
}
impl<'info> From<WithdrawAccounts<'_, 'info>>
for [AccountInfo<'info>; WITHDRAW_IX_ACCOUNTS_LEN] {
    fn from(accounts: WithdrawAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.user_token_account.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; WITHDRAW_IX_ACCOUNTS_LEN]>
for WithdrawAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; WITHDRAW_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            spot_market_vault: &arr[4],
            drift_signer: &arr[5],
            user_token_account: &arr[6],
            token_program: &arr[7],
        }
    }
}
pub const WITHDRAW_IX_DISCM: [u8; 8] = [183, 18, 70, 156, 148, 109, 161, 34];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct WithdrawIxArgs {
    pub market_index: u16,
    pub amount: u64,
    pub reduce_only: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct WithdrawIxData(pub WithdrawIxArgs);
impl From<WithdrawIxArgs> for WithdrawIxData {
    fn from(args: WithdrawIxArgs) -> Self {
        Self(args)
    }
}
impl WithdrawIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != WITHDRAW_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        WITHDRAW_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(WithdrawIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&WITHDRAW_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn withdraw_ix_with_program_id(
    program_id: Pubkey,
    keys: WithdrawKeys,
    args: WithdrawIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; WITHDRAW_IX_ACCOUNTS_LEN] = keys.into();
    let data: WithdrawIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn withdraw_ix(
    keys: WithdrawKeys,
    args: WithdrawIxArgs,
) -> std::io::Result<Instruction> {
    withdraw_ix_with_program_id(crate::ID, keys, args)
}
pub fn withdraw_invoke_with_program_id(
    program_id: Pubkey,
    accounts: WithdrawAccounts<'_, '_>,
    args: WithdrawIxArgs,
) -> ProgramResult {
    let keys: WithdrawKeys = accounts.into();
    let ix = withdraw_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn withdraw_invoke(
    accounts: WithdrawAccounts<'_, '_>,
    args: WithdrawIxArgs,
) -> ProgramResult {
    withdraw_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn withdraw_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: WithdrawAccounts<'_, '_>,
    args: WithdrawIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: WithdrawKeys = accounts.into();
    let ix = withdraw_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn withdraw_invoke_signed(
    accounts: WithdrawAccounts<'_, '_>,
    args: WithdrawIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    withdraw_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn withdraw_verify_account_keys(
    accounts: WithdrawAccounts<'_, '_>,
    keys: WithdrawKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.user_token_account.key, keys.user_token_account),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn withdraw_verify_writable_privileges<'me, 'info>(
    accounts: WithdrawAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.spot_market_vault,
        accounts.user_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn withdraw_verify_signer_privileges<'me, 'info>(
    accounts: WithdrawAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn withdraw_verify_account_privileges<'me, 'info>(
    accounts: WithdrawAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    withdraw_verify_writable_privileges(accounts)?;
    withdraw_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct TransferDepositAccounts<'me, 'info> {
    pub from_user: &'me AccountInfo<'info>,
    pub to_user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct TransferDepositKeys {
    pub from_user: Pubkey,
    pub to_user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub state: Pubkey,
    pub spot_market_vault: Pubkey,
}
impl From<TransferDepositAccounts<'_, '_>> for TransferDepositKeys {
    fn from(accounts: TransferDepositAccounts) -> Self {
        Self {
            from_user: *accounts.from_user.key,
            to_user: *accounts.to_user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            state: *accounts.state.key,
            spot_market_vault: *accounts.spot_market_vault.key,
        }
    }
}
impl From<TransferDepositKeys> for [AccountMeta; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN] {
    fn from(keys: TransferDepositKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.from_user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.to_user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN]> for TransferDepositKeys {
    fn from(pubkeys: [Pubkey; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            from_user: pubkeys[0],
            to_user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            state: pubkeys[4],
            spot_market_vault: pubkeys[5],
        }
    }
}
impl<'info> From<TransferDepositAccounts<'_, 'info>>
for [AccountInfo<'info>; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN] {
    fn from(accounts: TransferDepositAccounts<'_, 'info>) -> Self {
        [
            accounts.from_user.clone(),
            accounts.to_user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.state.clone(),
            accounts.spot_market_vault.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN]>
for TransferDepositAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            from_user: &arr[0],
            to_user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            state: &arr[4],
            spot_market_vault: &arr[5],
        }
    }
}
pub const TRANSFER_DEPOSIT_IX_DISCM: [u8; 8] = [20, 20, 147, 223, 41, 63, 204, 111];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct TransferDepositIxArgs {
    pub market_index: u16,
    pub amount: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct TransferDepositIxData(pub TransferDepositIxArgs);
impl From<TransferDepositIxArgs> for TransferDepositIxData {
    fn from(args: TransferDepositIxArgs) -> Self {
        Self(args)
    }
}
impl TransferDepositIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != TRANSFER_DEPOSIT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        TRANSFER_DEPOSIT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(TransferDepositIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&TRANSFER_DEPOSIT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn transfer_deposit_ix_with_program_id(
    program_id: Pubkey,
    keys: TransferDepositKeys,
    args: TransferDepositIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; TRANSFER_DEPOSIT_IX_ACCOUNTS_LEN] = keys.into();
    let data: TransferDepositIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn transfer_deposit_ix(
    keys: TransferDepositKeys,
    args: TransferDepositIxArgs,
) -> std::io::Result<Instruction> {
    transfer_deposit_ix_with_program_id(crate::ID, keys, args)
}
pub fn transfer_deposit_invoke_with_program_id(
    program_id: Pubkey,
    accounts: TransferDepositAccounts<'_, '_>,
    args: TransferDepositIxArgs,
) -> ProgramResult {
    let keys: TransferDepositKeys = accounts.into();
    let ix = transfer_deposit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn transfer_deposit_invoke(
    accounts: TransferDepositAccounts<'_, '_>,
    args: TransferDepositIxArgs,
) -> ProgramResult {
    transfer_deposit_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn transfer_deposit_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: TransferDepositAccounts<'_, '_>,
    args: TransferDepositIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: TransferDepositKeys = accounts.into();
    let ix = transfer_deposit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn transfer_deposit_invoke_signed(
    accounts: TransferDepositAccounts<'_, '_>,
    args: TransferDepositIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    transfer_deposit_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn transfer_deposit_verify_account_keys(
    accounts: TransferDepositAccounts<'_, '_>,
    keys: TransferDepositKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.from_user.key, keys.from_user),
        (*accounts.to_user.key, keys.to_user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn transfer_deposit_verify_writable_privileges<'me, 'info>(
    accounts: TransferDepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.from_user,
        accounts.to_user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn transfer_deposit_verify_signer_privileges<'me, 'info>(
    accounts: TransferDepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn transfer_deposit_verify_account_privileges<'me, 'info>(
    accounts: TransferDepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    transfer_deposit_verify_writable_privileges(accounts)?;
    transfer_deposit_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_PERP_ORDER_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct PlacePerpOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlacePerpOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<PlacePerpOrderAccounts<'_, '_>> for PlacePerpOrderKeys {
    fn from(accounts: PlacePerpOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlacePerpOrderKeys> for [AccountMeta; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlacePerpOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN]> for PlacePerpOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<PlacePerpOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlacePerpOrderAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN]>
for PlacePerpOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const PLACE_PERP_ORDER_IX_DISCM: [u8; 8] = [69, 161, 93, 202, 120, 126, 76, 185];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlacePerpOrderIxArgs {
    pub params: OrderParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlacePerpOrderIxData(pub PlacePerpOrderIxArgs);
impl From<PlacePerpOrderIxArgs> for PlacePerpOrderIxData {
    fn from(args: PlacePerpOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlacePerpOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_PERP_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_PERP_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlacePerpOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_PERP_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_perp_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlacePerpOrderKeys,
    args: PlacePerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_PERP_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlacePerpOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_perp_order_ix(
    keys: PlacePerpOrderKeys,
    args: PlacePerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_perp_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_perp_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlacePerpOrderAccounts<'_, '_>,
    args: PlacePerpOrderIxArgs,
) -> ProgramResult {
    let keys: PlacePerpOrderKeys = accounts.into();
    let ix = place_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_perp_order_invoke(
    accounts: PlacePerpOrderAccounts<'_, '_>,
    args: PlacePerpOrderIxArgs,
) -> ProgramResult {
    place_perp_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_perp_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlacePerpOrderAccounts<'_, '_>,
    args: PlacePerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlacePerpOrderKeys = accounts.into();
    let ix = place_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_perp_order_invoke_signed(
    accounts: PlacePerpOrderAccounts<'_, '_>,
    args: PlacePerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_perp_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn place_perp_order_verify_account_keys(
    accounts: PlacePerpOrderAccounts<'_, '_>,
    keys: PlacePerpOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_perp_order_verify_writable_privileges<'me, 'info>(
    accounts: PlacePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_perp_order_verify_signer_privileges<'me, 'info>(
    accounts: PlacePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_perp_order_verify_account_privileges<'me, 'info>(
    accounts: PlacePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_perp_order_verify_writable_privileges(accounts)?;
    place_perp_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const CANCEL_ORDER_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct CancelOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CancelOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<CancelOrderAccounts<'_, '_>> for CancelOrderKeys {
    fn from(accounts: CancelOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<CancelOrderKeys> for [AccountMeta; CANCEL_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: CancelOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; CANCEL_ORDER_IX_ACCOUNTS_LEN]> for CancelOrderKeys {
    fn from(pubkeys: [Pubkey; CANCEL_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<CancelOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; CANCEL_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: CancelOrderAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; CANCEL_ORDER_IX_ACCOUNTS_LEN]>
for CancelOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; CANCEL_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const CANCEL_ORDER_IX_DISCM: [u8; 8] = [95, 129, 237, 240, 8, 49, 223, 132];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CancelOrderIxArgs {
    pub order_id: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct CancelOrderIxData(pub CancelOrderIxArgs);
impl From<CancelOrderIxArgs> for CancelOrderIxData {
    fn from(args: CancelOrderIxArgs) -> Self {
        Self(args)
    }
}
impl CancelOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != CANCEL_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        CANCEL_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(CancelOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&CANCEL_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn cancel_order_ix_with_program_id(
    program_id: Pubkey,
    keys: CancelOrderKeys,
    args: CancelOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; CANCEL_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: CancelOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn cancel_order_ix(
    keys: CancelOrderKeys,
    args: CancelOrderIxArgs,
) -> std::io::Result<Instruction> {
    cancel_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn cancel_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrderAccounts<'_, '_>,
    args: CancelOrderIxArgs,
) -> ProgramResult {
    let keys: CancelOrderKeys = accounts.into();
    let ix = cancel_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn cancel_order_invoke(
    accounts: CancelOrderAccounts<'_, '_>,
    args: CancelOrderIxArgs,
) -> ProgramResult {
    cancel_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn cancel_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrderAccounts<'_, '_>,
    args: CancelOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: CancelOrderKeys = accounts.into();
    let ix = cancel_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn cancel_order_invoke_signed(
    accounts: CancelOrderAccounts<'_, '_>,
    args: CancelOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    cancel_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn cancel_order_verify_account_keys(
    accounts: CancelOrderAccounts<'_, '_>,
    keys: CancelOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn cancel_order_verify_writable_privileges<'me, 'info>(
    accounts: CancelOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn cancel_order_verify_signer_privileges<'me, 'info>(
    accounts: CancelOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn cancel_order_verify_account_privileges<'me, 'info>(
    accounts: CancelOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    cancel_order_verify_writable_privileges(accounts)?;
    cancel_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct CancelOrderByUserIdAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CancelOrderByUserIdKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<CancelOrderByUserIdAccounts<'_, '_>> for CancelOrderByUserIdKeys {
    fn from(accounts: CancelOrderByUserIdAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<CancelOrderByUserIdKeys>
for [AccountMeta; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN] {
    fn from(keys: CancelOrderByUserIdKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN]>
for CancelOrderByUserIdKeys {
    fn from(pubkeys: [Pubkey; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<CancelOrderByUserIdAccounts<'_, 'info>>
for [AccountInfo<'info>; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN] {
    fn from(accounts: CancelOrderByUserIdAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN]>
for CancelOrderByUserIdAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const CANCEL_ORDER_BY_USER_ID_IX_DISCM: [u8; 8] = [
    107,
    211,
    250,
    133,
    18,
    37,
    57,
    100,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CancelOrderByUserIdIxArgs {
    pub user_order_id: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct CancelOrderByUserIdIxData(pub CancelOrderByUserIdIxArgs);
impl From<CancelOrderByUserIdIxArgs> for CancelOrderByUserIdIxData {
    fn from(args: CancelOrderByUserIdIxArgs) -> Self {
        Self(args)
    }
}
impl CancelOrderByUserIdIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != CANCEL_ORDER_BY_USER_ID_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        CANCEL_ORDER_BY_USER_ID_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(CancelOrderByUserIdIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&CANCEL_ORDER_BY_USER_ID_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn cancel_order_by_user_id_ix_with_program_id(
    program_id: Pubkey,
    keys: CancelOrderByUserIdKeys,
    args: CancelOrderByUserIdIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; CANCEL_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN] = keys.into();
    let data: CancelOrderByUserIdIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn cancel_order_by_user_id_ix(
    keys: CancelOrderByUserIdKeys,
    args: CancelOrderByUserIdIxArgs,
) -> std::io::Result<Instruction> {
    cancel_order_by_user_id_ix_with_program_id(crate::ID, keys, args)
}
pub fn cancel_order_by_user_id_invoke_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrderByUserIdAccounts<'_, '_>,
    args: CancelOrderByUserIdIxArgs,
) -> ProgramResult {
    let keys: CancelOrderByUserIdKeys = accounts.into();
    let ix = cancel_order_by_user_id_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn cancel_order_by_user_id_invoke(
    accounts: CancelOrderByUserIdAccounts<'_, '_>,
    args: CancelOrderByUserIdIxArgs,
) -> ProgramResult {
    cancel_order_by_user_id_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn cancel_order_by_user_id_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrderByUserIdAccounts<'_, '_>,
    args: CancelOrderByUserIdIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: CancelOrderByUserIdKeys = accounts.into();
    let ix = cancel_order_by_user_id_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn cancel_order_by_user_id_invoke_signed(
    accounts: CancelOrderByUserIdAccounts<'_, '_>,
    args: CancelOrderByUserIdIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    cancel_order_by_user_id_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn cancel_order_by_user_id_verify_account_keys(
    accounts: CancelOrderByUserIdAccounts<'_, '_>,
    keys: CancelOrderByUserIdKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn cancel_order_by_user_id_verify_writable_privileges<'me, 'info>(
    accounts: CancelOrderByUserIdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn cancel_order_by_user_id_verify_signer_privileges<'me, 'info>(
    accounts: CancelOrderByUserIdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn cancel_order_by_user_id_verify_account_privileges<'me, 'info>(
    accounts: CancelOrderByUserIdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    cancel_order_by_user_id_verify_writable_privileges(accounts)?;
    cancel_order_by_user_id_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const CANCEL_ORDERS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct CancelOrdersAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CancelOrdersKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<CancelOrdersAccounts<'_, '_>> for CancelOrdersKeys {
    fn from(accounts: CancelOrdersAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<CancelOrdersKeys> for [AccountMeta; CANCEL_ORDERS_IX_ACCOUNTS_LEN] {
    fn from(keys: CancelOrdersKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; CANCEL_ORDERS_IX_ACCOUNTS_LEN]> for CancelOrdersKeys {
    fn from(pubkeys: [Pubkey; CANCEL_ORDERS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<CancelOrdersAccounts<'_, 'info>>
for [AccountInfo<'info>; CANCEL_ORDERS_IX_ACCOUNTS_LEN] {
    fn from(accounts: CancelOrdersAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; CANCEL_ORDERS_IX_ACCOUNTS_LEN]>
for CancelOrdersAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; CANCEL_ORDERS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const CANCEL_ORDERS_IX_DISCM: [u8; 8] = [238, 225, 95, 158, 227, 103, 8, 194];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CancelOrdersIxArgs {
    pub market_type: Option<MarketType>,
    pub market_index: Option<u16>,
    pub direction: Option<PositionDirection>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct CancelOrdersIxData(pub CancelOrdersIxArgs);
impl From<CancelOrdersIxArgs> for CancelOrdersIxData {
    fn from(args: CancelOrdersIxArgs) -> Self {
        Self(args)
    }
}
impl CancelOrdersIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != CANCEL_ORDERS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        CANCEL_ORDERS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(CancelOrdersIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&CANCEL_ORDERS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn cancel_orders_ix_with_program_id(
    program_id: Pubkey,
    keys: CancelOrdersKeys,
    args: CancelOrdersIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; CANCEL_ORDERS_IX_ACCOUNTS_LEN] = keys.into();
    let data: CancelOrdersIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn cancel_orders_ix(
    keys: CancelOrdersKeys,
    args: CancelOrdersIxArgs,
) -> std::io::Result<Instruction> {
    cancel_orders_ix_with_program_id(crate::ID, keys, args)
}
pub fn cancel_orders_invoke_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrdersAccounts<'_, '_>,
    args: CancelOrdersIxArgs,
) -> ProgramResult {
    let keys: CancelOrdersKeys = accounts.into();
    let ix = cancel_orders_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn cancel_orders_invoke(
    accounts: CancelOrdersAccounts<'_, '_>,
    args: CancelOrdersIxArgs,
) -> ProgramResult {
    cancel_orders_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn cancel_orders_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrdersAccounts<'_, '_>,
    args: CancelOrdersIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: CancelOrdersKeys = accounts.into();
    let ix = cancel_orders_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn cancel_orders_invoke_signed(
    accounts: CancelOrdersAccounts<'_, '_>,
    args: CancelOrdersIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    cancel_orders_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn cancel_orders_verify_account_keys(
    accounts: CancelOrdersAccounts<'_, '_>,
    keys: CancelOrdersKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn cancel_orders_verify_writable_privileges<'me, 'info>(
    accounts: CancelOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn cancel_orders_verify_signer_privileges<'me, 'info>(
    accounts: CancelOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn cancel_orders_verify_account_privileges<'me, 'info>(
    accounts: CancelOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    cancel_orders_verify_writable_privileges(accounts)?;
    cancel_orders_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct CancelOrdersByIdsAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CancelOrdersByIdsKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<CancelOrdersByIdsAccounts<'_, '_>> for CancelOrdersByIdsKeys {
    fn from(accounts: CancelOrdersByIdsAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<CancelOrdersByIdsKeys>
for [AccountMeta; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN] {
    fn from(keys: CancelOrdersByIdsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN]> for CancelOrdersByIdsKeys {
    fn from(pubkeys: [Pubkey; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<CancelOrdersByIdsAccounts<'_, 'info>>
for [AccountInfo<'info>; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN] {
    fn from(accounts: CancelOrdersByIdsAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN]>
for CancelOrdersByIdsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const CANCEL_ORDERS_BY_IDS_IX_DISCM: [u8; 8] = [134, 19, 144, 165, 94, 240, 210, 94];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CancelOrdersByIdsIxArgs {
    pub order_ids: Vec<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct CancelOrdersByIdsIxData(pub CancelOrdersByIdsIxArgs);
impl From<CancelOrdersByIdsIxArgs> for CancelOrdersByIdsIxData {
    fn from(args: CancelOrdersByIdsIxArgs) -> Self {
        Self(args)
    }
}
impl CancelOrdersByIdsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != CANCEL_ORDERS_BY_IDS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        CANCEL_ORDERS_BY_IDS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(CancelOrdersByIdsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&CANCEL_ORDERS_BY_IDS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn cancel_orders_by_ids_ix_with_program_id(
    program_id: Pubkey,
    keys: CancelOrdersByIdsKeys,
    args: CancelOrdersByIdsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; CANCEL_ORDERS_BY_IDS_IX_ACCOUNTS_LEN] = keys.into();
    let data: CancelOrdersByIdsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn cancel_orders_by_ids_ix(
    keys: CancelOrdersByIdsKeys,
    args: CancelOrdersByIdsIxArgs,
) -> std::io::Result<Instruction> {
    cancel_orders_by_ids_ix_with_program_id(crate::ID, keys, args)
}
pub fn cancel_orders_by_ids_invoke_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrdersByIdsAccounts<'_, '_>,
    args: CancelOrdersByIdsIxArgs,
) -> ProgramResult {
    let keys: CancelOrdersByIdsKeys = accounts.into();
    let ix = cancel_orders_by_ids_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn cancel_orders_by_ids_invoke(
    accounts: CancelOrdersByIdsAccounts<'_, '_>,
    args: CancelOrdersByIdsIxArgs,
) -> ProgramResult {
    cancel_orders_by_ids_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn cancel_orders_by_ids_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: CancelOrdersByIdsAccounts<'_, '_>,
    args: CancelOrdersByIdsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: CancelOrdersByIdsKeys = accounts.into();
    let ix = cancel_orders_by_ids_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn cancel_orders_by_ids_invoke_signed(
    accounts: CancelOrdersByIdsAccounts<'_, '_>,
    args: CancelOrdersByIdsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    cancel_orders_by_ids_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn cancel_orders_by_ids_verify_account_keys(
    accounts: CancelOrdersByIdsAccounts<'_, '_>,
    keys: CancelOrdersByIdsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn cancel_orders_by_ids_verify_writable_privileges<'me, 'info>(
    accounts: CancelOrdersByIdsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn cancel_orders_by_ids_verify_signer_privileges<'me, 'info>(
    accounts: CancelOrdersByIdsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn cancel_orders_by_ids_verify_account_privileges<'me, 'info>(
    accounts: CancelOrdersByIdsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    cancel_orders_by_ids_verify_writable_privileges(accounts)?;
    cancel_orders_by_ids_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const MODIFY_ORDER_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct ModifyOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ModifyOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<ModifyOrderAccounts<'_, '_>> for ModifyOrderKeys {
    fn from(accounts: ModifyOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<ModifyOrderKeys> for [AccountMeta; MODIFY_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: ModifyOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; MODIFY_ORDER_IX_ACCOUNTS_LEN]> for ModifyOrderKeys {
    fn from(pubkeys: [Pubkey; MODIFY_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<ModifyOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; MODIFY_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: ModifyOrderAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; MODIFY_ORDER_IX_ACCOUNTS_LEN]>
for ModifyOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; MODIFY_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const MODIFY_ORDER_IX_DISCM: [u8; 8] = [47, 124, 117, 255, 201, 197, 130, 94];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ModifyOrderIxArgs {
    pub order_id: Option<u32>,
    pub modify_order_params: ModifyOrderParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct ModifyOrderIxData(pub ModifyOrderIxArgs);
impl From<ModifyOrderIxArgs> for ModifyOrderIxData {
    fn from(args: ModifyOrderIxArgs) -> Self {
        Self(args)
    }
}
impl ModifyOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != MODIFY_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        MODIFY_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(ModifyOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&MODIFY_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn modify_order_ix_with_program_id(
    program_id: Pubkey,
    keys: ModifyOrderKeys,
    args: ModifyOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; MODIFY_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: ModifyOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn modify_order_ix(
    keys: ModifyOrderKeys,
    args: ModifyOrderIxArgs,
) -> std::io::Result<Instruction> {
    modify_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn modify_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ModifyOrderAccounts<'_, '_>,
    args: ModifyOrderIxArgs,
) -> ProgramResult {
    let keys: ModifyOrderKeys = accounts.into();
    let ix = modify_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn modify_order_invoke(
    accounts: ModifyOrderAccounts<'_, '_>,
    args: ModifyOrderIxArgs,
) -> ProgramResult {
    modify_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn modify_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ModifyOrderAccounts<'_, '_>,
    args: ModifyOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ModifyOrderKeys = accounts.into();
    let ix = modify_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn modify_order_invoke_signed(
    accounts: ModifyOrderAccounts<'_, '_>,
    args: ModifyOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    modify_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn modify_order_verify_account_keys(
    accounts: ModifyOrderAccounts<'_, '_>,
    keys: ModifyOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn modify_order_verify_writable_privileges<'me, 'info>(
    accounts: ModifyOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn modify_order_verify_signer_privileges<'me, 'info>(
    accounts: ModifyOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn modify_order_verify_account_privileges<'me, 'info>(
    accounts: ModifyOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    modify_order_verify_writable_privileges(accounts)?;
    modify_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct ModifyOrderByUserIdAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ModifyOrderByUserIdKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<ModifyOrderByUserIdAccounts<'_, '_>> for ModifyOrderByUserIdKeys {
    fn from(accounts: ModifyOrderByUserIdAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<ModifyOrderByUserIdKeys>
for [AccountMeta; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN] {
    fn from(keys: ModifyOrderByUserIdKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN]>
for ModifyOrderByUserIdKeys {
    fn from(pubkeys: [Pubkey; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<ModifyOrderByUserIdAccounts<'_, 'info>>
for [AccountInfo<'info>; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN] {
    fn from(accounts: ModifyOrderByUserIdAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN]>
for ModifyOrderByUserIdAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const MODIFY_ORDER_BY_USER_ID_IX_DISCM: [u8; 8] = [
    158,
    77,
    4,
    253,
    252,
    194,
    161,
    179,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ModifyOrderByUserIdIxArgs {
    pub user_order_id: u8,
    pub modify_order_params: ModifyOrderParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct ModifyOrderByUserIdIxData(pub ModifyOrderByUserIdIxArgs);
impl From<ModifyOrderByUserIdIxArgs> for ModifyOrderByUserIdIxData {
    fn from(args: ModifyOrderByUserIdIxArgs) -> Self {
        Self(args)
    }
}
impl ModifyOrderByUserIdIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != MODIFY_ORDER_BY_USER_ID_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        MODIFY_ORDER_BY_USER_ID_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(ModifyOrderByUserIdIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&MODIFY_ORDER_BY_USER_ID_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn modify_order_by_user_id_ix_with_program_id(
    program_id: Pubkey,
    keys: ModifyOrderByUserIdKeys,
    args: ModifyOrderByUserIdIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; MODIFY_ORDER_BY_USER_ID_IX_ACCOUNTS_LEN] = keys.into();
    let data: ModifyOrderByUserIdIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn modify_order_by_user_id_ix(
    keys: ModifyOrderByUserIdKeys,
    args: ModifyOrderByUserIdIxArgs,
) -> std::io::Result<Instruction> {
    modify_order_by_user_id_ix_with_program_id(crate::ID, keys, args)
}
pub fn modify_order_by_user_id_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ModifyOrderByUserIdAccounts<'_, '_>,
    args: ModifyOrderByUserIdIxArgs,
) -> ProgramResult {
    let keys: ModifyOrderByUserIdKeys = accounts.into();
    let ix = modify_order_by_user_id_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn modify_order_by_user_id_invoke(
    accounts: ModifyOrderByUserIdAccounts<'_, '_>,
    args: ModifyOrderByUserIdIxArgs,
) -> ProgramResult {
    modify_order_by_user_id_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn modify_order_by_user_id_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ModifyOrderByUserIdAccounts<'_, '_>,
    args: ModifyOrderByUserIdIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ModifyOrderByUserIdKeys = accounts.into();
    let ix = modify_order_by_user_id_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn modify_order_by_user_id_invoke_signed(
    accounts: ModifyOrderByUserIdAccounts<'_, '_>,
    args: ModifyOrderByUserIdIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    modify_order_by_user_id_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn modify_order_by_user_id_verify_account_keys(
    accounts: ModifyOrderByUserIdAccounts<'_, '_>,
    keys: ModifyOrderByUserIdKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn modify_order_by_user_id_verify_writable_privileges<'me, 'info>(
    accounts: ModifyOrderByUserIdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn modify_order_by_user_id_verify_signer_privileges<'me, 'info>(
    accounts: ModifyOrderByUserIdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn modify_order_by_user_id_verify_account_privileges<'me, 'info>(
    accounts: ModifyOrderByUserIdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    modify_order_by_user_id_verify_writable_privileges(accounts)?;
    modify_order_by_user_id_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct PlaceAndTakePerpOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceAndTakePerpOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
}
impl From<PlaceAndTakePerpOrderAccounts<'_, '_>> for PlaceAndTakePerpOrderKeys {
    fn from(accounts: PlaceAndTakePerpOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlaceAndTakePerpOrderKeys>
for [AccountMeta; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceAndTakePerpOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndTakePerpOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
        }
    }
}
impl<'info> From<PlaceAndTakePerpOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceAndTakePerpOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndTakePerpOrderAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
        }
    }
}
pub const PLACE_AND_TAKE_PERP_ORDER_IX_DISCM: [u8; 8] = [
    213,
    51,
    1,
    187,
    108,
    220,
    230,
    224,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceAndTakePerpOrderIxArgs {
    pub params: OrderParams,
    pub success_condition: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceAndTakePerpOrderIxData(pub PlaceAndTakePerpOrderIxArgs);
impl From<PlaceAndTakePerpOrderIxArgs> for PlaceAndTakePerpOrderIxData {
    fn from(args: PlaceAndTakePerpOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceAndTakePerpOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_AND_TAKE_PERP_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_AND_TAKE_PERP_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceAndTakePerpOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_AND_TAKE_PERP_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_and_take_perp_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceAndTakePerpOrderKeys,
    args: PlaceAndTakePerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_AND_TAKE_PERP_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceAndTakePerpOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_and_take_perp_order_ix(
    keys: PlaceAndTakePerpOrderKeys,
    args: PlaceAndTakePerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_and_take_perp_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_and_take_perp_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndTakePerpOrderAccounts<'_, '_>,
    args: PlaceAndTakePerpOrderIxArgs,
) -> ProgramResult {
    let keys: PlaceAndTakePerpOrderKeys = accounts.into();
    let ix = place_and_take_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_and_take_perp_order_invoke(
    accounts: PlaceAndTakePerpOrderAccounts<'_, '_>,
    args: PlaceAndTakePerpOrderIxArgs,
) -> ProgramResult {
    place_and_take_perp_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_and_take_perp_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndTakePerpOrderAccounts<'_, '_>,
    args: PlaceAndTakePerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceAndTakePerpOrderKeys = accounts.into();
    let ix = place_and_take_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_and_take_perp_order_invoke_signed(
    accounts: PlaceAndTakePerpOrderAccounts<'_, '_>,
    args: PlaceAndTakePerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_and_take_perp_order_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn place_and_take_perp_order_verify_account_keys(
    accounts: PlaceAndTakePerpOrderAccounts<'_, '_>,
    keys: PlaceAndTakePerpOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_and_take_perp_order_verify_writable_privileges<'me, 'info>(
    accounts: PlaceAndTakePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_and_take_perp_order_verify_signer_privileges<'me, 'info>(
    accounts: PlaceAndTakePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_and_take_perp_order_verify_account_privileges<'me, 'info>(
    accounts: PlaceAndTakePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_and_take_perp_order_verify_writable_privileges(accounts)?;
    place_and_take_perp_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct PlaceAndMakePerpOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub taker: &'me AccountInfo<'info>,
    pub taker_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceAndMakePerpOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub taker: Pubkey,
    pub taker_stats: Pubkey,
    pub authority: Pubkey,
}
impl From<PlaceAndMakePerpOrderAccounts<'_, '_>> for PlaceAndMakePerpOrderKeys {
    fn from(accounts: PlaceAndMakePerpOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            taker: *accounts.taker.key,
            taker_stats: *accounts.taker_stats.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlaceAndMakePerpOrderKeys>
for [AccountMeta; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceAndMakePerpOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.taker,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.taker_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndMakePerpOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            taker: pubkeys[3],
            taker_stats: pubkeys[4],
            authority: pubkeys[5],
        }
    }
}
impl<'info> From<PlaceAndMakePerpOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceAndMakePerpOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.taker.clone(),
            accounts.taker_stats.clone(),
            accounts.authority.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndMakePerpOrderAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            taker: &arr[3],
            taker_stats: &arr[4],
            authority: &arr[5],
        }
    }
}
pub const PLACE_AND_MAKE_PERP_ORDER_IX_DISCM: [u8; 8] = [
    149,
    117,
    11,
    237,
    47,
    95,
    89,
    237,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceAndMakePerpOrderIxArgs {
    pub params: OrderParams,
    pub taker_order_id: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceAndMakePerpOrderIxData(pub PlaceAndMakePerpOrderIxArgs);
impl From<PlaceAndMakePerpOrderIxArgs> for PlaceAndMakePerpOrderIxData {
    fn from(args: PlaceAndMakePerpOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceAndMakePerpOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_AND_MAKE_PERP_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_AND_MAKE_PERP_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceAndMakePerpOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_AND_MAKE_PERP_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_and_make_perp_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceAndMakePerpOrderKeys,
    args: PlaceAndMakePerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_AND_MAKE_PERP_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceAndMakePerpOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_and_make_perp_order_ix(
    keys: PlaceAndMakePerpOrderKeys,
    args: PlaceAndMakePerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_and_make_perp_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_and_make_perp_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndMakePerpOrderAccounts<'_, '_>,
    args: PlaceAndMakePerpOrderIxArgs,
) -> ProgramResult {
    let keys: PlaceAndMakePerpOrderKeys = accounts.into();
    let ix = place_and_make_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_and_make_perp_order_invoke(
    accounts: PlaceAndMakePerpOrderAccounts<'_, '_>,
    args: PlaceAndMakePerpOrderIxArgs,
) -> ProgramResult {
    place_and_make_perp_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_and_make_perp_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndMakePerpOrderAccounts<'_, '_>,
    args: PlaceAndMakePerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceAndMakePerpOrderKeys = accounts.into();
    let ix = place_and_make_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_and_make_perp_order_invoke_signed(
    accounts: PlaceAndMakePerpOrderAccounts<'_, '_>,
    args: PlaceAndMakePerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_and_make_perp_order_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn place_and_make_perp_order_verify_account_keys(
    accounts: PlaceAndMakePerpOrderAccounts<'_, '_>,
    keys: PlaceAndMakePerpOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.taker.key, keys.taker),
        (*accounts.taker_stats.key, keys.taker_stats),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_and_make_perp_order_verify_writable_privileges<'me, 'info>(
    accounts: PlaceAndMakePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.taker,
        accounts.taker_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_and_make_perp_order_verify_signer_privileges<'me, 'info>(
    accounts: PlaceAndMakePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_and_make_perp_order_verify_account_privileges<'me, 'info>(
    accounts: PlaceAndMakePerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_and_make_perp_order_verify_writable_privileges(accounts)?;
    place_and_make_perp_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct PlaceSwiftTakerOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub ix_sysvar: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceSwiftTakerOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub ix_sysvar: Pubkey,
}
impl From<PlaceSwiftTakerOrderAccounts<'_, '_>> for PlaceSwiftTakerOrderKeys {
    fn from(accounts: PlaceSwiftTakerOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            ix_sysvar: *accounts.ix_sysvar.key,
        }
    }
}
impl From<PlaceSwiftTakerOrderKeys>
for [AccountMeta; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceSwiftTakerOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.ix_sysvar,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN]>
for PlaceSwiftTakerOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            ix_sysvar: pubkeys[4],
        }
    }
}
impl<'info> From<PlaceSwiftTakerOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceSwiftTakerOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.ix_sysvar.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN]>
for PlaceSwiftTakerOrderAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            ix_sysvar: &arr[4],
        }
    }
}
pub const PLACE_SWIFT_TAKER_ORDER_IX_DISCM: [u8; 8] = [
    50,
    89,
    120,
    78,
    254,
    15,
    104,
    140,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceSwiftTakerOrderIxArgs {
    pub swift_message_bytes: Vec<u8>,
    pub swift_order_params_message_bytes: Vec<u8>,
    pub swift_message_signature: [u8; 64],
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceSwiftTakerOrderIxData(pub PlaceSwiftTakerOrderIxArgs);
impl From<PlaceSwiftTakerOrderIxArgs> for PlaceSwiftTakerOrderIxData {
    fn from(args: PlaceSwiftTakerOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceSwiftTakerOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_SWIFT_TAKER_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_SWIFT_TAKER_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceSwiftTakerOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_SWIFT_TAKER_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_swift_taker_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceSwiftTakerOrderKeys,
    args: PlaceSwiftTakerOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_SWIFT_TAKER_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceSwiftTakerOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_swift_taker_order_ix(
    keys: PlaceSwiftTakerOrderKeys,
    args: PlaceSwiftTakerOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_swift_taker_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_swift_taker_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceSwiftTakerOrderAccounts<'_, '_>,
    args: PlaceSwiftTakerOrderIxArgs,
) -> ProgramResult {
    let keys: PlaceSwiftTakerOrderKeys = accounts.into();
    let ix = place_swift_taker_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_swift_taker_order_invoke(
    accounts: PlaceSwiftTakerOrderAccounts<'_, '_>,
    args: PlaceSwiftTakerOrderIxArgs,
) -> ProgramResult {
    place_swift_taker_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_swift_taker_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceSwiftTakerOrderAccounts<'_, '_>,
    args: PlaceSwiftTakerOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceSwiftTakerOrderKeys = accounts.into();
    let ix = place_swift_taker_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_swift_taker_order_invoke_signed(
    accounts: PlaceSwiftTakerOrderAccounts<'_, '_>,
    args: PlaceSwiftTakerOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_swift_taker_order_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn place_swift_taker_order_verify_account_keys(
    accounts: PlaceSwiftTakerOrderAccounts<'_, '_>,
    keys: PlaceSwiftTakerOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.ix_sysvar.key, keys.ix_sysvar),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_swift_taker_order_verify_writable_privileges<'me, 'info>(
    accounts: PlaceSwiftTakerOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_swift_taker_order_verify_signer_privileges<'me, 'info>(
    accounts: PlaceSwiftTakerOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_swift_taker_order_verify_account_privileges<'me, 'info>(
    accounts: PlaceSwiftTakerOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_swift_taker_order_verify_writable_privileges(accounts)?;
    place_swift_taker_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct PlaceSpotOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceSpotOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<PlaceSpotOrderAccounts<'_, '_>> for PlaceSpotOrderKeys {
    fn from(accounts: PlaceSpotOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlaceSpotOrderKeys> for [AccountMeta; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceSpotOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN]> for PlaceSpotOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<PlaceSpotOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceSpotOrderAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN]>
for PlaceSpotOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const PLACE_SPOT_ORDER_IX_DISCM: [u8; 8] = [45, 79, 81, 160, 248, 90, 91, 220];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceSpotOrderIxArgs {
    pub params: OrderParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceSpotOrderIxData(pub PlaceSpotOrderIxArgs);
impl From<PlaceSpotOrderIxArgs> for PlaceSpotOrderIxData {
    fn from(args: PlaceSpotOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceSpotOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_SPOT_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_SPOT_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceSpotOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_SPOT_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_spot_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceSpotOrderKeys,
    args: PlaceSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_SPOT_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceSpotOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_spot_order_ix(
    keys: PlaceSpotOrderKeys,
    args: PlaceSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_spot_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_spot_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceSpotOrderAccounts<'_, '_>,
    args: PlaceSpotOrderIxArgs,
) -> ProgramResult {
    let keys: PlaceSpotOrderKeys = accounts.into();
    let ix = place_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_spot_order_invoke(
    accounts: PlaceSpotOrderAccounts<'_, '_>,
    args: PlaceSpotOrderIxArgs,
) -> ProgramResult {
    place_spot_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_spot_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceSpotOrderAccounts<'_, '_>,
    args: PlaceSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceSpotOrderKeys = accounts.into();
    let ix = place_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_spot_order_invoke_signed(
    accounts: PlaceSpotOrderAccounts<'_, '_>,
    args: PlaceSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_spot_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn place_spot_order_verify_account_keys(
    accounts: PlaceSpotOrderAccounts<'_, '_>,
    keys: PlaceSpotOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_spot_order_verify_writable_privileges<'me, 'info>(
    accounts: PlaceSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_spot_order_verify_signer_privileges<'me, 'info>(
    accounts: PlaceSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_spot_order_verify_account_privileges<'me, 'info>(
    accounts: PlaceSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_spot_order_verify_writable_privileges(accounts)?;
    place_spot_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct PlaceAndTakeSpotOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceAndTakeSpotOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
}
impl From<PlaceAndTakeSpotOrderAccounts<'_, '_>> for PlaceAndTakeSpotOrderKeys {
    fn from(accounts: PlaceAndTakeSpotOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlaceAndTakeSpotOrderKeys>
for [AccountMeta; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceAndTakeSpotOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndTakeSpotOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
        }
    }
}
impl<'info> From<PlaceAndTakeSpotOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceAndTakeSpotOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndTakeSpotOrderAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
        }
    }
}
pub const PLACE_AND_TAKE_SPOT_ORDER_IX_DISCM: [u8; 8] = [
    191,
    3,
    138,
    71,
    114,
    198,
    202,
    100,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceAndTakeSpotOrderIxArgs {
    pub params: OrderParams,
    pub fulfillment_type: Option<SpotFulfillmentType>,
    pub maker_order_id: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceAndTakeSpotOrderIxData(pub PlaceAndTakeSpotOrderIxArgs);
impl From<PlaceAndTakeSpotOrderIxArgs> for PlaceAndTakeSpotOrderIxData {
    fn from(args: PlaceAndTakeSpotOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceAndTakeSpotOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_AND_TAKE_SPOT_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_AND_TAKE_SPOT_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceAndTakeSpotOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_AND_TAKE_SPOT_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_and_take_spot_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceAndTakeSpotOrderKeys,
    args: PlaceAndTakeSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_AND_TAKE_SPOT_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceAndTakeSpotOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_and_take_spot_order_ix(
    keys: PlaceAndTakeSpotOrderKeys,
    args: PlaceAndTakeSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_and_take_spot_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_and_take_spot_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndTakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndTakeSpotOrderIxArgs,
) -> ProgramResult {
    let keys: PlaceAndTakeSpotOrderKeys = accounts.into();
    let ix = place_and_take_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_and_take_spot_order_invoke(
    accounts: PlaceAndTakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndTakeSpotOrderIxArgs,
) -> ProgramResult {
    place_and_take_spot_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_and_take_spot_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndTakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndTakeSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceAndTakeSpotOrderKeys = accounts.into();
    let ix = place_and_take_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_and_take_spot_order_invoke_signed(
    accounts: PlaceAndTakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndTakeSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_and_take_spot_order_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn place_and_take_spot_order_verify_account_keys(
    accounts: PlaceAndTakeSpotOrderAccounts<'_, '_>,
    keys: PlaceAndTakeSpotOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_and_take_spot_order_verify_writable_privileges<'me, 'info>(
    accounts: PlaceAndTakeSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_and_take_spot_order_verify_signer_privileges<'me, 'info>(
    accounts: PlaceAndTakeSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_and_take_spot_order_verify_account_privileges<'me, 'info>(
    accounts: PlaceAndTakeSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_and_take_spot_order_verify_writable_privileges(accounts)?;
    place_and_take_spot_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct PlaceAndMakeSpotOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub taker: &'me AccountInfo<'info>,
    pub taker_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceAndMakeSpotOrderKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub taker: Pubkey,
    pub taker_stats: Pubkey,
    pub authority: Pubkey,
}
impl From<PlaceAndMakeSpotOrderAccounts<'_, '_>> for PlaceAndMakeSpotOrderKeys {
    fn from(accounts: PlaceAndMakeSpotOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            taker: *accounts.taker.key,
            taker_stats: *accounts.taker_stats.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlaceAndMakeSpotOrderKeys>
for [AccountMeta; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceAndMakeSpotOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.taker,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.taker_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndMakeSpotOrderKeys {
    fn from(pubkeys: [Pubkey; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            taker: pubkeys[3],
            taker_stats: pubkeys[4],
            authority: pubkeys[5],
        }
    }
}
impl<'info> From<PlaceAndMakeSpotOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceAndMakeSpotOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.taker.clone(),
            accounts.taker_stats.clone(),
            accounts.authority.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN]>
for PlaceAndMakeSpotOrderAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            taker: &arr[3],
            taker_stats: &arr[4],
            authority: &arr[5],
        }
    }
}
pub const PLACE_AND_MAKE_SPOT_ORDER_IX_DISCM: [u8; 8] = [
    149,
    158,
    85,
    66,
    239,
    9,
    243,
    98,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceAndMakeSpotOrderIxArgs {
    pub params: OrderParams,
    pub taker_order_id: u32,
    pub fulfillment_type: Option<SpotFulfillmentType>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceAndMakeSpotOrderIxData(pub PlaceAndMakeSpotOrderIxArgs);
impl From<PlaceAndMakeSpotOrderIxArgs> for PlaceAndMakeSpotOrderIxData {
    fn from(args: PlaceAndMakeSpotOrderIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceAndMakeSpotOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_AND_MAKE_SPOT_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_AND_MAKE_SPOT_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceAndMakeSpotOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_AND_MAKE_SPOT_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_and_make_spot_order_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceAndMakeSpotOrderKeys,
    args: PlaceAndMakeSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_AND_MAKE_SPOT_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceAndMakeSpotOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_and_make_spot_order_ix(
    keys: PlaceAndMakeSpotOrderKeys,
    args: PlaceAndMakeSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    place_and_make_spot_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_and_make_spot_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndMakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndMakeSpotOrderIxArgs,
) -> ProgramResult {
    let keys: PlaceAndMakeSpotOrderKeys = accounts.into();
    let ix = place_and_make_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_and_make_spot_order_invoke(
    accounts: PlaceAndMakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndMakeSpotOrderIxArgs,
) -> ProgramResult {
    place_and_make_spot_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_and_make_spot_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceAndMakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndMakeSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceAndMakeSpotOrderKeys = accounts.into();
    let ix = place_and_make_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_and_make_spot_order_invoke_signed(
    accounts: PlaceAndMakeSpotOrderAccounts<'_, '_>,
    args: PlaceAndMakeSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_and_make_spot_order_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn place_and_make_spot_order_verify_account_keys(
    accounts: PlaceAndMakeSpotOrderAccounts<'_, '_>,
    keys: PlaceAndMakeSpotOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.taker.key, keys.taker),
        (*accounts.taker_stats.key, keys.taker_stats),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_and_make_spot_order_verify_writable_privileges<'me, 'info>(
    accounts: PlaceAndMakeSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.taker,
        accounts.taker_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_and_make_spot_order_verify_signer_privileges<'me, 'info>(
    accounts: PlaceAndMakeSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_and_make_spot_order_verify_account_privileges<'me, 'info>(
    accounts: PlaceAndMakeSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_and_make_spot_order_verify_writable_privileges(accounts)?;
    place_and_make_spot_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PLACE_ORDERS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct PlaceOrdersAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PlaceOrdersKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<PlaceOrdersAccounts<'_, '_>> for PlaceOrdersKeys {
    fn from(accounts: PlaceOrdersAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<PlaceOrdersKeys> for [AccountMeta; PLACE_ORDERS_IX_ACCOUNTS_LEN] {
    fn from(keys: PlaceOrdersKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; PLACE_ORDERS_IX_ACCOUNTS_LEN]> for PlaceOrdersKeys {
    fn from(pubkeys: [Pubkey; PLACE_ORDERS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<PlaceOrdersAccounts<'_, 'info>>
for [AccountInfo<'info>; PLACE_ORDERS_IX_ACCOUNTS_LEN] {
    fn from(accounts: PlaceOrdersAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; PLACE_ORDERS_IX_ACCOUNTS_LEN]>
for PlaceOrdersAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; PLACE_ORDERS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const PLACE_ORDERS_IX_DISCM: [u8; 8] = [60, 63, 50, 123, 12, 197, 60, 190];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PlaceOrdersIxArgs {
    pub params: Vec<OrderParams>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PlaceOrdersIxData(pub PlaceOrdersIxArgs);
impl From<PlaceOrdersIxArgs> for PlaceOrdersIxData {
    fn from(args: PlaceOrdersIxArgs) -> Self {
        Self(args)
    }
}
impl PlaceOrdersIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PLACE_ORDERS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PLACE_ORDERS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PlaceOrdersIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PLACE_ORDERS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn place_orders_ix_with_program_id(
    program_id: Pubkey,
    keys: PlaceOrdersKeys,
    args: PlaceOrdersIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PLACE_ORDERS_IX_ACCOUNTS_LEN] = keys.into();
    let data: PlaceOrdersIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn place_orders_ix(
    keys: PlaceOrdersKeys,
    args: PlaceOrdersIxArgs,
) -> std::io::Result<Instruction> {
    place_orders_ix_with_program_id(crate::ID, keys, args)
}
pub fn place_orders_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PlaceOrdersAccounts<'_, '_>,
    args: PlaceOrdersIxArgs,
) -> ProgramResult {
    let keys: PlaceOrdersKeys = accounts.into();
    let ix = place_orders_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn place_orders_invoke(
    accounts: PlaceOrdersAccounts<'_, '_>,
    args: PlaceOrdersIxArgs,
) -> ProgramResult {
    place_orders_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn place_orders_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PlaceOrdersAccounts<'_, '_>,
    args: PlaceOrdersIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PlaceOrdersKeys = accounts.into();
    let ix = place_orders_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn place_orders_invoke_signed(
    accounts: PlaceOrdersAccounts<'_, '_>,
    args: PlaceOrdersIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    place_orders_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn place_orders_verify_account_keys(
    accounts: PlaceOrdersAccounts<'_, '_>,
    keys: PlaceOrdersKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn place_orders_verify_writable_privileges<'me, 'info>(
    accounts: PlaceOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn place_orders_verify_signer_privileges<'me, 'info>(
    accounts: PlaceOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn place_orders_verify_account_privileges<'me, 'info>(
    accounts: PlaceOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    place_orders_verify_writable_privileges(accounts)?;
    place_orders_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const BEGIN_SWAP_IX_ACCOUNTS_LEN: usize = 11;
#[derive(Copy, Clone, Debug)]
pub struct BeginSwapAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub out_spot_market_vault: &'me AccountInfo<'info>,
    pub in_spot_market_vault: &'me AccountInfo<'info>,
    pub out_token_account: &'me AccountInfo<'info>,
    pub in_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub instructions: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct BeginSwapKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub out_spot_market_vault: Pubkey,
    pub in_spot_market_vault: Pubkey,
    pub out_token_account: Pubkey,
    pub in_token_account: Pubkey,
    pub token_program: Pubkey,
    pub drift_signer: Pubkey,
    pub instructions: Pubkey,
}
impl From<BeginSwapAccounts<'_, '_>> for BeginSwapKeys {
    fn from(accounts: BeginSwapAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            out_spot_market_vault: *accounts.out_spot_market_vault.key,
            in_spot_market_vault: *accounts.in_spot_market_vault.key,
            out_token_account: *accounts.out_token_account.key,
            in_token_account: *accounts.in_token_account.key,
            token_program: *accounts.token_program.key,
            drift_signer: *accounts.drift_signer.key,
            instructions: *accounts.instructions.key,
        }
    }
}
impl From<BeginSwapKeys> for [AccountMeta; BEGIN_SWAP_IX_ACCOUNTS_LEN] {
    fn from(keys: BeginSwapKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.out_spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.in_spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.out_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.in_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.instructions,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; BEGIN_SWAP_IX_ACCOUNTS_LEN]> for BeginSwapKeys {
    fn from(pubkeys: [Pubkey; BEGIN_SWAP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            out_spot_market_vault: pubkeys[4],
            in_spot_market_vault: pubkeys[5],
            out_token_account: pubkeys[6],
            in_token_account: pubkeys[7],
            token_program: pubkeys[8],
            drift_signer: pubkeys[9],
            instructions: pubkeys[10],
        }
    }
}
impl<'info> From<BeginSwapAccounts<'_, 'info>>
for [AccountInfo<'info>; BEGIN_SWAP_IX_ACCOUNTS_LEN] {
    fn from(accounts: BeginSwapAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.out_spot_market_vault.clone(),
            accounts.in_spot_market_vault.clone(),
            accounts.out_token_account.clone(),
            accounts.in_token_account.clone(),
            accounts.token_program.clone(),
            accounts.drift_signer.clone(),
            accounts.instructions.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; BEGIN_SWAP_IX_ACCOUNTS_LEN]>
for BeginSwapAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; BEGIN_SWAP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            out_spot_market_vault: &arr[4],
            in_spot_market_vault: &arr[5],
            out_token_account: &arr[6],
            in_token_account: &arr[7],
            token_program: &arr[8],
            drift_signer: &arr[9],
            instructions: &arr[10],
        }
    }
}
pub const BEGIN_SWAP_IX_DISCM: [u8; 8] = [174, 109, 228, 1, 242, 105, 232, 105];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct BeginSwapIxArgs {
    pub in_market_index: u16,
    pub out_market_index: u16,
    pub amount_in: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct BeginSwapIxData(pub BeginSwapIxArgs);
impl From<BeginSwapIxArgs> for BeginSwapIxData {
    fn from(args: BeginSwapIxArgs) -> Self {
        Self(args)
    }
}
impl BeginSwapIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != BEGIN_SWAP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        BEGIN_SWAP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(BeginSwapIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&BEGIN_SWAP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn begin_swap_ix_with_program_id(
    program_id: Pubkey,
    keys: BeginSwapKeys,
    args: BeginSwapIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; BEGIN_SWAP_IX_ACCOUNTS_LEN] = keys.into();
    let data: BeginSwapIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn begin_swap_ix(
    keys: BeginSwapKeys,
    args: BeginSwapIxArgs,
) -> std::io::Result<Instruction> {
    begin_swap_ix_with_program_id(crate::ID, keys, args)
}
pub fn begin_swap_invoke_with_program_id(
    program_id: Pubkey,
    accounts: BeginSwapAccounts<'_, '_>,
    args: BeginSwapIxArgs,
) -> ProgramResult {
    let keys: BeginSwapKeys = accounts.into();
    let ix = begin_swap_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn begin_swap_invoke(
    accounts: BeginSwapAccounts<'_, '_>,
    args: BeginSwapIxArgs,
) -> ProgramResult {
    begin_swap_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn begin_swap_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: BeginSwapAccounts<'_, '_>,
    args: BeginSwapIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: BeginSwapKeys = accounts.into();
    let ix = begin_swap_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn begin_swap_invoke_signed(
    accounts: BeginSwapAccounts<'_, '_>,
    args: BeginSwapIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    begin_swap_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn begin_swap_verify_account_keys(
    accounts: BeginSwapAccounts<'_, '_>,
    keys: BeginSwapKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.out_spot_market_vault.key, keys.out_spot_market_vault),
        (*accounts.in_spot_market_vault.key, keys.in_spot_market_vault),
        (*accounts.out_token_account.key, keys.out_token_account),
        (*accounts.in_token_account.key, keys.in_token_account),
        (*accounts.token_program.key, keys.token_program),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.instructions.key, keys.instructions),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn begin_swap_verify_writable_privileges<'me, 'info>(
    accounts: BeginSwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.out_spot_market_vault,
        accounts.in_spot_market_vault,
        accounts.out_token_account,
        accounts.in_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn begin_swap_verify_signer_privileges<'me, 'info>(
    accounts: BeginSwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn begin_swap_verify_account_privileges<'me, 'info>(
    accounts: BeginSwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    begin_swap_verify_writable_privileges(accounts)?;
    begin_swap_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const END_SWAP_IX_ACCOUNTS_LEN: usize = 11;
#[derive(Copy, Clone, Debug)]
pub struct EndSwapAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub out_spot_market_vault: &'me AccountInfo<'info>,
    pub in_spot_market_vault: &'me AccountInfo<'info>,
    pub out_token_account: &'me AccountInfo<'info>,
    pub in_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub instructions: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct EndSwapKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub out_spot_market_vault: Pubkey,
    pub in_spot_market_vault: Pubkey,
    pub out_token_account: Pubkey,
    pub in_token_account: Pubkey,
    pub token_program: Pubkey,
    pub drift_signer: Pubkey,
    pub instructions: Pubkey,
}
impl From<EndSwapAccounts<'_, '_>> for EndSwapKeys {
    fn from(accounts: EndSwapAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            out_spot_market_vault: *accounts.out_spot_market_vault.key,
            in_spot_market_vault: *accounts.in_spot_market_vault.key,
            out_token_account: *accounts.out_token_account.key,
            in_token_account: *accounts.in_token_account.key,
            token_program: *accounts.token_program.key,
            drift_signer: *accounts.drift_signer.key,
            instructions: *accounts.instructions.key,
        }
    }
}
impl From<EndSwapKeys> for [AccountMeta; END_SWAP_IX_ACCOUNTS_LEN] {
    fn from(keys: EndSwapKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.out_spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.in_spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.out_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.in_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.instructions,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; END_SWAP_IX_ACCOUNTS_LEN]> for EndSwapKeys {
    fn from(pubkeys: [Pubkey; END_SWAP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            out_spot_market_vault: pubkeys[4],
            in_spot_market_vault: pubkeys[5],
            out_token_account: pubkeys[6],
            in_token_account: pubkeys[7],
            token_program: pubkeys[8],
            drift_signer: pubkeys[9],
            instructions: pubkeys[10],
        }
    }
}
impl<'info> From<EndSwapAccounts<'_, 'info>>
for [AccountInfo<'info>; END_SWAP_IX_ACCOUNTS_LEN] {
    fn from(accounts: EndSwapAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.out_spot_market_vault.clone(),
            accounts.in_spot_market_vault.clone(),
            accounts.out_token_account.clone(),
            accounts.in_token_account.clone(),
            accounts.token_program.clone(),
            accounts.drift_signer.clone(),
            accounts.instructions.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; END_SWAP_IX_ACCOUNTS_LEN]>
for EndSwapAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; END_SWAP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            out_spot_market_vault: &arr[4],
            in_spot_market_vault: &arr[5],
            out_token_account: &arr[6],
            in_token_account: &arr[7],
            token_program: &arr[8],
            drift_signer: &arr[9],
            instructions: &arr[10],
        }
    }
}
pub const END_SWAP_IX_DISCM: [u8; 8] = [177, 184, 27, 193, 34, 13, 210, 145];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EndSwapIxArgs {
    pub in_market_index: u16,
    pub out_market_index: u16,
    pub limit_price: Option<u64>,
    pub reduce_only: Option<SwapReduceOnly>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct EndSwapIxData(pub EndSwapIxArgs);
impl From<EndSwapIxArgs> for EndSwapIxData {
    fn from(args: EndSwapIxArgs) -> Self {
        Self(args)
    }
}
impl EndSwapIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != END_SWAP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        END_SWAP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(EndSwapIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&END_SWAP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn end_swap_ix_with_program_id(
    program_id: Pubkey,
    keys: EndSwapKeys,
    args: EndSwapIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; END_SWAP_IX_ACCOUNTS_LEN] = keys.into();
    let data: EndSwapIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn end_swap_ix(
    keys: EndSwapKeys,
    args: EndSwapIxArgs,
) -> std::io::Result<Instruction> {
    end_swap_ix_with_program_id(crate::ID, keys, args)
}
pub fn end_swap_invoke_with_program_id(
    program_id: Pubkey,
    accounts: EndSwapAccounts<'_, '_>,
    args: EndSwapIxArgs,
) -> ProgramResult {
    let keys: EndSwapKeys = accounts.into();
    let ix = end_swap_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn end_swap_invoke(
    accounts: EndSwapAccounts<'_, '_>,
    args: EndSwapIxArgs,
) -> ProgramResult {
    end_swap_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn end_swap_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: EndSwapAccounts<'_, '_>,
    args: EndSwapIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: EndSwapKeys = accounts.into();
    let ix = end_swap_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn end_swap_invoke_signed(
    accounts: EndSwapAccounts<'_, '_>,
    args: EndSwapIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    end_swap_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn end_swap_verify_account_keys(
    accounts: EndSwapAccounts<'_, '_>,
    keys: EndSwapKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.out_spot_market_vault.key, keys.out_spot_market_vault),
        (*accounts.in_spot_market_vault.key, keys.in_spot_market_vault),
        (*accounts.out_token_account.key, keys.out_token_account),
        (*accounts.in_token_account.key, keys.in_token_account),
        (*accounts.token_program.key, keys.token_program),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.instructions.key, keys.instructions),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn end_swap_verify_writable_privileges<'me, 'info>(
    accounts: EndSwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.user,
        accounts.user_stats,
        accounts.out_spot_market_vault,
        accounts.in_spot_market_vault,
        accounts.out_token_account,
        accounts.in_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn end_swap_verify_signer_privileges<'me, 'info>(
    accounts: EndSwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn end_swap_verify_account_privileges<'me, 'info>(
    accounts: EndSwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    end_swap_verify_writable_privileges(accounts)?;
    end_swap_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct AddPerpLpSharesAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct AddPerpLpSharesKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<AddPerpLpSharesAccounts<'_, '_>> for AddPerpLpSharesKeys {
    fn from(accounts: AddPerpLpSharesAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<AddPerpLpSharesKeys> for [AccountMeta; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN] {
    fn from(keys: AddPerpLpSharesKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN]> for AddPerpLpSharesKeys {
    fn from(pubkeys: [Pubkey; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<AddPerpLpSharesAccounts<'_, 'info>>
for [AccountInfo<'info>; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN] {
    fn from(accounts: AddPerpLpSharesAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN]>
for AddPerpLpSharesAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const ADD_PERP_LP_SHARES_IX_DISCM: [u8; 8] = [56, 209, 56, 197, 119, 254, 188, 117];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AddPerpLpSharesIxArgs {
    pub n_shares: u64,
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct AddPerpLpSharesIxData(pub AddPerpLpSharesIxArgs);
impl From<AddPerpLpSharesIxArgs> for AddPerpLpSharesIxData {
    fn from(args: AddPerpLpSharesIxArgs) -> Self {
        Self(args)
    }
}
impl AddPerpLpSharesIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != ADD_PERP_LP_SHARES_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        ADD_PERP_LP_SHARES_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(AddPerpLpSharesIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&ADD_PERP_LP_SHARES_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn add_perp_lp_shares_ix_with_program_id(
    program_id: Pubkey,
    keys: AddPerpLpSharesKeys,
    args: AddPerpLpSharesIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; ADD_PERP_LP_SHARES_IX_ACCOUNTS_LEN] = keys.into();
    let data: AddPerpLpSharesIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn add_perp_lp_shares_ix(
    keys: AddPerpLpSharesKeys,
    args: AddPerpLpSharesIxArgs,
) -> std::io::Result<Instruction> {
    add_perp_lp_shares_ix_with_program_id(crate::ID, keys, args)
}
pub fn add_perp_lp_shares_invoke_with_program_id(
    program_id: Pubkey,
    accounts: AddPerpLpSharesAccounts<'_, '_>,
    args: AddPerpLpSharesIxArgs,
) -> ProgramResult {
    let keys: AddPerpLpSharesKeys = accounts.into();
    let ix = add_perp_lp_shares_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn add_perp_lp_shares_invoke(
    accounts: AddPerpLpSharesAccounts<'_, '_>,
    args: AddPerpLpSharesIxArgs,
) -> ProgramResult {
    add_perp_lp_shares_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn add_perp_lp_shares_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: AddPerpLpSharesAccounts<'_, '_>,
    args: AddPerpLpSharesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: AddPerpLpSharesKeys = accounts.into();
    let ix = add_perp_lp_shares_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn add_perp_lp_shares_invoke_signed(
    accounts: AddPerpLpSharesAccounts<'_, '_>,
    args: AddPerpLpSharesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    add_perp_lp_shares_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn add_perp_lp_shares_verify_account_keys(
    accounts: AddPerpLpSharesAccounts<'_, '_>,
    keys: AddPerpLpSharesKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn add_perp_lp_shares_verify_writable_privileges<'me, 'info>(
    accounts: AddPerpLpSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn add_perp_lp_shares_verify_signer_privileges<'me, 'info>(
    accounts: AddPerpLpSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn add_perp_lp_shares_verify_account_privileges<'me, 'info>(
    accounts: AddPerpLpSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    add_perp_lp_shares_verify_writable_privileges(accounts)?;
    add_perp_lp_shares_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct RemovePerpLpSharesAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RemovePerpLpSharesKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<RemovePerpLpSharesAccounts<'_, '_>> for RemovePerpLpSharesKeys {
    fn from(accounts: RemovePerpLpSharesAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<RemovePerpLpSharesKeys>
for [AccountMeta; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN] {
    fn from(keys: RemovePerpLpSharesKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN]> for RemovePerpLpSharesKeys {
    fn from(pubkeys: [Pubkey; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<RemovePerpLpSharesAccounts<'_, 'info>>
for [AccountInfo<'info>; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN] {
    fn from(accounts: RemovePerpLpSharesAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN]>
for RemovePerpLpSharesAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const REMOVE_PERP_LP_SHARES_IX_DISCM: [u8; 8] = [213, 89, 217, 18, 160, 55, 53, 141];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RemovePerpLpSharesIxArgs {
    pub shares_to_burn: u64,
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct RemovePerpLpSharesIxData(pub RemovePerpLpSharesIxArgs);
impl From<RemovePerpLpSharesIxArgs> for RemovePerpLpSharesIxData {
    fn from(args: RemovePerpLpSharesIxArgs) -> Self {
        Self(args)
    }
}
impl RemovePerpLpSharesIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != REMOVE_PERP_LP_SHARES_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        REMOVE_PERP_LP_SHARES_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(RemovePerpLpSharesIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&REMOVE_PERP_LP_SHARES_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn remove_perp_lp_shares_ix_with_program_id(
    program_id: Pubkey,
    keys: RemovePerpLpSharesKeys,
    args: RemovePerpLpSharesIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; REMOVE_PERP_LP_SHARES_IX_ACCOUNTS_LEN] = keys.into();
    let data: RemovePerpLpSharesIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn remove_perp_lp_shares_ix(
    keys: RemovePerpLpSharesKeys,
    args: RemovePerpLpSharesIxArgs,
) -> std::io::Result<Instruction> {
    remove_perp_lp_shares_ix_with_program_id(crate::ID, keys, args)
}
pub fn remove_perp_lp_shares_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RemovePerpLpSharesAccounts<'_, '_>,
    args: RemovePerpLpSharesIxArgs,
) -> ProgramResult {
    let keys: RemovePerpLpSharesKeys = accounts.into();
    let ix = remove_perp_lp_shares_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn remove_perp_lp_shares_invoke(
    accounts: RemovePerpLpSharesAccounts<'_, '_>,
    args: RemovePerpLpSharesIxArgs,
) -> ProgramResult {
    remove_perp_lp_shares_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn remove_perp_lp_shares_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RemovePerpLpSharesAccounts<'_, '_>,
    args: RemovePerpLpSharesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RemovePerpLpSharesKeys = accounts.into();
    let ix = remove_perp_lp_shares_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn remove_perp_lp_shares_invoke_signed(
    accounts: RemovePerpLpSharesAccounts<'_, '_>,
    args: RemovePerpLpSharesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    remove_perp_lp_shares_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn remove_perp_lp_shares_verify_account_keys(
    accounts: RemovePerpLpSharesAccounts<'_, '_>,
    keys: RemovePerpLpSharesKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn remove_perp_lp_shares_verify_writable_privileges<'me, 'info>(
    accounts: RemovePerpLpSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn remove_perp_lp_shares_verify_signer_privileges<'me, 'info>(
    accounts: RemovePerpLpSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn remove_perp_lp_shares_verify_account_privileges<'me, 'info>(
    accounts: RemovePerpLpSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    remove_perp_lp_shares_verify_writable_privileges(accounts)?;
    remove_perp_lp_shares_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct RemovePerpLpSharesInExpiringMarketAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RemovePerpLpSharesInExpiringMarketKeys {
    pub state: Pubkey,
    pub user: Pubkey,
}
impl From<RemovePerpLpSharesInExpiringMarketAccounts<'_, '_>>
for RemovePerpLpSharesInExpiringMarketKeys {
    fn from(accounts: RemovePerpLpSharesInExpiringMarketAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
        }
    }
}
impl From<RemovePerpLpSharesInExpiringMarketKeys>
for [AccountMeta; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: RemovePerpLpSharesInExpiringMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN]>
for RemovePerpLpSharesInExpiringMarketKeys {
    fn from(
        pubkeys: [Pubkey; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
        }
    }
}
impl<'info> From<RemovePerpLpSharesInExpiringMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: RemovePerpLpSharesInExpiringMarketAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN],
> for RemovePerpLpSharesInExpiringMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
        }
    }
}
pub const REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_DISCM: [u8; 8] = [
    83,
    254,
    253,
    137,
    59,
    122,
    68,
    156,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RemovePerpLpSharesInExpiringMarketIxArgs {
    pub shares_to_burn: u64,
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct RemovePerpLpSharesInExpiringMarketIxData(
    pub RemovePerpLpSharesInExpiringMarketIxArgs,
);
impl From<RemovePerpLpSharesInExpiringMarketIxArgs>
for RemovePerpLpSharesInExpiringMarketIxData {
    fn from(args: RemovePerpLpSharesInExpiringMarketIxArgs) -> Self {
        Self(args)
    }
}
impl RemovePerpLpSharesInExpiringMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(RemovePerpLpSharesInExpiringMarketIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn remove_perp_lp_shares_in_expiring_market_ix_with_program_id(
    program_id: Pubkey,
    keys: RemovePerpLpSharesInExpiringMarketKeys,
    args: RemovePerpLpSharesInExpiringMarketIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; REMOVE_PERP_LP_SHARES_IN_EXPIRING_MARKET_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: RemovePerpLpSharesInExpiringMarketIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn remove_perp_lp_shares_in_expiring_market_ix(
    keys: RemovePerpLpSharesInExpiringMarketKeys,
    args: RemovePerpLpSharesInExpiringMarketIxArgs,
) -> std::io::Result<Instruction> {
    remove_perp_lp_shares_in_expiring_market_ix_with_program_id(crate::ID, keys, args)
}
pub fn remove_perp_lp_shares_in_expiring_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'_, '_>,
    args: RemovePerpLpSharesInExpiringMarketIxArgs,
) -> ProgramResult {
    let keys: RemovePerpLpSharesInExpiringMarketKeys = accounts.into();
    let ix = remove_perp_lp_shares_in_expiring_market_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn remove_perp_lp_shares_in_expiring_market_invoke(
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'_, '_>,
    args: RemovePerpLpSharesInExpiringMarketIxArgs,
) -> ProgramResult {
    remove_perp_lp_shares_in_expiring_market_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn remove_perp_lp_shares_in_expiring_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'_, '_>,
    args: RemovePerpLpSharesInExpiringMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RemovePerpLpSharesInExpiringMarketKeys = accounts.into();
    let ix = remove_perp_lp_shares_in_expiring_market_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn remove_perp_lp_shares_in_expiring_market_invoke_signed(
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'_, '_>,
    args: RemovePerpLpSharesInExpiringMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    remove_perp_lp_shares_in_expiring_market_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn remove_perp_lp_shares_in_expiring_market_verify_account_keys(
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'_, '_>,
    keys: RemovePerpLpSharesInExpiringMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn remove_perp_lp_shares_in_expiring_market_verify_writable_privileges<'me, 'info>(
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn remove_perp_lp_shares_in_expiring_market_verify_account_privileges<'me, 'info>(
    accounts: RemovePerpLpSharesInExpiringMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    remove_perp_lp_shares_in_expiring_market_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_NAME_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserNameAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserNameKeys {
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateUserNameAccounts<'_, '_>> for UpdateUserNameKeys {
    fn from(accounts: UpdateUserNameAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateUserNameKeys> for [AccountMeta; UPDATE_USER_NAME_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserNameKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_NAME_IX_ACCOUNTS_LEN]> for UpdateUserNameKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_NAME_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateUserNameAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_NAME_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserNameAccounts<'_, 'info>) -> Self {
        [accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_USER_NAME_IX_ACCOUNTS_LEN]>
for UpdateUserNameAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; UPDATE_USER_NAME_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_USER_NAME_IX_DISCM: [u8; 8] = [135, 25, 185, 56, 165, 53, 34, 136];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateUserNameIxArgs {
    pub sub_account_id: u16,
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserNameIxData(pub UpdateUserNameIxArgs);
impl From<UpdateUserNameIxArgs> for UpdateUserNameIxData {
    fn from(args: UpdateUserNameIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateUserNameIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_NAME_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_NAME_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateUserNameIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_NAME_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_name_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserNameKeys,
    args: UpdateUserNameIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_NAME_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateUserNameIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_user_name_ix(
    keys: UpdateUserNameKeys,
    args: UpdateUserNameIxArgs,
) -> std::io::Result<Instruction> {
    update_user_name_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_user_name_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserNameAccounts<'_, '_>,
    args: UpdateUserNameIxArgs,
) -> ProgramResult {
    let keys: UpdateUserNameKeys = accounts.into();
    let ix = update_user_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_name_invoke(
    accounts: UpdateUserNameAccounts<'_, '_>,
    args: UpdateUserNameIxArgs,
) -> ProgramResult {
    update_user_name_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_user_name_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserNameAccounts<'_, '_>,
    args: UpdateUserNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserNameKeys = accounts.into();
    let ix = update_user_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_name_invoke_signed(
    accounts: UpdateUserNameAccounts<'_, '_>,
    args: UpdateUserNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_name_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_user_name_verify_account_keys(
    accounts: UpdateUserNameAccounts<'_, '_>,
    keys: UpdateUserNameKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_name_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_name_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_name_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_name_verify_writable_privileges(accounts)?;
    update_user_name_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserCustomMarginRatioAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserCustomMarginRatioKeys {
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateUserCustomMarginRatioAccounts<'_, '_>>
for UpdateUserCustomMarginRatioKeys {
    fn from(accounts: UpdateUserCustomMarginRatioAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateUserCustomMarginRatioKeys>
for [AccountMeta; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserCustomMarginRatioKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN]>
for UpdateUserCustomMarginRatioKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateUserCustomMarginRatioAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserCustomMarginRatioAccounts<'_, 'info>) -> Self {
        [accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN]>
for UpdateUserCustomMarginRatioAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_DISCM: [u8; 8] = [
    21,
    221,
    140,
    187,
    32,
    129,
    11,
    123,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateUserCustomMarginRatioIxArgs {
    pub sub_account_id: u16,
    pub margin_ratio: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserCustomMarginRatioIxData(pub UpdateUserCustomMarginRatioIxArgs);
impl From<UpdateUserCustomMarginRatioIxArgs> for UpdateUserCustomMarginRatioIxData {
    fn from(args: UpdateUserCustomMarginRatioIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateUserCustomMarginRatioIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateUserCustomMarginRatioIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_custom_margin_ratio_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserCustomMarginRatioKeys,
    args: UpdateUserCustomMarginRatioIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_CUSTOM_MARGIN_RATIO_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateUserCustomMarginRatioIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_user_custom_margin_ratio_ix(
    keys: UpdateUserCustomMarginRatioKeys,
    args: UpdateUserCustomMarginRatioIxArgs,
) -> std::io::Result<Instruction> {
    update_user_custom_margin_ratio_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_user_custom_margin_ratio_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserCustomMarginRatioAccounts<'_, '_>,
    args: UpdateUserCustomMarginRatioIxArgs,
) -> ProgramResult {
    let keys: UpdateUserCustomMarginRatioKeys = accounts.into();
    let ix = update_user_custom_margin_ratio_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_custom_margin_ratio_invoke(
    accounts: UpdateUserCustomMarginRatioAccounts<'_, '_>,
    args: UpdateUserCustomMarginRatioIxArgs,
) -> ProgramResult {
    update_user_custom_margin_ratio_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_user_custom_margin_ratio_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserCustomMarginRatioAccounts<'_, '_>,
    args: UpdateUserCustomMarginRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserCustomMarginRatioKeys = accounts.into();
    let ix = update_user_custom_margin_ratio_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_custom_margin_ratio_invoke_signed(
    accounts: UpdateUserCustomMarginRatioAccounts<'_, '_>,
    args: UpdateUserCustomMarginRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_custom_margin_ratio_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_user_custom_margin_ratio_verify_account_keys(
    accounts: UpdateUserCustomMarginRatioAccounts<'_, '_>,
    keys: UpdateUserCustomMarginRatioKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_custom_margin_ratio_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserCustomMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_custom_margin_ratio_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserCustomMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_custom_margin_ratio_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserCustomMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_custom_margin_ratio_verify_writable_privileges(accounts)?;
    update_user_custom_margin_ratio_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserMarginTradingEnabledAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserMarginTradingEnabledKeys {
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateUserMarginTradingEnabledAccounts<'_, '_>>
for UpdateUserMarginTradingEnabledKeys {
    fn from(accounts: UpdateUserMarginTradingEnabledAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateUserMarginTradingEnabledKeys>
for [AccountMeta; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserMarginTradingEnabledKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN]>
for UpdateUserMarginTradingEnabledKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateUserMarginTradingEnabledAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserMarginTradingEnabledAccounts<'_, 'info>) -> Self {
        [accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN]>
for UpdateUserMarginTradingEnabledAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_USER_MARGIN_TRADING_ENABLED_IX_DISCM: [u8; 8] = [
    194,
    92,
    204,
    223,
    246,
    188,
    31,
    203,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateUserMarginTradingEnabledIxArgs {
    pub sub_account_id: u16,
    pub margin_trading_enabled: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserMarginTradingEnabledIxData(
    pub UpdateUserMarginTradingEnabledIxArgs,
);
impl From<UpdateUserMarginTradingEnabledIxArgs>
for UpdateUserMarginTradingEnabledIxData {
    fn from(args: UpdateUserMarginTradingEnabledIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateUserMarginTradingEnabledIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_MARGIN_TRADING_ENABLED_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_MARGIN_TRADING_ENABLED_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateUserMarginTradingEnabledIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_MARGIN_TRADING_ENABLED_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_margin_trading_enabled_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserMarginTradingEnabledKeys,
    args: UpdateUserMarginTradingEnabledIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_MARGIN_TRADING_ENABLED_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateUserMarginTradingEnabledIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_user_margin_trading_enabled_ix(
    keys: UpdateUserMarginTradingEnabledKeys,
    args: UpdateUserMarginTradingEnabledIxArgs,
) -> std::io::Result<Instruction> {
    update_user_margin_trading_enabled_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_user_margin_trading_enabled_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserMarginTradingEnabledAccounts<'_, '_>,
    args: UpdateUserMarginTradingEnabledIxArgs,
) -> ProgramResult {
    let keys: UpdateUserMarginTradingEnabledKeys = accounts.into();
    let ix = update_user_margin_trading_enabled_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_margin_trading_enabled_invoke(
    accounts: UpdateUserMarginTradingEnabledAccounts<'_, '_>,
    args: UpdateUserMarginTradingEnabledIxArgs,
) -> ProgramResult {
    update_user_margin_trading_enabled_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_user_margin_trading_enabled_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserMarginTradingEnabledAccounts<'_, '_>,
    args: UpdateUserMarginTradingEnabledIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserMarginTradingEnabledKeys = accounts.into();
    let ix = update_user_margin_trading_enabled_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_margin_trading_enabled_invoke_signed(
    accounts: UpdateUserMarginTradingEnabledAccounts<'_, '_>,
    args: UpdateUserMarginTradingEnabledIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_margin_trading_enabled_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_user_margin_trading_enabled_verify_account_keys(
    accounts: UpdateUserMarginTradingEnabledAccounts<'_, '_>,
    keys: UpdateUserMarginTradingEnabledKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_margin_trading_enabled_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserMarginTradingEnabledAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_margin_trading_enabled_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserMarginTradingEnabledAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_margin_trading_enabled_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserMarginTradingEnabledAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_margin_trading_enabled_verify_writable_privileges(accounts)?;
    update_user_margin_trading_enabled_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserDelegateAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserDelegateKeys {
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateUserDelegateAccounts<'_, '_>> for UpdateUserDelegateKeys {
    fn from(accounts: UpdateUserDelegateAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateUserDelegateKeys>
for [AccountMeta; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserDelegateKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN]> for UpdateUserDelegateKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateUserDelegateAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserDelegateAccounts<'_, 'info>) -> Self {
        [accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN]>
for UpdateUserDelegateAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_USER_DELEGATE_IX_DISCM: [u8; 8] = [
    139,
    205,
    141,
    141,
    113,
    36,
    94,
    187,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateUserDelegateIxArgs {
    pub sub_account_id: u16,
    pub delegate: Pubkey,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserDelegateIxData(pub UpdateUserDelegateIxArgs);
impl From<UpdateUserDelegateIxArgs> for UpdateUserDelegateIxData {
    fn from(args: UpdateUserDelegateIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateUserDelegateIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_DELEGATE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_DELEGATE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateUserDelegateIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_DELEGATE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_delegate_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserDelegateKeys,
    args: UpdateUserDelegateIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_DELEGATE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateUserDelegateIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_user_delegate_ix(
    keys: UpdateUserDelegateKeys,
    args: UpdateUserDelegateIxArgs,
) -> std::io::Result<Instruction> {
    update_user_delegate_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_user_delegate_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserDelegateAccounts<'_, '_>,
    args: UpdateUserDelegateIxArgs,
) -> ProgramResult {
    let keys: UpdateUserDelegateKeys = accounts.into();
    let ix = update_user_delegate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_delegate_invoke(
    accounts: UpdateUserDelegateAccounts<'_, '_>,
    args: UpdateUserDelegateIxArgs,
) -> ProgramResult {
    update_user_delegate_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_user_delegate_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserDelegateAccounts<'_, '_>,
    args: UpdateUserDelegateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserDelegateKeys = accounts.into();
    let ix = update_user_delegate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_delegate_invoke_signed(
    accounts: UpdateUserDelegateAccounts<'_, '_>,
    args: UpdateUserDelegateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_delegate_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_user_delegate_verify_account_keys(
    accounts: UpdateUserDelegateAccounts<'_, '_>,
    keys: UpdateUserDelegateKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_delegate_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserDelegateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_delegate_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserDelegateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_delegate_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserDelegateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_delegate_verify_writable_privileges(accounts)?;
    update_user_delegate_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserReduceOnlyAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserReduceOnlyKeys {
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateUserReduceOnlyAccounts<'_, '_>> for UpdateUserReduceOnlyKeys {
    fn from(accounts: UpdateUserReduceOnlyAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateUserReduceOnlyKeys>
for [AccountMeta; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserReduceOnlyKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN]>
for UpdateUserReduceOnlyKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateUserReduceOnlyAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserReduceOnlyAccounts<'_, 'info>) -> Self {
        [accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN]>
for UpdateUserReduceOnlyAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_USER_REDUCE_ONLY_IX_DISCM: [u8; 8] = [
    199,
    71,
    42,
    67,
    144,
    19,
    86,
    109,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateUserReduceOnlyIxArgs {
    pub sub_account_id: u16,
    pub reduce_only: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserReduceOnlyIxData(pub UpdateUserReduceOnlyIxArgs);
impl From<UpdateUserReduceOnlyIxArgs> for UpdateUserReduceOnlyIxData {
    fn from(args: UpdateUserReduceOnlyIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateUserReduceOnlyIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_REDUCE_ONLY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_REDUCE_ONLY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateUserReduceOnlyIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_REDUCE_ONLY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_reduce_only_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserReduceOnlyKeys,
    args: UpdateUserReduceOnlyIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_REDUCE_ONLY_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateUserReduceOnlyIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_user_reduce_only_ix(
    keys: UpdateUserReduceOnlyKeys,
    args: UpdateUserReduceOnlyIxArgs,
) -> std::io::Result<Instruction> {
    update_user_reduce_only_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_user_reduce_only_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserReduceOnlyAccounts<'_, '_>,
    args: UpdateUserReduceOnlyIxArgs,
) -> ProgramResult {
    let keys: UpdateUserReduceOnlyKeys = accounts.into();
    let ix = update_user_reduce_only_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_reduce_only_invoke(
    accounts: UpdateUserReduceOnlyAccounts<'_, '_>,
    args: UpdateUserReduceOnlyIxArgs,
) -> ProgramResult {
    update_user_reduce_only_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_user_reduce_only_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserReduceOnlyAccounts<'_, '_>,
    args: UpdateUserReduceOnlyIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserReduceOnlyKeys = accounts.into();
    let ix = update_user_reduce_only_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_reduce_only_invoke_signed(
    accounts: UpdateUserReduceOnlyAccounts<'_, '_>,
    args: UpdateUserReduceOnlyIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_reduce_only_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_user_reduce_only_verify_account_keys(
    accounts: UpdateUserReduceOnlyAccounts<'_, '_>,
    keys: UpdateUserReduceOnlyKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_reduce_only_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserReduceOnlyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_reduce_only_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserReduceOnlyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_reduce_only_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserReduceOnlyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_reduce_only_verify_writable_privileges(accounts)?;
    update_user_reduce_only_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserAdvancedLpAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserAdvancedLpKeys {
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateUserAdvancedLpAccounts<'_, '_>> for UpdateUserAdvancedLpKeys {
    fn from(accounts: UpdateUserAdvancedLpAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateUserAdvancedLpKeys>
for [AccountMeta; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserAdvancedLpKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN]>
for UpdateUserAdvancedLpKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateUserAdvancedLpAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserAdvancedLpAccounts<'_, 'info>) -> Self {
        [accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN]>
for UpdateUserAdvancedLpAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            user: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_USER_ADVANCED_LP_IX_DISCM: [u8; 8] = [
    66,
    80,
    107,
    186,
    27,
    242,
    66,
    95,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateUserAdvancedLpIxArgs {
    pub sub_account_id: u16,
    pub advanced_lp: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserAdvancedLpIxData(pub UpdateUserAdvancedLpIxArgs);
impl From<UpdateUserAdvancedLpIxArgs> for UpdateUserAdvancedLpIxData {
    fn from(args: UpdateUserAdvancedLpIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateUserAdvancedLpIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_ADVANCED_LP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_ADVANCED_LP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateUserAdvancedLpIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_ADVANCED_LP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_advanced_lp_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserAdvancedLpKeys,
    args: UpdateUserAdvancedLpIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_ADVANCED_LP_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateUserAdvancedLpIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_user_advanced_lp_ix(
    keys: UpdateUserAdvancedLpKeys,
    args: UpdateUserAdvancedLpIxArgs,
) -> std::io::Result<Instruction> {
    update_user_advanced_lp_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_user_advanced_lp_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserAdvancedLpAccounts<'_, '_>,
    args: UpdateUserAdvancedLpIxArgs,
) -> ProgramResult {
    let keys: UpdateUserAdvancedLpKeys = accounts.into();
    let ix = update_user_advanced_lp_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_advanced_lp_invoke(
    accounts: UpdateUserAdvancedLpAccounts<'_, '_>,
    args: UpdateUserAdvancedLpIxArgs,
) -> ProgramResult {
    update_user_advanced_lp_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_user_advanced_lp_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserAdvancedLpAccounts<'_, '_>,
    args: UpdateUserAdvancedLpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserAdvancedLpKeys = accounts.into();
    let ix = update_user_advanced_lp_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_advanced_lp_invoke_signed(
    accounts: UpdateUserAdvancedLpAccounts<'_, '_>,
    args: UpdateUserAdvancedLpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_advanced_lp_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_user_advanced_lp_verify_account_keys(
    accounts: UpdateUserAdvancedLpAccounts<'_, '_>,
    keys: UpdateUserAdvancedLpKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_advanced_lp_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserAdvancedLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_advanced_lp_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserAdvancedLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_advanced_lp_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserAdvancedLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_advanced_lp_verify_writable_privileges(accounts)?;
    update_user_advanced_lp_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DELETE_USER_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct DeleteUserAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DeleteUserKeys {
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub state: Pubkey,
    pub authority: Pubkey,
}
impl From<DeleteUserAccounts<'_, '_>> for DeleteUserKeys {
    fn from(accounts: DeleteUserAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            state: *accounts.state.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<DeleteUserKeys> for [AccountMeta; DELETE_USER_IX_ACCOUNTS_LEN] {
    fn from(keys: DeleteUserKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DELETE_USER_IX_ACCOUNTS_LEN]> for DeleteUserKeys {
    fn from(pubkeys: [Pubkey; DELETE_USER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            user_stats: pubkeys[1],
            state: pubkeys[2],
            authority: pubkeys[3],
        }
    }
}
impl<'info> From<DeleteUserAccounts<'_, 'info>>
for [AccountInfo<'info>; DELETE_USER_IX_ACCOUNTS_LEN] {
    fn from(accounts: DeleteUserAccounts<'_, 'info>) -> Self {
        [
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.state.clone(),
            accounts.authority.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; DELETE_USER_IX_ACCOUNTS_LEN]>
for DeleteUserAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; DELETE_USER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: &arr[0],
            user_stats: &arr[1],
            state: &arr[2],
            authority: &arr[3],
        }
    }
}
pub const DELETE_USER_IX_DISCM: [u8; 8] = [186, 85, 17, 249, 219, 231, 98, 251];
#[derive(Clone, Debug, PartialEq)]
pub struct DeleteUserIxData;
impl DeleteUserIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DELETE_USER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DELETE_USER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DELETE_USER_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn delete_user_ix_with_program_id(
    program_id: Pubkey,
    keys: DeleteUserKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DELETE_USER_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: DeleteUserIxData.try_to_vec()?,
    })
}
pub fn delete_user_ix(keys: DeleteUserKeys) -> std::io::Result<Instruction> {
    delete_user_ix_with_program_id(crate::ID, keys)
}
pub fn delete_user_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DeleteUserAccounts<'_, '_>,
) -> ProgramResult {
    let keys: DeleteUserKeys = accounts.into();
    let ix = delete_user_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn delete_user_invoke(accounts: DeleteUserAccounts<'_, '_>) -> ProgramResult {
    delete_user_invoke_with_program_id(crate::ID, accounts)
}
pub fn delete_user_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DeleteUserAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DeleteUserKeys = accounts.into();
    let ix = delete_user_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn delete_user_invoke_signed(
    accounts: DeleteUserAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    delete_user_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn delete_user_verify_account_keys(
    accounts: DeleteUserAccounts<'_, '_>,
    keys: DeleteUserKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn delete_user_verify_writable_privileges<'me, 'info>(
    accounts: DeleteUserAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats, accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn delete_user_verify_signer_privileges<'me, 'info>(
    accounts: DeleteUserAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn delete_user_verify_account_privileges<'me, 'info>(
    accounts: DeleteUserAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    delete_user_verify_writable_privileges(accounts)?;
    delete_user_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const RECLAIM_RENT_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct ReclaimRentAccounts<'me, 'info> {
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ReclaimRentKeys {
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub state: Pubkey,
    pub authority: Pubkey,
    pub rent: Pubkey,
}
impl From<ReclaimRentAccounts<'_, '_>> for ReclaimRentKeys {
    fn from(accounts: ReclaimRentAccounts) -> Self {
        Self {
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            rent: *accounts.rent.key,
        }
    }
}
impl From<ReclaimRentKeys> for [AccountMeta; RECLAIM_RENT_IX_ACCOUNTS_LEN] {
    fn from(keys: ReclaimRentKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; RECLAIM_RENT_IX_ACCOUNTS_LEN]> for ReclaimRentKeys {
    fn from(pubkeys: [Pubkey; RECLAIM_RENT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: pubkeys[0],
            user_stats: pubkeys[1],
            state: pubkeys[2],
            authority: pubkeys[3],
            rent: pubkeys[4],
        }
    }
}
impl<'info> From<ReclaimRentAccounts<'_, 'info>>
for [AccountInfo<'info>; RECLAIM_RENT_IX_ACCOUNTS_LEN] {
    fn from(accounts: ReclaimRentAccounts<'_, 'info>) -> Self {
        [
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.rent.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; RECLAIM_RENT_IX_ACCOUNTS_LEN]>
for ReclaimRentAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; RECLAIM_RENT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            user: &arr[0],
            user_stats: &arr[1],
            state: &arr[2],
            authority: &arr[3],
            rent: &arr[4],
        }
    }
}
pub const RECLAIM_RENT_IX_DISCM: [u8; 8] = [218, 200, 19, 197, 227, 89, 192, 22];
#[derive(Clone, Debug, PartialEq)]
pub struct ReclaimRentIxData;
impl ReclaimRentIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != RECLAIM_RENT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        RECLAIM_RENT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&RECLAIM_RENT_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn reclaim_rent_ix_with_program_id(
    program_id: Pubkey,
    keys: ReclaimRentKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; RECLAIM_RENT_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: ReclaimRentIxData.try_to_vec()?,
    })
}
pub fn reclaim_rent_ix(keys: ReclaimRentKeys) -> std::io::Result<Instruction> {
    reclaim_rent_ix_with_program_id(crate::ID, keys)
}
pub fn reclaim_rent_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ReclaimRentAccounts<'_, '_>,
) -> ProgramResult {
    let keys: ReclaimRentKeys = accounts.into();
    let ix = reclaim_rent_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn reclaim_rent_invoke(accounts: ReclaimRentAccounts<'_, '_>) -> ProgramResult {
    reclaim_rent_invoke_with_program_id(crate::ID, accounts)
}
pub fn reclaim_rent_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ReclaimRentAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ReclaimRentKeys = accounts.into();
    let ix = reclaim_rent_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn reclaim_rent_invoke_signed(
    accounts: ReclaimRentAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    reclaim_rent_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn reclaim_rent_verify_account_keys(
    accounts: ReclaimRentAccounts<'_, '_>,
    keys: ReclaimRentKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.rent.key, keys.rent),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn reclaim_rent_verify_writable_privileges<'me, 'info>(
    accounts: ReclaimRentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn reclaim_rent_verify_signer_privileges<'me, 'info>(
    accounts: ReclaimRentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn reclaim_rent_verify_account_privileges<'me, 'info>(
    accounts: ReclaimRentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    reclaim_rent_verify_writable_privileges(accounts)?;
    reclaim_rent_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct EnableUserHighLeverageModeAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub high_leverage_mode_config: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct EnableUserHighLeverageModeKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
    pub high_leverage_mode_config: Pubkey,
}
impl From<EnableUserHighLeverageModeAccounts<'_, '_>>
for EnableUserHighLeverageModeKeys {
    fn from(accounts: EnableUserHighLeverageModeAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
            high_leverage_mode_config: *accounts.high_leverage_mode_config.key,
        }
    }
}
impl From<EnableUserHighLeverageModeKeys>
for [AccountMeta; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN] {
    fn from(keys: EnableUserHighLeverageModeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.high_leverage_mode_config,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN]>
for EnableUserHighLeverageModeKeys {
    fn from(pubkeys: [Pubkey; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
            high_leverage_mode_config: pubkeys[3],
        }
    }
}
impl<'info> From<EnableUserHighLeverageModeAccounts<'_, 'info>>
for [AccountInfo<'info>; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN] {
    fn from(accounts: EnableUserHighLeverageModeAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.authority.clone(),
            accounts.high_leverage_mode_config.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN]>
for EnableUserHighLeverageModeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
            high_leverage_mode_config: &arr[3],
        }
    }
}
pub const ENABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM: [u8; 8] = [
    231,
    24,
    230,
    112,
    201,
    173,
    73,
    184,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EnableUserHighLeverageModeIxArgs {
    pub sub_account_id: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct EnableUserHighLeverageModeIxData(pub EnableUserHighLeverageModeIxArgs);
impl From<EnableUserHighLeverageModeIxArgs> for EnableUserHighLeverageModeIxData {
    fn from(args: EnableUserHighLeverageModeIxArgs) -> Self {
        Self(args)
    }
}
impl EnableUserHighLeverageModeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != ENABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        ENABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(EnableUserHighLeverageModeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&ENABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn enable_user_high_leverage_mode_ix_with_program_id(
    program_id: Pubkey,
    keys: EnableUserHighLeverageModeKeys,
    args: EnableUserHighLeverageModeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; ENABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: EnableUserHighLeverageModeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn enable_user_high_leverage_mode_ix(
    keys: EnableUserHighLeverageModeKeys,
    args: EnableUserHighLeverageModeIxArgs,
) -> std::io::Result<Instruction> {
    enable_user_high_leverage_mode_ix_with_program_id(crate::ID, keys, args)
}
pub fn enable_user_high_leverage_mode_invoke_with_program_id(
    program_id: Pubkey,
    accounts: EnableUserHighLeverageModeAccounts<'_, '_>,
    args: EnableUserHighLeverageModeIxArgs,
) -> ProgramResult {
    let keys: EnableUserHighLeverageModeKeys = accounts.into();
    let ix = enable_user_high_leverage_mode_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn enable_user_high_leverage_mode_invoke(
    accounts: EnableUserHighLeverageModeAccounts<'_, '_>,
    args: EnableUserHighLeverageModeIxArgs,
) -> ProgramResult {
    enable_user_high_leverage_mode_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn enable_user_high_leverage_mode_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: EnableUserHighLeverageModeAccounts<'_, '_>,
    args: EnableUserHighLeverageModeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: EnableUserHighLeverageModeKeys = accounts.into();
    let ix = enable_user_high_leverage_mode_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn enable_user_high_leverage_mode_invoke_signed(
    accounts: EnableUserHighLeverageModeAccounts<'_, '_>,
    args: EnableUserHighLeverageModeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    enable_user_high_leverage_mode_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn enable_user_high_leverage_mode_verify_account_keys(
    accounts: EnableUserHighLeverageModeAccounts<'_, '_>,
    keys: EnableUserHighLeverageModeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
        (*accounts.high_leverage_mode_config.key, keys.high_leverage_mode_config),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn enable_user_high_leverage_mode_verify_writable_privileges<'me, 'info>(
    accounts: EnableUserHighLeverageModeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.high_leverage_mode_config] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn enable_user_high_leverage_mode_verify_signer_privileges<'me, 'info>(
    accounts: EnableUserHighLeverageModeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn enable_user_high_leverage_mode_verify_account_privileges<'me, 'info>(
    accounts: EnableUserHighLeverageModeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    enable_user_high_leverage_mode_verify_writable_privileges(accounts)?;
    enable_user_high_leverage_mode_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const FILL_PERP_ORDER_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct FillPerpOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub filler_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct FillPerpOrderKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub filler_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<FillPerpOrderAccounts<'_, '_>> for FillPerpOrderKeys {
    fn from(accounts: FillPerpOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            filler_stats: *accounts.filler_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<FillPerpOrderKeys> for [AccountMeta; FILL_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: FillPerpOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.filler_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; FILL_PERP_ORDER_IX_ACCOUNTS_LEN]> for FillPerpOrderKeys {
    fn from(pubkeys: [Pubkey; FILL_PERP_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            filler_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<FillPerpOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; FILL_PERP_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: FillPerpOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.filler_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; FILL_PERP_ORDER_IX_ACCOUNTS_LEN]>
for FillPerpOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; FILL_PERP_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            filler_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const FILL_PERP_ORDER_IX_DISCM: [u8; 8] = [13, 188, 248, 103, 134, 217, 106, 240];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct FillPerpOrderIxArgs {
    pub order_id: Option<u32>,
    pub maker_order_id: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct FillPerpOrderIxData(pub FillPerpOrderIxArgs);
impl From<FillPerpOrderIxArgs> for FillPerpOrderIxData {
    fn from(args: FillPerpOrderIxArgs) -> Self {
        Self(args)
    }
}
impl FillPerpOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != FILL_PERP_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        FILL_PERP_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(FillPerpOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&FILL_PERP_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn fill_perp_order_ix_with_program_id(
    program_id: Pubkey,
    keys: FillPerpOrderKeys,
    args: FillPerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; FILL_PERP_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: FillPerpOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn fill_perp_order_ix(
    keys: FillPerpOrderKeys,
    args: FillPerpOrderIxArgs,
) -> std::io::Result<Instruction> {
    fill_perp_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn fill_perp_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: FillPerpOrderAccounts<'_, '_>,
    args: FillPerpOrderIxArgs,
) -> ProgramResult {
    let keys: FillPerpOrderKeys = accounts.into();
    let ix = fill_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn fill_perp_order_invoke(
    accounts: FillPerpOrderAccounts<'_, '_>,
    args: FillPerpOrderIxArgs,
) -> ProgramResult {
    fill_perp_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn fill_perp_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: FillPerpOrderAccounts<'_, '_>,
    args: FillPerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: FillPerpOrderKeys = accounts.into();
    let ix = fill_perp_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn fill_perp_order_invoke_signed(
    accounts: FillPerpOrderAccounts<'_, '_>,
    args: FillPerpOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    fill_perp_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn fill_perp_order_verify_account_keys(
    accounts: FillPerpOrderAccounts<'_, '_>,
    keys: FillPerpOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.filler_stats.key, keys.filler_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn fill_perp_order_verify_writable_privileges<'me, 'info>(
    accounts: FillPerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.filler,
        accounts.filler_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn fill_perp_order_verify_signer_privileges<'me, 'info>(
    accounts: FillPerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn fill_perp_order_verify_account_privileges<'me, 'info>(
    accounts: FillPerpOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    fill_perp_order_verify_writable_privileges(accounts)?;
    fill_perp_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const REVERT_FILL_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct RevertFillAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub filler_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RevertFillKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub filler_stats: Pubkey,
}
impl From<RevertFillAccounts<'_, '_>> for RevertFillKeys {
    fn from(accounts: RevertFillAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            filler_stats: *accounts.filler_stats.key,
        }
    }
}
impl From<RevertFillKeys> for [AccountMeta; REVERT_FILL_IX_ACCOUNTS_LEN] {
    fn from(keys: RevertFillKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.filler_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; REVERT_FILL_IX_ACCOUNTS_LEN]> for RevertFillKeys {
    fn from(pubkeys: [Pubkey; REVERT_FILL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            filler_stats: pubkeys[3],
        }
    }
}
impl<'info> From<RevertFillAccounts<'_, 'info>>
for [AccountInfo<'info>; REVERT_FILL_IX_ACCOUNTS_LEN] {
    fn from(accounts: RevertFillAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.filler_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; REVERT_FILL_IX_ACCOUNTS_LEN]>
for RevertFillAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; REVERT_FILL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            filler_stats: &arr[3],
        }
    }
}
pub const REVERT_FILL_IX_DISCM: [u8; 8] = [236, 238, 176, 69, 239, 10, 181, 193];
#[derive(Clone, Debug, PartialEq)]
pub struct RevertFillIxData;
impl RevertFillIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != REVERT_FILL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        REVERT_FILL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&REVERT_FILL_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn revert_fill_ix_with_program_id(
    program_id: Pubkey,
    keys: RevertFillKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; REVERT_FILL_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: RevertFillIxData.try_to_vec()?,
    })
}
pub fn revert_fill_ix(keys: RevertFillKeys) -> std::io::Result<Instruction> {
    revert_fill_ix_with_program_id(crate::ID, keys)
}
pub fn revert_fill_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RevertFillAccounts<'_, '_>,
) -> ProgramResult {
    let keys: RevertFillKeys = accounts.into();
    let ix = revert_fill_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn revert_fill_invoke(accounts: RevertFillAccounts<'_, '_>) -> ProgramResult {
    revert_fill_invoke_with_program_id(crate::ID, accounts)
}
pub fn revert_fill_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RevertFillAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RevertFillKeys = accounts.into();
    let ix = revert_fill_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn revert_fill_invoke_signed(
    accounts: RevertFillAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    revert_fill_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn revert_fill_verify_account_keys(
    accounts: RevertFillAccounts<'_, '_>,
    keys: RevertFillKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.filler_stats.key, keys.filler_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn revert_fill_verify_writable_privileges<'me, 'info>(
    accounts: RevertFillAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.filler, accounts.filler_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn revert_fill_verify_signer_privileges<'me, 'info>(
    accounts: RevertFillAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn revert_fill_verify_account_privileges<'me, 'info>(
    accounts: RevertFillAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    revert_fill_verify_writable_privileges(accounts)?;
    revert_fill_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const FILL_SPOT_ORDER_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct FillSpotOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub filler_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct FillSpotOrderKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub filler_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<FillSpotOrderAccounts<'_, '_>> for FillSpotOrderKeys {
    fn from(accounts: FillSpotOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            filler_stats: *accounts.filler_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<FillSpotOrderKeys> for [AccountMeta; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: FillSpotOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.filler_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN]> for FillSpotOrderKeys {
    fn from(pubkeys: [Pubkey; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            filler_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<FillSpotOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: FillSpotOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.filler_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN]>
for FillSpotOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            filler_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const FILL_SPOT_ORDER_IX_DISCM: [u8; 8] = [212, 206, 130, 173, 21, 34, 199, 40];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct FillSpotOrderIxArgs {
    pub order_id: Option<u32>,
    pub fulfillment_type: Option<SpotFulfillmentType>,
    pub maker_order_id: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct FillSpotOrderIxData(pub FillSpotOrderIxArgs);
impl From<FillSpotOrderIxArgs> for FillSpotOrderIxData {
    fn from(args: FillSpotOrderIxArgs) -> Self {
        Self(args)
    }
}
impl FillSpotOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != FILL_SPOT_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        FILL_SPOT_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(FillSpotOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&FILL_SPOT_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn fill_spot_order_ix_with_program_id(
    program_id: Pubkey,
    keys: FillSpotOrderKeys,
    args: FillSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; FILL_SPOT_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: FillSpotOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn fill_spot_order_ix(
    keys: FillSpotOrderKeys,
    args: FillSpotOrderIxArgs,
) -> std::io::Result<Instruction> {
    fill_spot_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn fill_spot_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: FillSpotOrderAccounts<'_, '_>,
    args: FillSpotOrderIxArgs,
) -> ProgramResult {
    let keys: FillSpotOrderKeys = accounts.into();
    let ix = fill_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn fill_spot_order_invoke(
    accounts: FillSpotOrderAccounts<'_, '_>,
    args: FillSpotOrderIxArgs,
) -> ProgramResult {
    fill_spot_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn fill_spot_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: FillSpotOrderAccounts<'_, '_>,
    args: FillSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: FillSpotOrderKeys = accounts.into();
    let ix = fill_spot_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn fill_spot_order_invoke_signed(
    accounts: FillSpotOrderAccounts<'_, '_>,
    args: FillSpotOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    fill_spot_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn fill_spot_order_verify_account_keys(
    accounts: FillSpotOrderAccounts<'_, '_>,
    keys: FillSpotOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.filler_stats.key, keys.filler_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn fill_spot_order_verify_writable_privileges<'me, 'info>(
    accounts: FillSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.filler,
        accounts.filler_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn fill_spot_order_verify_signer_privileges<'me, 'info>(
    accounts: FillSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn fill_spot_order_verify_account_privileges<'me, 'info>(
    accounts: FillSpotOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    fill_spot_order_verify_writable_privileges(accounts)?;
    fill_spot_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const TRIGGER_ORDER_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct TriggerOrderAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct TriggerOrderKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub user: Pubkey,
}
impl From<TriggerOrderAccounts<'_, '_>> for TriggerOrderKeys {
    fn from(accounts: TriggerOrderAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            user: *accounts.user.key,
        }
    }
}
impl From<TriggerOrderKeys> for [AccountMeta; TRIGGER_ORDER_IX_ACCOUNTS_LEN] {
    fn from(keys: TriggerOrderKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; TRIGGER_ORDER_IX_ACCOUNTS_LEN]> for TriggerOrderKeys {
    fn from(pubkeys: [Pubkey; TRIGGER_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            user: pubkeys[3],
        }
    }
}
impl<'info> From<TriggerOrderAccounts<'_, 'info>>
for [AccountInfo<'info>; TRIGGER_ORDER_IX_ACCOUNTS_LEN] {
    fn from(accounts: TriggerOrderAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.user.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; TRIGGER_ORDER_IX_ACCOUNTS_LEN]>
for TriggerOrderAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; TRIGGER_ORDER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            user: &arr[3],
        }
    }
}
pub const TRIGGER_ORDER_IX_DISCM: [u8; 8] = [63, 112, 51, 233, 232, 47, 240, 199];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct TriggerOrderIxArgs {
    pub order_id: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct TriggerOrderIxData(pub TriggerOrderIxArgs);
impl From<TriggerOrderIxArgs> for TriggerOrderIxData {
    fn from(args: TriggerOrderIxArgs) -> Self {
        Self(args)
    }
}
impl TriggerOrderIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != TRIGGER_ORDER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        TRIGGER_ORDER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(TriggerOrderIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&TRIGGER_ORDER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn trigger_order_ix_with_program_id(
    program_id: Pubkey,
    keys: TriggerOrderKeys,
    args: TriggerOrderIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; TRIGGER_ORDER_IX_ACCOUNTS_LEN] = keys.into();
    let data: TriggerOrderIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn trigger_order_ix(
    keys: TriggerOrderKeys,
    args: TriggerOrderIxArgs,
) -> std::io::Result<Instruction> {
    trigger_order_ix_with_program_id(crate::ID, keys, args)
}
pub fn trigger_order_invoke_with_program_id(
    program_id: Pubkey,
    accounts: TriggerOrderAccounts<'_, '_>,
    args: TriggerOrderIxArgs,
) -> ProgramResult {
    let keys: TriggerOrderKeys = accounts.into();
    let ix = trigger_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn trigger_order_invoke(
    accounts: TriggerOrderAccounts<'_, '_>,
    args: TriggerOrderIxArgs,
) -> ProgramResult {
    trigger_order_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn trigger_order_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: TriggerOrderAccounts<'_, '_>,
    args: TriggerOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: TriggerOrderKeys = accounts.into();
    let ix = trigger_order_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn trigger_order_invoke_signed(
    accounts: TriggerOrderAccounts<'_, '_>,
    args: TriggerOrderIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    trigger_order_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn trigger_order_verify_account_keys(
    accounts: TriggerOrderAccounts<'_, '_>,
    keys: TriggerOrderKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn trigger_order_verify_writable_privileges<'me, 'info>(
    accounts: TriggerOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.filler, accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn trigger_order_verify_signer_privileges<'me, 'info>(
    accounts: TriggerOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn trigger_order_verify_account_privileges<'me, 'info>(
    accounts: TriggerOrderAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    trigger_order_verify_writable_privileges(accounts)?;
    trigger_order_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct ForceCancelOrdersAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ForceCancelOrdersKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub user: Pubkey,
}
impl From<ForceCancelOrdersAccounts<'_, '_>> for ForceCancelOrdersKeys {
    fn from(accounts: ForceCancelOrdersAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            user: *accounts.user.key,
        }
    }
}
impl From<ForceCancelOrdersKeys> for [AccountMeta; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN] {
    fn from(keys: ForceCancelOrdersKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN]> for ForceCancelOrdersKeys {
    fn from(pubkeys: [Pubkey; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            user: pubkeys[3],
        }
    }
}
impl<'info> From<ForceCancelOrdersAccounts<'_, 'info>>
for [AccountInfo<'info>; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN] {
    fn from(accounts: ForceCancelOrdersAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.user.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN]>
for ForceCancelOrdersAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            user: &arr[3],
        }
    }
}
pub const FORCE_CANCEL_ORDERS_IX_DISCM: [u8; 8] = [64, 181, 196, 63, 222, 72, 64, 232];
#[derive(Clone, Debug, PartialEq)]
pub struct ForceCancelOrdersIxData;
impl ForceCancelOrdersIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != FORCE_CANCEL_ORDERS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        FORCE_CANCEL_ORDERS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&FORCE_CANCEL_ORDERS_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn force_cancel_orders_ix_with_program_id(
    program_id: Pubkey,
    keys: ForceCancelOrdersKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: ForceCancelOrdersIxData.try_to_vec()?,
    })
}
pub fn force_cancel_orders_ix(
    keys: ForceCancelOrdersKeys,
) -> std::io::Result<Instruction> {
    force_cancel_orders_ix_with_program_id(crate::ID, keys)
}
pub fn force_cancel_orders_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ForceCancelOrdersAccounts<'_, '_>,
) -> ProgramResult {
    let keys: ForceCancelOrdersKeys = accounts.into();
    let ix = force_cancel_orders_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn force_cancel_orders_invoke(
    accounts: ForceCancelOrdersAccounts<'_, '_>,
) -> ProgramResult {
    force_cancel_orders_invoke_with_program_id(crate::ID, accounts)
}
pub fn force_cancel_orders_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ForceCancelOrdersAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ForceCancelOrdersKeys = accounts.into();
    let ix = force_cancel_orders_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn force_cancel_orders_invoke_signed(
    accounts: ForceCancelOrdersAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    force_cancel_orders_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn force_cancel_orders_verify_account_keys(
    accounts: ForceCancelOrdersAccounts<'_, '_>,
    keys: ForceCancelOrdersKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn force_cancel_orders_verify_writable_privileges<'me, 'info>(
    accounts: ForceCancelOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.filler, accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn force_cancel_orders_verify_signer_privileges<'me, 'info>(
    accounts: ForceCancelOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn force_cancel_orders_verify_account_privileges<'me, 'info>(
    accounts: ForceCancelOrdersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    force_cancel_orders_verify_writable_privileges(accounts)?;
    force_cancel_orders_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_IDLE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserIdleAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserIdleKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub user: Pubkey,
}
impl From<UpdateUserIdleAccounts<'_, '_>> for UpdateUserIdleKeys {
    fn from(accounts: UpdateUserIdleAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            user: *accounts.user.key,
        }
    }
}
impl From<UpdateUserIdleKeys> for [AccountMeta; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserIdleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN]> for UpdateUserIdleKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            user: pubkeys[3],
        }
    }
}
impl<'info> From<UpdateUserIdleAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserIdleAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.user.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN]>
for UpdateUserIdleAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            user: &arr[3],
        }
    }
}
pub const UPDATE_USER_IDLE_IX_DISCM: [u8; 8] = [253, 133, 67, 22, 103, 161, 20, 100];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserIdleIxData;
impl UpdateUserIdleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_IDLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_IDLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_IDLE_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_idle_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserIdleKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_IDLE_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateUserIdleIxData.try_to_vec()?,
    })
}
pub fn update_user_idle_ix(keys: UpdateUserIdleKeys) -> std::io::Result<Instruction> {
    update_user_idle_ix_with_program_id(crate::ID, keys)
}
pub fn update_user_idle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserIdleAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateUserIdleKeys = accounts.into();
    let ix = update_user_idle_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_idle_invoke(
    accounts: UpdateUserIdleAccounts<'_, '_>,
) -> ProgramResult {
    update_user_idle_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_user_idle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserIdleAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserIdleKeys = accounts.into();
    let ix = update_user_idle_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_idle_invoke_signed(
    accounts: UpdateUserIdleAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_idle_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn update_user_idle_verify_account_keys(
    accounts: UpdateUserIdleAccounts<'_, '_>,
    keys: UpdateUserIdleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_idle_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserIdleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.filler, accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_idle_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserIdleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_idle_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserIdleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_idle_verify_writable_privileges(accounts)?;
    update_user_idle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct DisableUserHighLeverageModeAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub high_leverage_mode_config: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DisableUserHighLeverageModeKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub user: Pubkey,
    pub high_leverage_mode_config: Pubkey,
}
impl From<DisableUserHighLeverageModeAccounts<'_, '_>>
for DisableUserHighLeverageModeKeys {
    fn from(accounts: DisableUserHighLeverageModeAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            user: *accounts.user.key,
            high_leverage_mode_config: *accounts.high_leverage_mode_config.key,
        }
    }
}
impl From<DisableUserHighLeverageModeKeys>
for [AccountMeta; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN] {
    fn from(keys: DisableUserHighLeverageModeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.high_leverage_mode_config,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN]>
for DisableUserHighLeverageModeKeys {
    fn from(pubkeys: [Pubkey; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            user: pubkeys[2],
            high_leverage_mode_config: pubkeys[3],
        }
    }
}
impl<'info> From<DisableUserHighLeverageModeAccounts<'_, 'info>>
for [AccountInfo<'info>; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN] {
    fn from(accounts: DisableUserHighLeverageModeAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.user.clone(),
            accounts.high_leverage_mode_config.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN]>
for DisableUserHighLeverageModeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            user: &arr[2],
            high_leverage_mode_config: &arr[3],
        }
    }
}
pub const DISABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM: [u8; 8] = [
    183,
    155,
    45,
    0,
    226,
    85,
    213,
    69,
];
#[derive(Clone, Debug, PartialEq)]
pub struct DisableUserHighLeverageModeIxData;
impl DisableUserHighLeverageModeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DISABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DISABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DISABLE_USER_HIGH_LEVERAGE_MODE_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn disable_user_high_leverage_mode_ix_with_program_id(
    program_id: Pubkey,
    keys: DisableUserHighLeverageModeKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DISABLE_USER_HIGH_LEVERAGE_MODE_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: DisableUserHighLeverageModeIxData.try_to_vec()?,
    })
}
pub fn disable_user_high_leverage_mode_ix(
    keys: DisableUserHighLeverageModeKeys,
) -> std::io::Result<Instruction> {
    disable_user_high_leverage_mode_ix_with_program_id(crate::ID, keys)
}
pub fn disable_user_high_leverage_mode_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DisableUserHighLeverageModeAccounts<'_, '_>,
) -> ProgramResult {
    let keys: DisableUserHighLeverageModeKeys = accounts.into();
    let ix = disable_user_high_leverage_mode_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn disable_user_high_leverage_mode_invoke(
    accounts: DisableUserHighLeverageModeAccounts<'_, '_>,
) -> ProgramResult {
    disable_user_high_leverage_mode_invoke_with_program_id(crate::ID, accounts)
}
pub fn disable_user_high_leverage_mode_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DisableUserHighLeverageModeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DisableUserHighLeverageModeKeys = accounts.into();
    let ix = disable_user_high_leverage_mode_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn disable_user_high_leverage_mode_invoke_signed(
    accounts: DisableUserHighLeverageModeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    disable_user_high_leverage_mode_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn disable_user_high_leverage_mode_verify_account_keys(
    accounts: DisableUserHighLeverageModeAccounts<'_, '_>,
    keys: DisableUserHighLeverageModeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.user.key, keys.user),
        (*accounts.high_leverage_mode_config.key, keys.high_leverage_mode_config),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn disable_user_high_leverage_mode_verify_writable_privileges<'me, 'info>(
    accounts: DisableUserHighLeverageModeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.high_leverage_mode_config] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn disable_user_high_leverage_mode_verify_signer_privileges<'me, 'info>(
    accounts: DisableUserHighLeverageModeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn disable_user_high_leverage_mode_verify_account_privileges<'me, 'info>(
    accounts: DisableUserHighLeverageModeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    disable_user_high_leverage_mode_verify_writable_privileges(accounts)?;
    disable_user_high_leverage_mode_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserFuelBonusAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserFuelBonusKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<UpdateUserFuelBonusAccounts<'_, '_>> for UpdateUserFuelBonusKeys {
    fn from(accounts: UpdateUserFuelBonusAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<UpdateUserFuelBonusKeys>
for [AccountMeta; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserFuelBonusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN]> for UpdateUserFuelBonusKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            user: pubkeys[2],
            user_stats: pubkeys[3],
        }
    }
}
impl<'info> From<UpdateUserFuelBonusAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserFuelBonusAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN]>
for UpdateUserFuelBonusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            user: &arr[2],
            user_stats: &arr[3],
        }
    }
}
pub const UPDATE_USER_FUEL_BONUS_IX_DISCM: [u8; 8] = [
    88,
    175,
    201,
    190,
    222,
    100,
    143,
    57,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserFuelBonusIxData;
impl UpdateUserFuelBonusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_FUEL_BONUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_FUEL_BONUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_FUEL_BONUS_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_fuel_bonus_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserFuelBonusKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_FUEL_BONUS_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateUserFuelBonusIxData.try_to_vec()?,
    })
}
pub fn update_user_fuel_bonus_ix(
    keys: UpdateUserFuelBonusKeys,
) -> std::io::Result<Instruction> {
    update_user_fuel_bonus_ix_with_program_id(crate::ID, keys)
}
pub fn update_user_fuel_bonus_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserFuelBonusAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateUserFuelBonusKeys = accounts.into();
    let ix = update_user_fuel_bonus_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_fuel_bonus_invoke(
    accounts: UpdateUserFuelBonusAccounts<'_, '_>,
) -> ProgramResult {
    update_user_fuel_bonus_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_user_fuel_bonus_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserFuelBonusAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserFuelBonusKeys = accounts.into();
    let ix = update_user_fuel_bonus_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_fuel_bonus_invoke_signed(
    accounts: UpdateUserFuelBonusAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_fuel_bonus_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn update_user_fuel_bonus_verify_account_keys(
    accounts: UpdateUserFuelBonusAccounts<'_, '_>,
    keys: UpdateUserFuelBonusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_fuel_bonus_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserFuelBonusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_fuel_bonus_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserFuelBonusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_fuel_bonus_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserFuelBonusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_fuel_bonus_verify_writable_privileges(accounts)?;
    update_user_fuel_bonus_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserOpenOrdersCountAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub filler: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserOpenOrdersCountKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub filler: Pubkey,
    pub user: Pubkey,
}
impl From<UpdateUserOpenOrdersCountAccounts<'_, '_>> for UpdateUserOpenOrdersCountKeys {
    fn from(accounts: UpdateUserOpenOrdersCountAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            filler: *accounts.filler.key,
            user: *accounts.user.key,
        }
    }
}
impl From<UpdateUserOpenOrdersCountKeys>
for [AccountMeta; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserOpenOrdersCountKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.filler,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN]>
for UpdateUserOpenOrdersCountKeys {
    fn from(pubkeys: [Pubkey; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            filler: pubkeys[2],
            user: pubkeys[3],
        }
    }
}
impl<'info> From<UpdateUserOpenOrdersCountAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserOpenOrdersCountAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.filler.clone(),
            accounts.user.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN]>
for UpdateUserOpenOrdersCountAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            filler: &arr[2],
            user: &arr[3],
        }
    }
}
pub const UPDATE_USER_OPEN_ORDERS_COUNT_IX_DISCM: [u8; 8] = [
    104,
    39,
    65,
    210,
    250,
    163,
    100,
    134,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserOpenOrdersCountIxData;
impl UpdateUserOpenOrdersCountIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_OPEN_ORDERS_COUNT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_OPEN_ORDERS_COUNT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_OPEN_ORDERS_COUNT_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_open_orders_count_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserOpenOrdersCountKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_OPEN_ORDERS_COUNT_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateUserOpenOrdersCountIxData.try_to_vec()?,
    })
}
pub fn update_user_open_orders_count_ix(
    keys: UpdateUserOpenOrdersCountKeys,
) -> std::io::Result<Instruction> {
    update_user_open_orders_count_ix_with_program_id(crate::ID, keys)
}
pub fn update_user_open_orders_count_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserOpenOrdersCountAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateUserOpenOrdersCountKeys = accounts.into();
    let ix = update_user_open_orders_count_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_open_orders_count_invoke(
    accounts: UpdateUserOpenOrdersCountAccounts<'_, '_>,
) -> ProgramResult {
    update_user_open_orders_count_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_user_open_orders_count_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserOpenOrdersCountAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserOpenOrdersCountKeys = accounts.into();
    let ix = update_user_open_orders_count_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_open_orders_count_invoke_signed(
    accounts: UpdateUserOpenOrdersCountAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_open_orders_count_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn update_user_open_orders_count_verify_account_keys(
    accounts: UpdateUserOpenOrdersCountAccounts<'_, '_>,
    keys: UpdateUserOpenOrdersCountKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.filler.key, keys.filler),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_open_orders_count_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserOpenOrdersCountAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.filler, accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_open_orders_count_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserOpenOrdersCountAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_open_orders_count_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserOpenOrdersCountAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_open_orders_count_verify_writable_privileges(accounts)?;
    update_user_open_orders_count_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct AdminDisableUpdatePerpBidAskTwapAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct AdminDisableUpdatePerpBidAskTwapKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub user_stats: Pubkey,
}
impl From<AdminDisableUpdatePerpBidAskTwapAccounts<'_, '_>>
for AdminDisableUpdatePerpBidAskTwapKeys {
    fn from(accounts: AdminDisableUpdatePerpBidAskTwapAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<AdminDisableUpdatePerpBidAskTwapKeys>
for [AccountMeta; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN] {
    fn from(keys: AdminDisableUpdatePerpBidAskTwapKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN]>
for AdminDisableUpdatePerpBidAskTwapKeys {
    fn from(
        pubkeys: [Pubkey; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            user_stats: pubkeys[2],
        }
    }
}
impl<'info> From<AdminDisableUpdatePerpBidAskTwapAccounts<'_, 'info>>
for [AccountInfo<'info>; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN] {
    fn from(accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.user_stats.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN]>
for AdminDisableUpdatePerpBidAskTwapAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            user_stats: &arr[2],
        }
    }
}
pub const ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_DISCM: [u8; 8] = [
    17,
    164,
    82,
    45,
    183,
    86,
    191,
    199,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AdminDisableUpdatePerpBidAskTwapIxArgs {
    pub disable: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct AdminDisableUpdatePerpBidAskTwapIxData(
    pub AdminDisableUpdatePerpBidAskTwapIxArgs,
);
impl From<AdminDisableUpdatePerpBidAskTwapIxArgs>
for AdminDisableUpdatePerpBidAskTwapIxData {
    fn from(args: AdminDisableUpdatePerpBidAskTwapIxArgs) -> Self {
        Self(args)
    }
}
impl AdminDisableUpdatePerpBidAskTwapIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(AdminDisableUpdatePerpBidAskTwapIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn admin_disable_update_perp_bid_ask_twap_ix_with_program_id(
    program_id: Pubkey,
    keys: AdminDisableUpdatePerpBidAskTwapKeys,
    args: AdminDisableUpdatePerpBidAskTwapIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; ADMIN_DISABLE_UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: AdminDisableUpdatePerpBidAskTwapIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn admin_disable_update_perp_bid_ask_twap_ix(
    keys: AdminDisableUpdatePerpBidAskTwapKeys,
    args: AdminDisableUpdatePerpBidAskTwapIxArgs,
) -> std::io::Result<Instruction> {
    admin_disable_update_perp_bid_ask_twap_ix_with_program_id(crate::ID, keys, args)
}
pub fn admin_disable_update_perp_bid_ask_twap_invoke_with_program_id(
    program_id: Pubkey,
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'_, '_>,
    args: AdminDisableUpdatePerpBidAskTwapIxArgs,
) -> ProgramResult {
    let keys: AdminDisableUpdatePerpBidAskTwapKeys = accounts.into();
    let ix = admin_disable_update_perp_bid_ask_twap_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn admin_disable_update_perp_bid_ask_twap_invoke(
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'_, '_>,
    args: AdminDisableUpdatePerpBidAskTwapIxArgs,
) -> ProgramResult {
    admin_disable_update_perp_bid_ask_twap_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn admin_disable_update_perp_bid_ask_twap_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'_, '_>,
    args: AdminDisableUpdatePerpBidAskTwapIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: AdminDisableUpdatePerpBidAskTwapKeys = accounts.into();
    let ix = admin_disable_update_perp_bid_ask_twap_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn admin_disable_update_perp_bid_ask_twap_invoke_signed(
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'_, '_>,
    args: AdminDisableUpdatePerpBidAskTwapIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    admin_disable_update_perp_bid_ask_twap_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn admin_disable_update_perp_bid_ask_twap_verify_account_keys(
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'_, '_>,
    keys: AdminDisableUpdatePerpBidAskTwapKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn admin_disable_update_perp_bid_ask_twap_verify_writable_privileges<'me, 'info>(
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn admin_disable_update_perp_bid_ask_twap_verify_signer_privileges<'me, 'info>(
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn admin_disable_update_perp_bid_ask_twap_verify_account_privileges<'me, 'info>(
    accounts: AdminDisableUpdatePerpBidAskTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    admin_disable_update_perp_bid_ask_twap_verify_writable_privileges(accounts)?;
    admin_disable_update_perp_bid_ask_twap_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_PNL_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct SettlePnlAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettlePnlKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
}
impl From<SettlePnlAccounts<'_, '_>> for SettlePnlKeys {
    fn from(accounts: SettlePnlAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
        }
    }
}
impl From<SettlePnlKeys> for [AccountMeta; SETTLE_PNL_IX_ACCOUNTS_LEN] {
    fn from(keys: SettlePnlKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_PNL_IX_ACCOUNTS_LEN]> for SettlePnlKeys {
    fn from(pubkeys: [Pubkey; SETTLE_PNL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
            spot_market_vault: pubkeys[3],
        }
    }
}
impl<'info> From<SettlePnlAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_PNL_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettlePnlAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; SETTLE_PNL_IX_ACCOUNTS_LEN]>
for SettlePnlAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; SETTLE_PNL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
            spot_market_vault: &arr[3],
        }
    }
}
pub const SETTLE_PNL_IX_DISCM: [u8; 8] = [43, 61, 234, 45, 15, 95, 152, 153];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SettlePnlIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct SettlePnlIxData(pub SettlePnlIxArgs);
impl From<SettlePnlIxArgs> for SettlePnlIxData {
    fn from(args: SettlePnlIxArgs) -> Self {
        Self(args)
    }
}
impl SettlePnlIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_PNL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_PNL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(SettlePnlIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_PNL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_pnl_ix_with_program_id(
    program_id: Pubkey,
    keys: SettlePnlKeys,
    args: SettlePnlIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_PNL_IX_ACCOUNTS_LEN] = keys.into();
    let data: SettlePnlIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn settle_pnl_ix(
    keys: SettlePnlKeys,
    args: SettlePnlIxArgs,
) -> std::io::Result<Instruction> {
    settle_pnl_ix_with_program_id(crate::ID, keys, args)
}
pub fn settle_pnl_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettlePnlAccounts<'_, '_>,
    args: SettlePnlIxArgs,
) -> ProgramResult {
    let keys: SettlePnlKeys = accounts.into();
    let ix = settle_pnl_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_pnl_invoke(
    accounts: SettlePnlAccounts<'_, '_>,
    args: SettlePnlIxArgs,
) -> ProgramResult {
    settle_pnl_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn settle_pnl_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettlePnlAccounts<'_, '_>,
    args: SettlePnlIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettlePnlKeys = accounts.into();
    let ix = settle_pnl_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_pnl_invoke_signed(
    accounts: SettlePnlAccounts<'_, '_>,
    args: SettlePnlIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_pnl_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn settle_pnl_verify_account_keys(
    accounts: SettlePnlAccounts<'_, '_>,
    keys: SettlePnlKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_pnl_verify_writable_privileges<'me, 'info>(
    accounts: SettlePnlAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_pnl_verify_signer_privileges<'me, 'info>(
    accounts: SettlePnlAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn settle_pnl_verify_account_privileges<'me, 'info>(
    accounts: SettlePnlAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_pnl_verify_writable_privileges(accounts)?;
    settle_pnl_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct SettleMultiplePnlsAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettleMultiplePnlsKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
}
impl From<SettleMultiplePnlsAccounts<'_, '_>> for SettleMultiplePnlsKeys {
    fn from(accounts: SettleMultiplePnlsAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
        }
    }
}
impl From<SettleMultiplePnlsKeys>
for [AccountMeta; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN] {
    fn from(keys: SettleMultiplePnlsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN]> for SettleMultiplePnlsKeys {
    fn from(pubkeys: [Pubkey; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
            spot_market_vault: pubkeys[3],
        }
    }
}
impl<'info> From<SettleMultiplePnlsAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettleMultiplePnlsAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN]>
for SettleMultiplePnlsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
            spot_market_vault: &arr[3],
        }
    }
}
pub const SETTLE_MULTIPLE_PNLS_IX_DISCM: [u8; 8] = [127, 66, 117, 57, 40, 50, 152, 127];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SettleMultiplePnlsIxArgs {
    pub market_indexes: Vec<u16>,
    pub mode: SettlePnlMode,
}
#[derive(Clone, Debug, PartialEq)]
pub struct SettleMultiplePnlsIxData(pub SettleMultiplePnlsIxArgs);
impl From<SettleMultiplePnlsIxArgs> for SettleMultiplePnlsIxData {
    fn from(args: SettleMultiplePnlsIxArgs) -> Self {
        Self(args)
    }
}
impl SettleMultiplePnlsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_MULTIPLE_PNLS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_MULTIPLE_PNLS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(SettleMultiplePnlsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_MULTIPLE_PNLS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_multiple_pnls_ix_with_program_id(
    program_id: Pubkey,
    keys: SettleMultiplePnlsKeys,
    args: SettleMultiplePnlsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_MULTIPLE_PNLS_IX_ACCOUNTS_LEN] = keys.into();
    let data: SettleMultiplePnlsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn settle_multiple_pnls_ix(
    keys: SettleMultiplePnlsKeys,
    args: SettleMultiplePnlsIxArgs,
) -> std::io::Result<Instruction> {
    settle_multiple_pnls_ix_with_program_id(crate::ID, keys, args)
}
pub fn settle_multiple_pnls_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettleMultiplePnlsAccounts<'_, '_>,
    args: SettleMultiplePnlsIxArgs,
) -> ProgramResult {
    let keys: SettleMultiplePnlsKeys = accounts.into();
    let ix = settle_multiple_pnls_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_multiple_pnls_invoke(
    accounts: SettleMultiplePnlsAccounts<'_, '_>,
    args: SettleMultiplePnlsIxArgs,
) -> ProgramResult {
    settle_multiple_pnls_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn settle_multiple_pnls_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettleMultiplePnlsAccounts<'_, '_>,
    args: SettleMultiplePnlsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettleMultiplePnlsKeys = accounts.into();
    let ix = settle_multiple_pnls_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_multiple_pnls_invoke_signed(
    accounts: SettleMultiplePnlsAccounts<'_, '_>,
    args: SettleMultiplePnlsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_multiple_pnls_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn settle_multiple_pnls_verify_account_keys(
    accounts: SettleMultiplePnlsAccounts<'_, '_>,
    keys: SettleMultiplePnlsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_multiple_pnls_verify_writable_privileges<'me, 'info>(
    accounts: SettleMultiplePnlsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_multiple_pnls_verify_signer_privileges<'me, 'info>(
    accounts: SettleMultiplePnlsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn settle_multiple_pnls_verify_account_privileges<'me, 'info>(
    accounts: SettleMultiplePnlsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_multiple_pnls_verify_writable_privileges(accounts)?;
    settle_multiple_pnls_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct SettleFundingPaymentAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettleFundingPaymentKeys {
    pub state: Pubkey,
    pub user: Pubkey,
}
impl From<SettleFundingPaymentAccounts<'_, '_>> for SettleFundingPaymentKeys {
    fn from(accounts: SettleFundingPaymentAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
        }
    }
}
impl From<SettleFundingPaymentKeys>
for [AccountMeta; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN] {
    fn from(keys: SettleFundingPaymentKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN]>
for SettleFundingPaymentKeys {
    fn from(pubkeys: [Pubkey; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
        }
    }
}
impl<'info> From<SettleFundingPaymentAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettleFundingPaymentAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN]>
for SettleFundingPaymentAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
        }
    }
}
pub const SETTLE_FUNDING_PAYMENT_IX_DISCM: [u8; 8] = [
    222,
    90,
    202,
    94,
    28,
    45,
    115,
    183,
];
#[derive(Clone, Debug, PartialEq)]
pub struct SettleFundingPaymentIxData;
impl SettleFundingPaymentIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_FUNDING_PAYMENT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_FUNDING_PAYMENT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_FUNDING_PAYMENT_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_funding_payment_ix_with_program_id(
    program_id: Pubkey,
    keys: SettleFundingPaymentKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_FUNDING_PAYMENT_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: SettleFundingPaymentIxData.try_to_vec()?,
    })
}
pub fn settle_funding_payment_ix(
    keys: SettleFundingPaymentKeys,
) -> std::io::Result<Instruction> {
    settle_funding_payment_ix_with_program_id(crate::ID, keys)
}
pub fn settle_funding_payment_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettleFundingPaymentAccounts<'_, '_>,
) -> ProgramResult {
    let keys: SettleFundingPaymentKeys = accounts.into();
    let ix = settle_funding_payment_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_funding_payment_invoke(
    accounts: SettleFundingPaymentAccounts<'_, '_>,
) -> ProgramResult {
    settle_funding_payment_invoke_with_program_id(crate::ID, accounts)
}
pub fn settle_funding_payment_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettleFundingPaymentAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettleFundingPaymentKeys = accounts.into();
    let ix = settle_funding_payment_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_funding_payment_invoke_signed(
    accounts: SettleFundingPaymentAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_funding_payment_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn settle_funding_payment_verify_account_keys(
    accounts: SettleFundingPaymentAccounts<'_, '_>,
    keys: SettleFundingPaymentKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_funding_payment_verify_writable_privileges<'me, 'info>(
    accounts: SettleFundingPaymentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_funding_payment_verify_account_privileges<'me, 'info>(
    accounts: SettleFundingPaymentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_funding_payment_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_LP_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct SettleLpAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettleLpKeys {
    pub state: Pubkey,
    pub user: Pubkey,
}
impl From<SettleLpAccounts<'_, '_>> for SettleLpKeys {
    fn from(accounts: SettleLpAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
        }
    }
}
impl From<SettleLpKeys> for [AccountMeta; SETTLE_LP_IX_ACCOUNTS_LEN] {
    fn from(keys: SettleLpKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_LP_IX_ACCOUNTS_LEN]> for SettleLpKeys {
    fn from(pubkeys: [Pubkey; SETTLE_LP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
        }
    }
}
impl<'info> From<SettleLpAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_LP_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettleLpAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; SETTLE_LP_IX_ACCOUNTS_LEN]>
for SettleLpAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; SETTLE_LP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
        }
    }
}
pub const SETTLE_LP_IX_DISCM: [u8; 8] = [155, 231, 116, 113, 97, 229, 139, 141];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SettleLpIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct SettleLpIxData(pub SettleLpIxArgs);
impl From<SettleLpIxArgs> for SettleLpIxData {
    fn from(args: SettleLpIxArgs) -> Self {
        Self(args)
    }
}
impl SettleLpIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_LP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_LP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(SettleLpIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_LP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_lp_ix_with_program_id(
    program_id: Pubkey,
    keys: SettleLpKeys,
    args: SettleLpIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_LP_IX_ACCOUNTS_LEN] = keys.into();
    let data: SettleLpIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn settle_lp_ix(
    keys: SettleLpKeys,
    args: SettleLpIxArgs,
) -> std::io::Result<Instruction> {
    settle_lp_ix_with_program_id(crate::ID, keys, args)
}
pub fn settle_lp_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettleLpAccounts<'_, '_>,
    args: SettleLpIxArgs,
) -> ProgramResult {
    let keys: SettleLpKeys = accounts.into();
    let ix = settle_lp_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_lp_invoke(
    accounts: SettleLpAccounts<'_, '_>,
    args: SettleLpIxArgs,
) -> ProgramResult {
    settle_lp_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn settle_lp_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettleLpAccounts<'_, '_>,
    args: SettleLpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettleLpKeys = accounts.into();
    let ix = settle_lp_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_lp_invoke_signed(
    accounts: SettleLpAccounts<'_, '_>,
    args: SettleLpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_lp_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn settle_lp_verify_account_keys(
    accounts: SettleLpAccounts<'_, '_>,
    keys: SettleLpKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_lp_verify_writable_privileges<'me, 'info>(
    accounts: SettleLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_lp_verify_account_privileges<'me, 'info>(
    accounts: SettleLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_lp_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct SettleExpiredMarketAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettleExpiredMarketKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<SettleExpiredMarketAccounts<'_, '_>> for SettleExpiredMarketKeys {
    fn from(accounts: SettleExpiredMarketAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<SettleExpiredMarketKeys>
for [AccountMeta; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: SettleExpiredMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN]> for SettleExpiredMarketKeys {
    fn from(pubkeys: [Pubkey; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<SettleExpiredMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettleExpiredMarketAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN]>
for SettleExpiredMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const SETTLE_EXPIRED_MARKET_IX_DISCM: [u8; 8] = [120, 89, 11, 25, 122, 77, 72, 193];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SettleExpiredMarketIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct SettleExpiredMarketIxData(pub SettleExpiredMarketIxArgs);
impl From<SettleExpiredMarketIxArgs> for SettleExpiredMarketIxData {
    fn from(args: SettleExpiredMarketIxArgs) -> Self {
        Self(args)
    }
}
impl SettleExpiredMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_EXPIRED_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_EXPIRED_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(SettleExpiredMarketIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_EXPIRED_MARKET_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_expired_market_ix_with_program_id(
    program_id: Pubkey,
    keys: SettleExpiredMarketKeys,
    args: SettleExpiredMarketIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_EXPIRED_MARKET_IX_ACCOUNTS_LEN] = keys.into();
    let data: SettleExpiredMarketIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn settle_expired_market_ix(
    keys: SettleExpiredMarketKeys,
    args: SettleExpiredMarketIxArgs,
) -> std::io::Result<Instruction> {
    settle_expired_market_ix_with_program_id(crate::ID, keys, args)
}
pub fn settle_expired_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettleExpiredMarketAccounts<'_, '_>,
    args: SettleExpiredMarketIxArgs,
) -> ProgramResult {
    let keys: SettleExpiredMarketKeys = accounts.into();
    let ix = settle_expired_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_expired_market_invoke(
    accounts: SettleExpiredMarketAccounts<'_, '_>,
    args: SettleExpiredMarketIxArgs,
) -> ProgramResult {
    settle_expired_market_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn settle_expired_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettleExpiredMarketAccounts<'_, '_>,
    args: SettleExpiredMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettleExpiredMarketKeys = accounts.into();
    let ix = settle_expired_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_expired_market_invoke_signed(
    accounts: SettleExpiredMarketAccounts<'_, '_>,
    args: SettleExpiredMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_expired_market_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn settle_expired_market_verify_account_keys(
    accounts: SettleExpiredMarketAccounts<'_, '_>,
    keys: SettleExpiredMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_expired_market_verify_writable_privileges<'me, 'info>(
    accounts: SettleExpiredMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_expired_market_verify_signer_privileges<'me, 'info>(
    accounts: SettleExpiredMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn settle_expired_market_verify_account_privileges<'me, 'info>(
    accounts: SettleExpiredMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_expired_market_verify_writable_privileges(accounts)?;
    settle_expired_market_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const LIQUIDATE_PERP_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct LiquidatePerpAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct LiquidatePerpKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<LiquidatePerpAccounts<'_, '_>> for LiquidatePerpKeys {
    fn from(accounts: LiquidatePerpAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<LiquidatePerpKeys> for [AccountMeta; LIQUIDATE_PERP_IX_ACCOUNTS_LEN] {
    fn from(keys: LiquidatePerpKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; LIQUIDATE_PERP_IX_ACCOUNTS_LEN]> for LiquidatePerpKeys {
    fn from(pubkeys: [Pubkey; LIQUIDATE_PERP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<LiquidatePerpAccounts<'_, 'info>>
for [AccountInfo<'info>; LIQUIDATE_PERP_IX_ACCOUNTS_LEN] {
    fn from(accounts: LiquidatePerpAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; LIQUIDATE_PERP_IX_ACCOUNTS_LEN]>
for LiquidatePerpAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; LIQUIDATE_PERP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const LIQUIDATE_PERP_IX_DISCM: [u8; 8] = [75, 35, 119, 247, 191, 18, 139, 2];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LiquidatePerpIxArgs {
    pub market_index: u16,
    pub liquidator_max_base_asset_amount: u64,
    pub limit_price: Option<u64>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct LiquidatePerpIxData(pub LiquidatePerpIxArgs);
impl From<LiquidatePerpIxArgs> for LiquidatePerpIxData {
    fn from(args: LiquidatePerpIxArgs) -> Self {
        Self(args)
    }
}
impl LiquidatePerpIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != LIQUIDATE_PERP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        LIQUIDATE_PERP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(LiquidatePerpIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&LIQUIDATE_PERP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn liquidate_perp_ix_with_program_id(
    program_id: Pubkey,
    keys: LiquidatePerpKeys,
    args: LiquidatePerpIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; LIQUIDATE_PERP_IX_ACCOUNTS_LEN] = keys.into();
    let data: LiquidatePerpIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn liquidate_perp_ix(
    keys: LiquidatePerpKeys,
    args: LiquidatePerpIxArgs,
) -> std::io::Result<Instruction> {
    liquidate_perp_ix_with_program_id(crate::ID, keys, args)
}
pub fn liquidate_perp_invoke_with_program_id(
    program_id: Pubkey,
    accounts: LiquidatePerpAccounts<'_, '_>,
    args: LiquidatePerpIxArgs,
) -> ProgramResult {
    let keys: LiquidatePerpKeys = accounts.into();
    let ix = liquidate_perp_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn liquidate_perp_invoke(
    accounts: LiquidatePerpAccounts<'_, '_>,
    args: LiquidatePerpIxArgs,
) -> ProgramResult {
    liquidate_perp_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn liquidate_perp_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: LiquidatePerpAccounts<'_, '_>,
    args: LiquidatePerpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: LiquidatePerpKeys = accounts.into();
    let ix = liquidate_perp_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn liquidate_perp_invoke_signed(
    accounts: LiquidatePerpAccounts<'_, '_>,
    args: LiquidatePerpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    liquidate_perp_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn liquidate_perp_verify_account_keys(
    accounts: LiquidatePerpAccounts<'_, '_>,
    keys: LiquidatePerpKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn liquidate_perp_verify_writable_privileges<'me, 'info>(
    accounts: LiquidatePerpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn liquidate_perp_verify_signer_privileges<'me, 'info>(
    accounts: LiquidatePerpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn liquidate_perp_verify_account_privileges<'me, 'info>(
    accounts: LiquidatePerpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    liquidate_perp_verify_writable_privileges(accounts)?;
    liquidate_perp_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct LiquidatePerpWithFillAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct LiquidatePerpWithFillKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<LiquidatePerpWithFillAccounts<'_, '_>> for LiquidatePerpWithFillKeys {
    fn from(accounts: LiquidatePerpWithFillAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<LiquidatePerpWithFillKeys>
for [AccountMeta; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN] {
    fn from(keys: LiquidatePerpWithFillKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN]>
for LiquidatePerpWithFillKeys {
    fn from(pubkeys: [Pubkey; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<LiquidatePerpWithFillAccounts<'_, 'info>>
for [AccountInfo<'info>; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN] {
    fn from(accounts: LiquidatePerpWithFillAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN]>
for LiquidatePerpWithFillAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const LIQUIDATE_PERP_WITH_FILL_IX_DISCM: [u8; 8] = [
    95,
    111,
    124,
    105,
    86,
    169,
    187,
    34,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LiquidatePerpWithFillIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct LiquidatePerpWithFillIxData(pub LiquidatePerpWithFillIxArgs);
impl From<LiquidatePerpWithFillIxArgs> for LiquidatePerpWithFillIxData {
    fn from(args: LiquidatePerpWithFillIxArgs) -> Self {
        Self(args)
    }
}
impl LiquidatePerpWithFillIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != LIQUIDATE_PERP_WITH_FILL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        LIQUIDATE_PERP_WITH_FILL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(LiquidatePerpWithFillIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&LIQUIDATE_PERP_WITH_FILL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn liquidate_perp_with_fill_ix_with_program_id(
    program_id: Pubkey,
    keys: LiquidatePerpWithFillKeys,
    args: LiquidatePerpWithFillIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; LIQUIDATE_PERP_WITH_FILL_IX_ACCOUNTS_LEN] = keys.into();
    let data: LiquidatePerpWithFillIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn liquidate_perp_with_fill_ix(
    keys: LiquidatePerpWithFillKeys,
    args: LiquidatePerpWithFillIxArgs,
) -> std::io::Result<Instruction> {
    liquidate_perp_with_fill_ix_with_program_id(crate::ID, keys, args)
}
pub fn liquidate_perp_with_fill_invoke_with_program_id(
    program_id: Pubkey,
    accounts: LiquidatePerpWithFillAccounts<'_, '_>,
    args: LiquidatePerpWithFillIxArgs,
) -> ProgramResult {
    let keys: LiquidatePerpWithFillKeys = accounts.into();
    let ix = liquidate_perp_with_fill_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn liquidate_perp_with_fill_invoke(
    accounts: LiquidatePerpWithFillAccounts<'_, '_>,
    args: LiquidatePerpWithFillIxArgs,
) -> ProgramResult {
    liquidate_perp_with_fill_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn liquidate_perp_with_fill_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: LiquidatePerpWithFillAccounts<'_, '_>,
    args: LiquidatePerpWithFillIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: LiquidatePerpWithFillKeys = accounts.into();
    let ix = liquidate_perp_with_fill_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn liquidate_perp_with_fill_invoke_signed(
    accounts: LiquidatePerpWithFillAccounts<'_, '_>,
    args: LiquidatePerpWithFillIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    liquidate_perp_with_fill_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn liquidate_perp_with_fill_verify_account_keys(
    accounts: LiquidatePerpWithFillAccounts<'_, '_>,
    keys: LiquidatePerpWithFillKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn liquidate_perp_with_fill_verify_writable_privileges<'me, 'info>(
    accounts: LiquidatePerpWithFillAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn liquidate_perp_with_fill_verify_signer_privileges<'me, 'info>(
    accounts: LiquidatePerpWithFillAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn liquidate_perp_with_fill_verify_account_privileges<'me, 'info>(
    accounts: LiquidatePerpWithFillAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    liquidate_perp_with_fill_verify_writable_privileges(accounts)?;
    liquidate_perp_with_fill_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const LIQUIDATE_SPOT_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct LiquidateSpotAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct LiquidateSpotKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<LiquidateSpotAccounts<'_, '_>> for LiquidateSpotKeys {
    fn from(accounts: LiquidateSpotAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<LiquidateSpotKeys> for [AccountMeta; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN] {
    fn from(keys: LiquidateSpotKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN]> for LiquidateSpotKeys {
    fn from(pubkeys: [Pubkey; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<LiquidateSpotAccounts<'_, 'info>>
for [AccountInfo<'info>; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN] {
    fn from(accounts: LiquidateSpotAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN]>
for LiquidateSpotAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const LIQUIDATE_SPOT_IX_DISCM: [u8; 8] = [107, 0, 128, 41, 35, 229, 251, 18];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LiquidateSpotIxArgs {
    pub asset_market_index: u16,
    pub liability_market_index: u16,
    pub liquidator_max_liability_transfer: u128,
    pub limit_price: Option<u64>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct LiquidateSpotIxData(pub LiquidateSpotIxArgs);
impl From<LiquidateSpotIxArgs> for LiquidateSpotIxData {
    fn from(args: LiquidateSpotIxArgs) -> Self {
        Self(args)
    }
}
impl LiquidateSpotIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != LIQUIDATE_SPOT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        LIQUIDATE_SPOT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(LiquidateSpotIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&LIQUIDATE_SPOT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn liquidate_spot_ix_with_program_id(
    program_id: Pubkey,
    keys: LiquidateSpotKeys,
    args: LiquidateSpotIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; LIQUIDATE_SPOT_IX_ACCOUNTS_LEN] = keys.into();
    let data: LiquidateSpotIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn liquidate_spot_ix(
    keys: LiquidateSpotKeys,
    args: LiquidateSpotIxArgs,
) -> std::io::Result<Instruction> {
    liquidate_spot_ix_with_program_id(crate::ID, keys, args)
}
pub fn liquidate_spot_invoke_with_program_id(
    program_id: Pubkey,
    accounts: LiquidateSpotAccounts<'_, '_>,
    args: LiquidateSpotIxArgs,
) -> ProgramResult {
    let keys: LiquidateSpotKeys = accounts.into();
    let ix = liquidate_spot_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn liquidate_spot_invoke(
    accounts: LiquidateSpotAccounts<'_, '_>,
    args: LiquidateSpotIxArgs,
) -> ProgramResult {
    liquidate_spot_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn liquidate_spot_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: LiquidateSpotAccounts<'_, '_>,
    args: LiquidateSpotIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: LiquidateSpotKeys = accounts.into();
    let ix = liquidate_spot_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn liquidate_spot_invoke_signed(
    accounts: LiquidateSpotAccounts<'_, '_>,
    args: LiquidateSpotIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    liquidate_spot_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn liquidate_spot_verify_account_keys(
    accounts: LiquidateSpotAccounts<'_, '_>,
    keys: LiquidateSpotKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn liquidate_spot_verify_writable_privileges<'me, 'info>(
    accounts: LiquidateSpotAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn liquidate_spot_verify_signer_privileges<'me, 'info>(
    accounts: LiquidateSpotAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn liquidate_spot_verify_account_privileges<'me, 'info>(
    accounts: LiquidateSpotAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    liquidate_spot_verify_writable_privileges(accounts)?;
    liquidate_spot_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct LiquidateBorrowForPerpPnlAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct LiquidateBorrowForPerpPnlKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<LiquidateBorrowForPerpPnlAccounts<'_, '_>> for LiquidateBorrowForPerpPnlKeys {
    fn from(accounts: LiquidateBorrowForPerpPnlAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<LiquidateBorrowForPerpPnlKeys>
for [AccountMeta; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN] {
    fn from(keys: LiquidateBorrowForPerpPnlKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN]>
for LiquidateBorrowForPerpPnlKeys {
    fn from(pubkeys: [Pubkey; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<LiquidateBorrowForPerpPnlAccounts<'_, 'info>>
for [AccountInfo<'info>; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN] {
    fn from(accounts: LiquidateBorrowForPerpPnlAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN]>
for LiquidateBorrowForPerpPnlAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const LIQUIDATE_BORROW_FOR_PERP_PNL_IX_DISCM: [u8; 8] = [
    169,
    17,
    32,
    90,
    207,
    148,
    209,
    27,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LiquidateBorrowForPerpPnlIxArgs {
    pub perp_market_index: u16,
    pub spot_market_index: u16,
    pub liquidator_max_liability_transfer: u128,
    pub limit_price: Option<u64>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct LiquidateBorrowForPerpPnlIxData(pub LiquidateBorrowForPerpPnlIxArgs);
impl From<LiquidateBorrowForPerpPnlIxArgs> for LiquidateBorrowForPerpPnlIxData {
    fn from(args: LiquidateBorrowForPerpPnlIxArgs) -> Self {
        Self(args)
    }
}
impl LiquidateBorrowForPerpPnlIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != LIQUIDATE_BORROW_FOR_PERP_PNL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        LIQUIDATE_BORROW_FOR_PERP_PNL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(LiquidateBorrowForPerpPnlIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&LIQUIDATE_BORROW_FOR_PERP_PNL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn liquidate_borrow_for_perp_pnl_ix_with_program_id(
    program_id: Pubkey,
    keys: LiquidateBorrowForPerpPnlKeys,
    args: LiquidateBorrowForPerpPnlIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; LIQUIDATE_BORROW_FOR_PERP_PNL_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: LiquidateBorrowForPerpPnlIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn liquidate_borrow_for_perp_pnl_ix(
    keys: LiquidateBorrowForPerpPnlKeys,
    args: LiquidateBorrowForPerpPnlIxArgs,
) -> std::io::Result<Instruction> {
    liquidate_borrow_for_perp_pnl_ix_with_program_id(crate::ID, keys, args)
}
pub fn liquidate_borrow_for_perp_pnl_invoke_with_program_id(
    program_id: Pubkey,
    accounts: LiquidateBorrowForPerpPnlAccounts<'_, '_>,
    args: LiquidateBorrowForPerpPnlIxArgs,
) -> ProgramResult {
    let keys: LiquidateBorrowForPerpPnlKeys = accounts.into();
    let ix = liquidate_borrow_for_perp_pnl_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn liquidate_borrow_for_perp_pnl_invoke(
    accounts: LiquidateBorrowForPerpPnlAccounts<'_, '_>,
    args: LiquidateBorrowForPerpPnlIxArgs,
) -> ProgramResult {
    liquidate_borrow_for_perp_pnl_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn liquidate_borrow_for_perp_pnl_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: LiquidateBorrowForPerpPnlAccounts<'_, '_>,
    args: LiquidateBorrowForPerpPnlIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: LiquidateBorrowForPerpPnlKeys = accounts.into();
    let ix = liquidate_borrow_for_perp_pnl_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn liquidate_borrow_for_perp_pnl_invoke_signed(
    accounts: LiquidateBorrowForPerpPnlAccounts<'_, '_>,
    args: LiquidateBorrowForPerpPnlIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    liquidate_borrow_for_perp_pnl_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn liquidate_borrow_for_perp_pnl_verify_account_keys(
    accounts: LiquidateBorrowForPerpPnlAccounts<'_, '_>,
    keys: LiquidateBorrowForPerpPnlKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn liquidate_borrow_for_perp_pnl_verify_writable_privileges<'me, 'info>(
    accounts: LiquidateBorrowForPerpPnlAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn liquidate_borrow_for_perp_pnl_verify_signer_privileges<'me, 'info>(
    accounts: LiquidateBorrowForPerpPnlAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn liquidate_borrow_for_perp_pnl_verify_account_privileges<'me, 'info>(
    accounts: LiquidateBorrowForPerpPnlAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    liquidate_borrow_for_perp_pnl_verify_writable_privileges(accounts)?;
    liquidate_borrow_for_perp_pnl_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct LiquidatePerpPnlForDepositAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct LiquidatePerpPnlForDepositKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<LiquidatePerpPnlForDepositAccounts<'_, '_>>
for LiquidatePerpPnlForDepositKeys {
    fn from(accounts: LiquidatePerpPnlForDepositAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<LiquidatePerpPnlForDepositKeys>
for [AccountMeta; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN] {
    fn from(keys: LiquidatePerpPnlForDepositKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN]>
for LiquidatePerpPnlForDepositKeys {
    fn from(pubkeys: [Pubkey; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
        }
    }
}
impl<'info> From<LiquidatePerpPnlForDepositAccounts<'_, 'info>>
for [AccountInfo<'info>; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN] {
    fn from(accounts: LiquidatePerpPnlForDepositAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN]>
for LiquidatePerpPnlForDepositAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
        }
    }
}
pub const LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_DISCM: [u8; 8] = [
    237,
    75,
    198,
    235,
    233,
    186,
    75,
    35,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LiquidatePerpPnlForDepositIxArgs {
    pub perp_market_index: u16,
    pub spot_market_index: u16,
    pub liquidator_max_pnl_transfer: u128,
    pub limit_price: Option<u64>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct LiquidatePerpPnlForDepositIxData(pub LiquidatePerpPnlForDepositIxArgs);
impl From<LiquidatePerpPnlForDepositIxArgs> for LiquidatePerpPnlForDepositIxData {
    fn from(args: LiquidatePerpPnlForDepositIxArgs) -> Self {
        Self(args)
    }
}
impl LiquidatePerpPnlForDepositIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(LiquidatePerpPnlForDepositIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn liquidate_perp_pnl_for_deposit_ix_with_program_id(
    program_id: Pubkey,
    keys: LiquidatePerpPnlForDepositKeys,
    args: LiquidatePerpPnlForDepositIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; LIQUIDATE_PERP_PNL_FOR_DEPOSIT_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: LiquidatePerpPnlForDepositIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn liquidate_perp_pnl_for_deposit_ix(
    keys: LiquidatePerpPnlForDepositKeys,
    args: LiquidatePerpPnlForDepositIxArgs,
) -> std::io::Result<Instruction> {
    liquidate_perp_pnl_for_deposit_ix_with_program_id(crate::ID, keys, args)
}
pub fn liquidate_perp_pnl_for_deposit_invoke_with_program_id(
    program_id: Pubkey,
    accounts: LiquidatePerpPnlForDepositAccounts<'_, '_>,
    args: LiquidatePerpPnlForDepositIxArgs,
) -> ProgramResult {
    let keys: LiquidatePerpPnlForDepositKeys = accounts.into();
    let ix = liquidate_perp_pnl_for_deposit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn liquidate_perp_pnl_for_deposit_invoke(
    accounts: LiquidatePerpPnlForDepositAccounts<'_, '_>,
    args: LiquidatePerpPnlForDepositIxArgs,
) -> ProgramResult {
    liquidate_perp_pnl_for_deposit_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn liquidate_perp_pnl_for_deposit_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: LiquidatePerpPnlForDepositAccounts<'_, '_>,
    args: LiquidatePerpPnlForDepositIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: LiquidatePerpPnlForDepositKeys = accounts.into();
    let ix = liquidate_perp_pnl_for_deposit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn liquidate_perp_pnl_for_deposit_invoke_signed(
    accounts: LiquidatePerpPnlForDepositAccounts<'_, '_>,
    args: LiquidatePerpPnlForDepositIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    liquidate_perp_pnl_for_deposit_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn liquidate_perp_pnl_for_deposit_verify_account_keys(
    accounts: LiquidatePerpPnlForDepositAccounts<'_, '_>,
    keys: LiquidatePerpPnlForDepositKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn liquidate_perp_pnl_for_deposit_verify_writable_privileges<'me, 'info>(
    accounts: LiquidatePerpPnlForDepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn liquidate_perp_pnl_for_deposit_verify_signer_privileges<'me, 'info>(
    accounts: LiquidatePerpPnlForDepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn liquidate_perp_pnl_for_deposit_verify_account_privileges<'me, 'info>(
    accounts: LiquidatePerpPnlForDepositAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    liquidate_perp_pnl_for_deposit_verify_writable_privileges(accounts)?;
    liquidate_perp_pnl_for_deposit_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct SetUserStatusToBeingLiquidatedAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SetUserStatusToBeingLiquidatedKeys {
    pub state: Pubkey,
    pub user: Pubkey,
    pub authority: Pubkey,
}
impl From<SetUserStatusToBeingLiquidatedAccounts<'_, '_>>
for SetUserStatusToBeingLiquidatedKeys {
    fn from(accounts: SetUserStatusToBeingLiquidatedAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            user: *accounts.user.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<SetUserStatusToBeingLiquidatedKeys>
for [AccountMeta; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN] {
    fn from(keys: SetUserStatusToBeingLiquidatedKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN]>
for SetUserStatusToBeingLiquidatedKeys {
    fn from(
        pubkeys: [Pubkey; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            user: pubkeys[1],
            authority: pubkeys[2],
        }
    }
}
impl<'info> From<SetUserStatusToBeingLiquidatedAccounts<'_, 'info>>
for [AccountInfo<'info>; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN] {
    fn from(accounts: SetUserStatusToBeingLiquidatedAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.user.clone(), accounts.authority.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN]>
for SetUserStatusToBeingLiquidatedAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            user: &arr[1],
            authority: &arr[2],
        }
    }
}
pub const SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_DISCM: [u8; 8] = [
    106,
    133,
    160,
    206,
    193,
    171,
    192,
    194,
];
#[derive(Clone, Debug, PartialEq)]
pub struct SetUserStatusToBeingLiquidatedIxData;
impl SetUserStatusToBeingLiquidatedIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn set_user_status_to_being_liquidated_ix_with_program_id(
    program_id: Pubkey,
    keys: SetUserStatusToBeingLiquidatedKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SET_USER_STATUS_TO_BEING_LIQUIDATED_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: SetUserStatusToBeingLiquidatedIxData.try_to_vec()?,
    })
}
pub fn set_user_status_to_being_liquidated_ix(
    keys: SetUserStatusToBeingLiquidatedKeys,
) -> std::io::Result<Instruction> {
    set_user_status_to_being_liquidated_ix_with_program_id(crate::ID, keys)
}
pub fn set_user_status_to_being_liquidated_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SetUserStatusToBeingLiquidatedAccounts<'_, '_>,
) -> ProgramResult {
    let keys: SetUserStatusToBeingLiquidatedKeys = accounts.into();
    let ix = set_user_status_to_being_liquidated_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn set_user_status_to_being_liquidated_invoke(
    accounts: SetUserStatusToBeingLiquidatedAccounts<'_, '_>,
) -> ProgramResult {
    set_user_status_to_being_liquidated_invoke_with_program_id(crate::ID, accounts)
}
pub fn set_user_status_to_being_liquidated_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SetUserStatusToBeingLiquidatedAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SetUserStatusToBeingLiquidatedKeys = accounts.into();
    let ix = set_user_status_to_being_liquidated_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn set_user_status_to_being_liquidated_invoke_signed(
    accounts: SetUserStatusToBeingLiquidatedAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    set_user_status_to_being_liquidated_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn set_user_status_to_being_liquidated_verify_account_keys(
    accounts: SetUserStatusToBeingLiquidatedAccounts<'_, '_>,
    keys: SetUserStatusToBeingLiquidatedKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn set_user_status_to_being_liquidated_verify_writable_privileges<'me, 'info>(
    accounts: SetUserStatusToBeingLiquidatedAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn set_user_status_to_being_liquidated_verify_signer_privileges<'me, 'info>(
    accounts: SetUserStatusToBeingLiquidatedAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn set_user_status_to_being_liquidated_verify_account_privileges<'me, 'info>(
    accounts: SetUserStatusToBeingLiquidatedAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    set_user_status_to_being_liquidated_verify_writable_privileges(accounts)?;
    set_user_status_to_being_liquidated_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct ResolvePerpPnlDeficitAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ResolvePerpPnlDeficitKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub token_program: Pubkey,
}
impl From<ResolvePerpPnlDeficitAccounts<'_, '_>> for ResolvePerpPnlDeficitKeys {
    fn from(accounts: ResolvePerpPnlDeficitAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<ResolvePerpPnlDeficitKeys>
for [AccountMeta; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN] {
    fn from(keys: ResolvePerpPnlDeficitKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN]>
for ResolvePerpPnlDeficitKeys {
    fn from(pubkeys: [Pubkey; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            spot_market_vault: pubkeys[2],
            insurance_fund_vault: pubkeys[3],
            drift_signer: pubkeys[4],
            token_program: pubkeys[5],
        }
    }
}
impl<'info> From<ResolvePerpPnlDeficitAccounts<'_, 'info>>
for [AccountInfo<'info>; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN] {
    fn from(accounts: ResolvePerpPnlDeficitAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN]>
for ResolvePerpPnlDeficitAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            spot_market_vault: &arr[2],
            insurance_fund_vault: &arr[3],
            drift_signer: &arr[4],
            token_program: &arr[5],
        }
    }
}
pub const RESOLVE_PERP_PNL_DEFICIT_IX_DISCM: [u8; 8] = [
    168,
    204,
    68,
    150,
    159,
    126,
    95,
    148,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ResolvePerpPnlDeficitIxArgs {
    pub spot_market_index: u16,
    pub perp_market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct ResolvePerpPnlDeficitIxData(pub ResolvePerpPnlDeficitIxArgs);
impl From<ResolvePerpPnlDeficitIxArgs> for ResolvePerpPnlDeficitIxData {
    fn from(args: ResolvePerpPnlDeficitIxArgs) -> Self {
        Self(args)
    }
}
impl ResolvePerpPnlDeficitIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != RESOLVE_PERP_PNL_DEFICIT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        RESOLVE_PERP_PNL_DEFICIT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(ResolvePerpPnlDeficitIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&RESOLVE_PERP_PNL_DEFICIT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn resolve_perp_pnl_deficit_ix_with_program_id(
    program_id: Pubkey,
    keys: ResolvePerpPnlDeficitKeys,
    args: ResolvePerpPnlDeficitIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; RESOLVE_PERP_PNL_DEFICIT_IX_ACCOUNTS_LEN] = keys.into();
    let data: ResolvePerpPnlDeficitIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn resolve_perp_pnl_deficit_ix(
    keys: ResolvePerpPnlDeficitKeys,
    args: ResolvePerpPnlDeficitIxArgs,
) -> std::io::Result<Instruction> {
    resolve_perp_pnl_deficit_ix_with_program_id(crate::ID, keys, args)
}
pub fn resolve_perp_pnl_deficit_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ResolvePerpPnlDeficitAccounts<'_, '_>,
    args: ResolvePerpPnlDeficitIxArgs,
) -> ProgramResult {
    let keys: ResolvePerpPnlDeficitKeys = accounts.into();
    let ix = resolve_perp_pnl_deficit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn resolve_perp_pnl_deficit_invoke(
    accounts: ResolvePerpPnlDeficitAccounts<'_, '_>,
    args: ResolvePerpPnlDeficitIxArgs,
) -> ProgramResult {
    resolve_perp_pnl_deficit_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn resolve_perp_pnl_deficit_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ResolvePerpPnlDeficitAccounts<'_, '_>,
    args: ResolvePerpPnlDeficitIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ResolvePerpPnlDeficitKeys = accounts.into();
    let ix = resolve_perp_pnl_deficit_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn resolve_perp_pnl_deficit_invoke_signed(
    accounts: ResolvePerpPnlDeficitAccounts<'_, '_>,
    args: ResolvePerpPnlDeficitIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    resolve_perp_pnl_deficit_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn resolve_perp_pnl_deficit_verify_account_keys(
    accounts: ResolvePerpPnlDeficitAccounts<'_, '_>,
    keys: ResolvePerpPnlDeficitKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn resolve_perp_pnl_deficit_verify_writable_privileges<'me, 'info>(
    accounts: ResolvePerpPnlDeficitAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn resolve_perp_pnl_deficit_verify_signer_privileges<'me, 'info>(
    accounts: ResolvePerpPnlDeficitAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn resolve_perp_pnl_deficit_verify_account_privileges<'me, 'info>(
    accounts: ResolvePerpPnlDeficitAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    resolve_perp_pnl_deficit_verify_writable_privileges(accounts)?;
    resolve_perp_pnl_deficit_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN: usize = 10;
#[derive(Copy, Clone, Debug)]
pub struct ResolvePerpBankruptcyAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ResolvePerpBankruptcyKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub spot_market_vault: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub token_program: Pubkey,
}
impl From<ResolvePerpBankruptcyAccounts<'_, '_>> for ResolvePerpBankruptcyKeys {
    fn from(accounts: ResolvePerpBankruptcyAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<ResolvePerpBankruptcyKeys>
for [AccountMeta; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN] {
    fn from(keys: ResolvePerpBankruptcyKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN]>
for ResolvePerpBankruptcyKeys {
    fn from(pubkeys: [Pubkey; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
            spot_market_vault: pubkeys[6],
            insurance_fund_vault: pubkeys[7],
            drift_signer: pubkeys[8],
            token_program: pubkeys[9],
        }
    }
}
impl<'info> From<ResolvePerpBankruptcyAccounts<'_, 'info>>
for [AccountInfo<'info>; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN] {
    fn from(accounts: ResolvePerpBankruptcyAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.spot_market_vault.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN]>
for ResolvePerpBankruptcyAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
            spot_market_vault: &arr[6],
            insurance_fund_vault: &arr[7],
            drift_signer: &arr[8],
            token_program: &arr[9],
        }
    }
}
pub const RESOLVE_PERP_BANKRUPTCY_IX_DISCM: [u8; 8] = [
    224,
    16,
    176,
    214,
    162,
    213,
    183,
    222,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ResolvePerpBankruptcyIxArgs {
    pub quote_spot_market_index: u16,
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct ResolvePerpBankruptcyIxData(pub ResolvePerpBankruptcyIxArgs);
impl From<ResolvePerpBankruptcyIxArgs> for ResolvePerpBankruptcyIxData {
    fn from(args: ResolvePerpBankruptcyIxArgs) -> Self {
        Self(args)
    }
}
impl ResolvePerpBankruptcyIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != RESOLVE_PERP_BANKRUPTCY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        RESOLVE_PERP_BANKRUPTCY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(ResolvePerpBankruptcyIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&RESOLVE_PERP_BANKRUPTCY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn resolve_perp_bankruptcy_ix_with_program_id(
    program_id: Pubkey,
    keys: ResolvePerpBankruptcyKeys,
    args: ResolvePerpBankruptcyIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; RESOLVE_PERP_BANKRUPTCY_IX_ACCOUNTS_LEN] = keys.into();
    let data: ResolvePerpBankruptcyIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn resolve_perp_bankruptcy_ix(
    keys: ResolvePerpBankruptcyKeys,
    args: ResolvePerpBankruptcyIxArgs,
) -> std::io::Result<Instruction> {
    resolve_perp_bankruptcy_ix_with_program_id(crate::ID, keys, args)
}
pub fn resolve_perp_bankruptcy_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ResolvePerpBankruptcyAccounts<'_, '_>,
    args: ResolvePerpBankruptcyIxArgs,
) -> ProgramResult {
    let keys: ResolvePerpBankruptcyKeys = accounts.into();
    let ix = resolve_perp_bankruptcy_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn resolve_perp_bankruptcy_invoke(
    accounts: ResolvePerpBankruptcyAccounts<'_, '_>,
    args: ResolvePerpBankruptcyIxArgs,
) -> ProgramResult {
    resolve_perp_bankruptcy_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn resolve_perp_bankruptcy_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ResolvePerpBankruptcyAccounts<'_, '_>,
    args: ResolvePerpBankruptcyIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ResolvePerpBankruptcyKeys = accounts.into();
    let ix = resolve_perp_bankruptcy_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn resolve_perp_bankruptcy_invoke_signed(
    accounts: ResolvePerpBankruptcyAccounts<'_, '_>,
    args: ResolvePerpBankruptcyIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    resolve_perp_bankruptcy_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn resolve_perp_bankruptcy_verify_account_keys(
    accounts: ResolvePerpBankruptcyAccounts<'_, '_>,
    keys: ResolvePerpBankruptcyKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn resolve_perp_bankruptcy_verify_writable_privileges<'me, 'info>(
    accounts: ResolvePerpBankruptcyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn resolve_perp_bankruptcy_verify_signer_privileges<'me, 'info>(
    accounts: ResolvePerpBankruptcyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn resolve_perp_bankruptcy_verify_account_privileges<'me, 'info>(
    accounts: ResolvePerpBankruptcyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    resolve_perp_bankruptcy_verify_writable_privileges(accounts)?;
    resolve_perp_bankruptcy_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN: usize = 10;
#[derive(Copy, Clone, Debug)]
pub struct ResolveSpotBankruptcyAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub liquidator: &'me AccountInfo<'info>,
    pub liquidator_stats: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ResolveSpotBankruptcyKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
    pub liquidator: Pubkey,
    pub liquidator_stats: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
    pub spot_market_vault: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub token_program: Pubkey,
}
impl From<ResolveSpotBankruptcyAccounts<'_, '_>> for ResolveSpotBankruptcyKeys {
    fn from(accounts: ResolveSpotBankruptcyAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            liquidator: *accounts.liquidator.key,
            liquidator_stats: *accounts.liquidator_stats.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<ResolveSpotBankruptcyKeys>
for [AccountMeta; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN] {
    fn from(keys: ResolveSpotBankruptcyKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.liquidator,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.liquidator_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN]>
for ResolveSpotBankruptcyKeys {
    fn from(pubkeys: [Pubkey; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
            liquidator: pubkeys[2],
            liquidator_stats: pubkeys[3],
            user: pubkeys[4],
            user_stats: pubkeys[5],
            spot_market_vault: pubkeys[6],
            insurance_fund_vault: pubkeys[7],
            drift_signer: pubkeys[8],
            token_program: pubkeys[9],
        }
    }
}
impl<'info> From<ResolveSpotBankruptcyAccounts<'_, 'info>>
for [AccountInfo<'info>; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN] {
    fn from(accounts: ResolveSpotBankruptcyAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.liquidator.clone(),
            accounts.liquidator_stats.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
            accounts.spot_market_vault.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN]>
for ResolveSpotBankruptcyAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
            liquidator: &arr[2],
            liquidator_stats: &arr[3],
            user: &arr[4],
            user_stats: &arr[5],
            spot_market_vault: &arr[6],
            insurance_fund_vault: &arr[7],
            drift_signer: &arr[8],
            token_program: &arr[9],
        }
    }
}
pub const RESOLVE_SPOT_BANKRUPTCY_IX_DISCM: [u8; 8] = [
    124,
    194,
    240,
    254,
    198,
    213,
    52,
    122,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ResolveSpotBankruptcyIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct ResolveSpotBankruptcyIxData(pub ResolveSpotBankruptcyIxArgs);
impl From<ResolveSpotBankruptcyIxArgs> for ResolveSpotBankruptcyIxData {
    fn from(args: ResolveSpotBankruptcyIxArgs) -> Self {
        Self(args)
    }
}
impl ResolveSpotBankruptcyIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != RESOLVE_SPOT_BANKRUPTCY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        RESOLVE_SPOT_BANKRUPTCY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(ResolveSpotBankruptcyIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&RESOLVE_SPOT_BANKRUPTCY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn resolve_spot_bankruptcy_ix_with_program_id(
    program_id: Pubkey,
    keys: ResolveSpotBankruptcyKeys,
    args: ResolveSpotBankruptcyIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; RESOLVE_SPOT_BANKRUPTCY_IX_ACCOUNTS_LEN] = keys.into();
    let data: ResolveSpotBankruptcyIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn resolve_spot_bankruptcy_ix(
    keys: ResolveSpotBankruptcyKeys,
    args: ResolveSpotBankruptcyIxArgs,
) -> std::io::Result<Instruction> {
    resolve_spot_bankruptcy_ix_with_program_id(crate::ID, keys, args)
}
pub fn resolve_spot_bankruptcy_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ResolveSpotBankruptcyAccounts<'_, '_>,
    args: ResolveSpotBankruptcyIxArgs,
) -> ProgramResult {
    let keys: ResolveSpotBankruptcyKeys = accounts.into();
    let ix = resolve_spot_bankruptcy_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn resolve_spot_bankruptcy_invoke(
    accounts: ResolveSpotBankruptcyAccounts<'_, '_>,
    args: ResolveSpotBankruptcyIxArgs,
) -> ProgramResult {
    resolve_spot_bankruptcy_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn resolve_spot_bankruptcy_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ResolveSpotBankruptcyAccounts<'_, '_>,
    args: ResolveSpotBankruptcyIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ResolveSpotBankruptcyKeys = accounts.into();
    let ix = resolve_spot_bankruptcy_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn resolve_spot_bankruptcy_invoke_signed(
    accounts: ResolveSpotBankruptcyAccounts<'_, '_>,
    args: ResolveSpotBankruptcyIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    resolve_spot_bankruptcy_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn resolve_spot_bankruptcy_verify_account_keys(
    accounts: ResolveSpotBankruptcyAccounts<'_, '_>,
    keys: ResolveSpotBankruptcyKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.liquidator.key, keys.liquidator),
        (*accounts.liquidator_stats.key, keys.liquidator_stats),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn resolve_spot_bankruptcy_verify_writable_privileges<'me, 'info>(
    accounts: ResolveSpotBankruptcyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.liquidator,
        accounts.liquidator_stats,
        accounts.user,
        accounts.user_stats,
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn resolve_spot_bankruptcy_verify_signer_privileges<'me, 'info>(
    accounts: ResolveSpotBankruptcyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn resolve_spot_bankruptcy_verify_account_privileges<'me, 'info>(
    accounts: ResolveSpotBankruptcyAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    resolve_spot_bankruptcy_verify_writable_privileges(accounts)?;
    resolve_spot_bankruptcy_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct SettleRevenueToInsuranceFundAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettleRevenueToInsuranceFundKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub spot_market_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub token_program: Pubkey,
}
impl From<SettleRevenueToInsuranceFundAccounts<'_, '_>>
for SettleRevenueToInsuranceFundKeys {
    fn from(accounts: SettleRevenueToInsuranceFundAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            drift_signer: *accounts.drift_signer.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<SettleRevenueToInsuranceFundKeys>
for [AccountMeta; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN] {
    fn from(keys: SettleRevenueToInsuranceFundKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN]>
for SettleRevenueToInsuranceFundKeys {
    fn from(
        pubkeys: [Pubkey; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            spot_market_vault: pubkeys[2],
            drift_signer: pubkeys[3],
            insurance_fund_vault: pubkeys[4],
            token_program: pubkeys[5],
        }
    }
}
impl<'info> From<SettleRevenueToInsuranceFundAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettleRevenueToInsuranceFundAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.spot_market_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN]>
for SettleRevenueToInsuranceFundAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            spot_market_vault: &arr[2],
            drift_signer: &arr[3],
            insurance_fund_vault: &arr[4],
            token_program: &arr[5],
        }
    }
}
pub const SETTLE_REVENUE_TO_INSURANCE_FUND_IX_DISCM: [u8; 8] = [
    200,
    120,
    93,
    136,
    69,
    38,
    199,
    159,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SettleRevenueToInsuranceFundIxArgs {
    pub spot_market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct SettleRevenueToInsuranceFundIxData(pub SettleRevenueToInsuranceFundIxArgs);
impl From<SettleRevenueToInsuranceFundIxArgs> for SettleRevenueToInsuranceFundIxData {
    fn from(args: SettleRevenueToInsuranceFundIxArgs) -> Self {
        Self(args)
    }
}
impl SettleRevenueToInsuranceFundIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_REVENUE_TO_INSURANCE_FUND_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_REVENUE_TO_INSURANCE_FUND_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(SettleRevenueToInsuranceFundIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_REVENUE_TO_INSURANCE_FUND_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_revenue_to_insurance_fund_ix_with_program_id(
    program_id: Pubkey,
    keys: SettleRevenueToInsuranceFundKeys,
    args: SettleRevenueToInsuranceFundIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_REVENUE_TO_INSURANCE_FUND_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: SettleRevenueToInsuranceFundIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn settle_revenue_to_insurance_fund_ix(
    keys: SettleRevenueToInsuranceFundKeys,
    args: SettleRevenueToInsuranceFundIxArgs,
) -> std::io::Result<Instruction> {
    settle_revenue_to_insurance_fund_ix_with_program_id(crate::ID, keys, args)
}
pub fn settle_revenue_to_insurance_fund_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettleRevenueToInsuranceFundAccounts<'_, '_>,
    args: SettleRevenueToInsuranceFundIxArgs,
) -> ProgramResult {
    let keys: SettleRevenueToInsuranceFundKeys = accounts.into();
    let ix = settle_revenue_to_insurance_fund_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_revenue_to_insurance_fund_invoke(
    accounts: SettleRevenueToInsuranceFundAccounts<'_, '_>,
    args: SettleRevenueToInsuranceFundIxArgs,
) -> ProgramResult {
    settle_revenue_to_insurance_fund_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn settle_revenue_to_insurance_fund_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettleRevenueToInsuranceFundAccounts<'_, '_>,
    args: SettleRevenueToInsuranceFundIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettleRevenueToInsuranceFundKeys = accounts.into();
    let ix = settle_revenue_to_insurance_fund_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_revenue_to_insurance_fund_invoke_signed(
    accounts: SettleRevenueToInsuranceFundAccounts<'_, '_>,
    args: SettleRevenueToInsuranceFundIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_revenue_to_insurance_fund_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn settle_revenue_to_insurance_fund_verify_account_keys(
    accounts: SettleRevenueToInsuranceFundAccounts<'_, '_>,
    keys: SettleRevenueToInsuranceFundKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_revenue_to_insurance_fund_verify_writable_privileges<'me, 'info>(
    accounts: SettleRevenueToInsuranceFundAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_revenue_to_insurance_fund_verify_account_privileges<'me, 'info>(
    accounts: SettleRevenueToInsuranceFundAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_revenue_to_insurance_fund_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateFundingRateAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateFundingRateKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
}
impl From<UpdateFundingRateAccounts<'_, '_>> for UpdateFundingRateKeys {
    fn from(accounts: UpdateFundingRateAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
        }
    }
}
impl From<UpdateFundingRateKeys> for [AccountMeta; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateFundingRateKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN]> for UpdateFundingRateKeys {
    fn from(pubkeys: [Pubkey; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateFundingRateAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateFundingRateAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.perp_market.clone(), accounts.oracle.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN]>
for UpdateFundingRateAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
        }
    }
}
pub const UPDATE_FUNDING_RATE_IX_DISCM: [u8; 8] = [
    201,
    178,
    116,
    212,
    166,
    144,
    72,
    238,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateFundingRateIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateFundingRateIxData(pub UpdateFundingRateIxArgs);
impl From<UpdateFundingRateIxArgs> for UpdateFundingRateIxData {
    fn from(args: UpdateFundingRateIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateFundingRateIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_FUNDING_RATE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_FUNDING_RATE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateFundingRateIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_FUNDING_RATE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_funding_rate_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateFundingRateKeys,
    args: UpdateFundingRateIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_FUNDING_RATE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateFundingRateIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_funding_rate_ix(
    keys: UpdateFundingRateKeys,
    args: UpdateFundingRateIxArgs,
) -> std::io::Result<Instruction> {
    update_funding_rate_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_funding_rate_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateFundingRateAccounts<'_, '_>,
    args: UpdateFundingRateIxArgs,
) -> ProgramResult {
    let keys: UpdateFundingRateKeys = accounts.into();
    let ix = update_funding_rate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_funding_rate_invoke(
    accounts: UpdateFundingRateAccounts<'_, '_>,
    args: UpdateFundingRateIxArgs,
) -> ProgramResult {
    update_funding_rate_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_funding_rate_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateFundingRateAccounts<'_, '_>,
    args: UpdateFundingRateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateFundingRateKeys = accounts.into();
    let ix = update_funding_rate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_funding_rate_invoke_signed(
    accounts: UpdateFundingRateAccounts<'_, '_>,
    args: UpdateFundingRateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_funding_rate_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_funding_rate_verify_account_keys(
    accounts: UpdateFundingRateAccounts<'_, '_>,
    keys: UpdateFundingRateKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_funding_rate_verify_writable_privileges<'me, 'info>(
    accounts: UpdateFundingRateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_funding_rate_verify_account_privileges<'me, 'info>(
    accounts: UpdateFundingRateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_funding_rate_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePrelaunchOracleAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePrelaunchOracleKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
}
impl From<UpdatePrelaunchOracleAccounts<'_, '_>> for UpdatePrelaunchOracleKeys {
    fn from(accounts: UpdatePrelaunchOracleAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
        }
    }
}
impl From<UpdatePrelaunchOracleKeys>
for [AccountMeta; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePrelaunchOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]>
for UpdatePrelaunchOracleKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePrelaunchOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePrelaunchOracleAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.perp_market.clone(), accounts.oracle.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]>
for UpdatePrelaunchOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
        }
    }
}
pub const UPDATE_PRELAUNCH_ORACLE_IX_DISCM: [u8; 8] = [
    220,
    132,
    27,
    27,
    233,
    220,
    61,
    219,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePrelaunchOracleIxData;
impl UpdatePrelaunchOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PRELAUNCH_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PRELAUNCH_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PRELAUNCH_ORACLE_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_prelaunch_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePrelaunchOracleKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdatePrelaunchOracleIxData.try_to_vec()?,
    })
}
pub fn update_prelaunch_oracle_ix(
    keys: UpdatePrelaunchOracleKeys,
) -> std::io::Result<Instruction> {
    update_prelaunch_oracle_ix_with_program_id(crate::ID, keys)
}
pub fn update_prelaunch_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePrelaunchOracleAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdatePrelaunchOracleKeys = accounts.into();
    let ix = update_prelaunch_oracle_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_prelaunch_oracle_invoke(
    accounts: UpdatePrelaunchOracleAccounts<'_, '_>,
) -> ProgramResult {
    update_prelaunch_oracle_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_prelaunch_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePrelaunchOracleAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePrelaunchOracleKeys = accounts.into();
    let ix = update_prelaunch_oracle_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_prelaunch_oracle_invoke_signed(
    accounts: UpdatePrelaunchOracleAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_prelaunch_oracle_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn update_prelaunch_oracle_verify_account_keys(
    accounts: UpdatePrelaunchOracleAccounts<'_, '_>,
    keys: UpdatePrelaunchOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_prelaunch_oracle_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.oracle] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_prelaunch_oracle_verify_account_privileges<'me, 'info>(
    accounts: UpdatePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_prelaunch_oracle_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpBidAskTwapAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub keeper_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpBidAskTwapKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
    pub keeper_stats: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdatePerpBidAskTwapAccounts<'_, '_>> for UpdatePerpBidAskTwapKeys {
    fn from(accounts: UpdatePerpBidAskTwapAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
            keeper_stats: *accounts.keeper_stats.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdatePerpBidAskTwapKeys>
for [AccountMeta; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpBidAskTwapKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.keeper_stats,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN]>
for UpdatePerpBidAskTwapKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
            keeper_stats: pubkeys[3],
            authority: pubkeys[4],
        }
    }
}
impl<'info> From<UpdatePerpBidAskTwapAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpBidAskTwapAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
            accounts.keeper_stats.clone(),
            accounts.authority.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN]>
for UpdatePerpBidAskTwapAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
            keeper_stats: &arr[3],
            authority: &arr[4],
        }
    }
}
pub const UPDATE_PERP_BID_ASK_TWAP_IX_DISCM: [u8; 8] = [
    247,
    23,
    255,
    65,
    212,
    90,
    221,
    194,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpBidAskTwapIxData;
impl UpdatePerpBidAskTwapIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_BID_ASK_TWAP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_BID_ASK_TWAP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_BID_ASK_TWAP_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_bid_ask_twap_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpBidAskTwapKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_BID_ASK_TWAP_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdatePerpBidAskTwapIxData.try_to_vec()?,
    })
}
pub fn update_perp_bid_ask_twap_ix(
    keys: UpdatePerpBidAskTwapKeys,
) -> std::io::Result<Instruction> {
    update_perp_bid_ask_twap_ix_with_program_id(crate::ID, keys)
}
pub fn update_perp_bid_ask_twap_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpBidAskTwapAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdatePerpBidAskTwapKeys = accounts.into();
    let ix = update_perp_bid_ask_twap_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_bid_ask_twap_invoke(
    accounts: UpdatePerpBidAskTwapAccounts<'_, '_>,
) -> ProgramResult {
    update_perp_bid_ask_twap_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_perp_bid_ask_twap_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpBidAskTwapAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpBidAskTwapKeys = accounts.into();
    let ix = update_perp_bid_ask_twap_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_bid_ask_twap_invoke_signed(
    accounts: UpdatePerpBidAskTwapAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_bid_ask_twap_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn update_perp_bid_ask_twap_verify_account_keys(
    accounts: UpdatePerpBidAskTwapAccounts<'_, '_>,
    keys: UpdatePerpBidAskTwapKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.keeper_stats.key, keys.keeper_stats),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_bid_ask_twap_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpBidAskTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_bid_ask_twap_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpBidAskTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_bid_ask_twap_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpBidAskTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_bid_ask_twap_verify_writable_privileges(accounts)?;
    update_perp_bid_ask_twap_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketCumulativeInterestAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketCumulativeInterestKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub oracle: Pubkey,
    pub spot_market_vault: Pubkey,
}
impl From<UpdateSpotMarketCumulativeInterestAccounts<'_, '_>>
for UpdateSpotMarketCumulativeInterestKeys {
    fn from(accounts: UpdateSpotMarketCumulativeInterestAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            oracle: *accounts.oracle.key,
            spot_market_vault: *accounts.spot_market_vault.key,
        }
    }
}
impl From<UpdateSpotMarketCumulativeInterestKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketCumulativeInterestKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketCumulativeInterestKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            oracle: pubkeys[2],
            spot_market_vault: pubkeys[3],
        }
    }
}
impl<'info> From<UpdateSpotMarketCumulativeInterestAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketCumulativeInterestAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.oracle.clone(),
            accounts.spot_market_vault.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketCumulativeInterestAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            oracle: &arr[2],
            spot_market_vault: &arr[3],
        }
    }
}
pub const UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_DISCM: [u8; 8] = [
    39,
    166,
    139,
    243,
    158,
    165,
    155,
    225,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketCumulativeInterestIxData;
impl UpdateSpotMarketCumulativeInterestIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_cumulative_interest_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketCumulativeInterestKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_CUMULATIVE_INTEREST_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateSpotMarketCumulativeInterestIxData.try_to_vec()?,
    })
}
pub fn update_spot_market_cumulative_interest_ix(
    keys: UpdateSpotMarketCumulativeInterestKeys,
) -> std::io::Result<Instruction> {
    update_spot_market_cumulative_interest_ix_with_program_id(crate::ID, keys)
}
pub fn update_spot_market_cumulative_interest_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateSpotMarketCumulativeInterestKeys = accounts.into();
    let ix = update_spot_market_cumulative_interest_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_cumulative_interest_invoke(
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'_, '_>,
) -> ProgramResult {
    update_spot_market_cumulative_interest_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_spot_market_cumulative_interest_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketCumulativeInterestKeys = accounts.into();
    let ix = update_spot_market_cumulative_interest_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_cumulative_interest_invoke_signed(
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_cumulative_interest_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn update_spot_market_cumulative_interest_verify_account_keys(
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'_, '_>,
    keys: UpdateSpotMarketCumulativeInterestKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_cumulative_interest_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_cumulative_interest_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketCumulativeInterestAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_cumulative_interest_verify_writable_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_AMMS_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateAmmsAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateAmmsKeys {
    pub state: Pubkey,
    pub authority: Pubkey,
}
impl From<UpdateAmmsAccounts<'_, '_>> for UpdateAmmsKeys {
    fn from(accounts: UpdateAmmsAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            authority: *accounts.authority.key,
        }
    }
}
impl From<UpdateAmmsKeys> for [AccountMeta; UPDATE_AMMS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateAmmsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_AMMS_IX_ACCOUNTS_LEN]> for UpdateAmmsKeys {
    fn from(pubkeys: [Pubkey; UPDATE_AMMS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            authority: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateAmmsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_AMMS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateAmmsAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.authority.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_AMMS_IX_ACCOUNTS_LEN]>
for UpdateAmmsAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; UPDATE_AMMS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            authority: &arr[1],
        }
    }
}
pub const UPDATE_AMMS_IX_DISCM: [u8; 8] = [201, 106, 217, 253, 4, 175, 228, 97];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateAmmsIxArgs {
    pub market_indexes: [u16; 5],
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateAmmsIxData(pub UpdateAmmsIxArgs);
impl From<UpdateAmmsIxArgs> for UpdateAmmsIxData {
    fn from(args: UpdateAmmsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateAmmsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_AMMS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_AMMS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateAmmsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_AMMS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_amms_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateAmmsKeys,
    args: UpdateAmmsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_AMMS_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateAmmsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_amms_ix(
    keys: UpdateAmmsKeys,
    args: UpdateAmmsIxArgs,
) -> std::io::Result<Instruction> {
    update_amms_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_amms_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateAmmsAccounts<'_, '_>,
    args: UpdateAmmsIxArgs,
) -> ProgramResult {
    let keys: UpdateAmmsKeys = accounts.into();
    let ix = update_amms_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_amms_invoke(
    accounts: UpdateAmmsAccounts<'_, '_>,
    args: UpdateAmmsIxArgs,
) -> ProgramResult {
    update_amms_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_amms_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateAmmsAccounts<'_, '_>,
    args: UpdateAmmsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateAmmsKeys = accounts.into();
    let ix = update_amms_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_amms_invoke_signed(
    accounts: UpdateAmmsAccounts<'_, '_>,
    args: UpdateAmmsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_amms_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_amms_verify_account_keys(
    accounts: UpdateAmmsAccounts<'_, '_>,
    keys: UpdateAmmsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_amms_verify_signer_privileges<'me, 'info>(
    accounts: UpdateAmmsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_amms_verify_account_privileges<'me, 'info>(
    accounts: UpdateAmmsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_amms_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketExpiryAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketExpiryKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketExpiryAccounts<'_, '_>> for UpdateSpotMarketExpiryKeys {
    fn from(accounts: UpdateSpotMarketExpiryAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketExpiryKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketExpiryKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketExpiryKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketExpiryAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketExpiryAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketExpiryAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_EXPIRY_IX_DISCM: [u8; 8] = [
    208,
    11,
    211,
    159,
    226,
    24,
    11,
    247,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketExpiryIxArgs {
    pub expiry_ts: i64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketExpiryIxData(pub UpdateSpotMarketExpiryIxArgs);
impl From<UpdateSpotMarketExpiryIxArgs> for UpdateSpotMarketExpiryIxData {
    fn from(args: UpdateSpotMarketExpiryIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketExpiryIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_EXPIRY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_EXPIRY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketExpiryIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_EXPIRY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_expiry_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketExpiryKeys,
    args: UpdateSpotMarketExpiryIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_EXPIRY_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotMarketExpiryIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_expiry_ix(
    keys: UpdateSpotMarketExpiryKeys,
    args: UpdateSpotMarketExpiryIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_expiry_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_expiry_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketExpiryAccounts<'_, '_>,
    args: UpdateSpotMarketExpiryIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketExpiryKeys = accounts.into();
    let ix = update_spot_market_expiry_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_expiry_invoke(
    accounts: UpdateSpotMarketExpiryAccounts<'_, '_>,
    args: UpdateSpotMarketExpiryIxArgs,
) -> ProgramResult {
    update_spot_market_expiry_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_expiry_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketExpiryAccounts<'_, '_>,
    args: UpdateSpotMarketExpiryIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketExpiryKeys = accounts.into();
    let ix = update_spot_market_expiry_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_expiry_invoke_signed(
    accounts: UpdateSpotMarketExpiryAccounts<'_, '_>,
    args: UpdateSpotMarketExpiryIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_expiry_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_expiry_verify_account_keys(
    accounts: UpdateSpotMarketExpiryAccounts<'_, '_>,
    keys: UpdateSpotMarketExpiryKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_expiry_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketExpiryAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_expiry_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketExpiryAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_expiry_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketExpiryAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_expiry_verify_writable_privileges(accounts)?;
    update_spot_market_expiry_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserQuoteAssetInsuranceStakeAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub signer: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserQuoteAssetInsuranceStakeKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub signer: Pubkey,
    pub insurance_fund_vault: Pubkey,
}
impl From<UpdateUserQuoteAssetInsuranceStakeAccounts<'_, '_>>
for UpdateUserQuoteAssetInsuranceStakeKeys {
    fn from(accounts: UpdateUserQuoteAssetInsuranceStakeAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            signer: *accounts.signer.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
        }
    }
}
impl From<UpdateUserQuoteAssetInsuranceStakeKeys>
for [AccountMeta; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserQuoteAssetInsuranceStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.signer,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN]>
for UpdateUserQuoteAssetInsuranceStakeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            insurance_fund_stake: pubkeys[2],
            user_stats: pubkeys[3],
            signer: pubkeys[4],
            insurance_fund_vault: pubkeys[5],
        }
    }
}
impl<'info> From<UpdateUserQuoteAssetInsuranceStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.signer.clone(),
            accounts.insurance_fund_vault.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN],
> for UpdateUserQuoteAssetInsuranceStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            insurance_fund_stake: &arr[2],
            user_stats: &arr[3],
            signer: &arr[4],
            insurance_fund_vault: &arr[5],
        }
    }
}
pub const UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_DISCM: [u8; 8] = [
    251,
    101,
    156,
    7,
    2,
    63,
    30,
    23,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserQuoteAssetInsuranceStakeIxData;
impl UpdateUserQuoteAssetInsuranceStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_quote_asset_insurance_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserQuoteAssetInsuranceStakeKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_QUOTE_ASSET_INSURANCE_STAKE_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateUserQuoteAssetInsuranceStakeIxData.try_to_vec()?,
    })
}
pub fn update_user_quote_asset_insurance_stake_ix(
    keys: UpdateUserQuoteAssetInsuranceStakeKeys,
) -> std::io::Result<Instruction> {
    update_user_quote_asset_insurance_stake_ix_with_program_id(crate::ID, keys)
}
pub fn update_user_quote_asset_insurance_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateUserQuoteAssetInsuranceStakeKeys = accounts.into();
    let ix = update_user_quote_asset_insurance_stake_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_quote_asset_insurance_stake_invoke(
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'_, '_>,
) -> ProgramResult {
    update_user_quote_asset_insurance_stake_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_user_quote_asset_insurance_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserQuoteAssetInsuranceStakeKeys = accounts.into();
    let ix = update_user_quote_asset_insurance_stake_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_quote_asset_insurance_stake_invoke_signed(
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_quote_asset_insurance_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn update_user_quote_asset_insurance_stake_verify_account_keys(
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'_, '_>,
    keys: UpdateUserQuoteAssetInsuranceStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.signer.key, keys.signer),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_quote_asset_insurance_stake_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_quote_asset_insurance_stake_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.signer] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_quote_asset_insurance_stake_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserQuoteAssetInsuranceStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_quote_asset_insurance_stake_verify_writable_privileges(accounts)?;
    update_user_quote_asset_insurance_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct UpdateUserGovTokenInsuranceStakeAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub signer: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateUserGovTokenInsuranceStakeKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub signer: Pubkey,
    pub insurance_fund_vault: Pubkey,
}
impl From<UpdateUserGovTokenInsuranceStakeAccounts<'_, '_>>
for UpdateUserGovTokenInsuranceStakeKeys {
    fn from(accounts: UpdateUserGovTokenInsuranceStakeAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            signer: *accounts.signer.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
        }
    }
}
impl From<UpdateUserGovTokenInsuranceStakeKeys>
for [AccountMeta; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateUserGovTokenInsuranceStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.signer,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN]>
for UpdateUserGovTokenInsuranceStakeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            insurance_fund_stake: pubkeys[2],
            user_stats: pubkeys[3],
            signer: pubkeys[4],
            insurance_fund_vault: pubkeys[5],
        }
    }
}
impl<'info> From<UpdateUserGovTokenInsuranceStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateUserGovTokenInsuranceStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.signer.clone(),
            accounts.insurance_fund_vault.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN]>
for UpdateUserGovTokenInsuranceStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            insurance_fund_stake: &arr[2],
            user_stats: &arr[3],
            signer: &arr[4],
            insurance_fund_vault: &arr[5],
        }
    }
}
pub const UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_DISCM: [u8; 8] = [
    143,
    99,
    235,
    187,
    20,
    159,
    184,
    84,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateUserGovTokenInsuranceStakeIxData;
impl UpdateUserGovTokenInsuranceStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_user_gov_token_insurance_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateUserGovTokenInsuranceStakeKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_USER_GOV_TOKEN_INSURANCE_STAKE_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateUserGovTokenInsuranceStakeIxData.try_to_vec()?,
    })
}
pub fn update_user_gov_token_insurance_stake_ix(
    keys: UpdateUserGovTokenInsuranceStakeKeys,
) -> std::io::Result<Instruction> {
    update_user_gov_token_insurance_stake_ix_with_program_id(crate::ID, keys)
}
pub fn update_user_gov_token_insurance_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateUserGovTokenInsuranceStakeKeys = accounts.into();
    let ix = update_user_gov_token_insurance_stake_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_user_gov_token_insurance_stake_invoke(
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'_, '_>,
) -> ProgramResult {
    update_user_gov_token_insurance_stake_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_user_gov_token_insurance_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateUserGovTokenInsuranceStakeKeys = accounts.into();
    let ix = update_user_gov_token_insurance_stake_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_user_gov_token_insurance_stake_invoke_signed(
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_user_gov_token_insurance_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn update_user_gov_token_insurance_stake_verify_account_keys(
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'_, '_>,
    keys: UpdateUserGovTokenInsuranceStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.signer.key, keys.signer),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_user_gov_token_insurance_stake_verify_writable_privileges<'me, 'info>(
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_user_gov_token_insurance_stake_verify_signer_privileges<'me, 'info>(
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.signer] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_user_gov_token_insurance_stake_verify_account_privileges<'me, 'info>(
    accounts: UpdateUserGovTokenInsuranceStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_user_gov_token_insurance_stake_verify_writable_privileges(accounts)?;
    update_user_gov_token_insurance_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN: usize = 8;
#[derive(Copy, Clone, Debug)]
pub struct InitializeInsuranceFundStakeAccounts<'me, 'info> {
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub payer: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeInsuranceFundStakeKeys {
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub state: Pubkey,
    pub authority: Pubkey,
    pub payer: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeInsuranceFundStakeAccounts<'_, '_>>
for InitializeInsuranceFundStakeKeys {
    fn from(accounts: InitializeInsuranceFundStakeAccounts) -> Self {
        Self {
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            state: *accounts.state.key,
            authority: *accounts.authority.key,
            payer: *accounts.payer.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeInsuranceFundStakeKeys>
for [AccountMeta; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeInsuranceFundStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.payer,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for InitializeInsuranceFundStakeKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            spot_market: pubkeys[0],
            insurance_fund_stake: pubkeys[1],
            user_stats: pubkeys[2],
            state: pubkeys[3],
            authority: pubkeys[4],
            payer: pubkeys[5],
            rent: pubkeys[6],
            system_program: pubkeys[7],
        }
    }
}
impl<'info> From<InitializeInsuranceFundStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeInsuranceFundStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.state.clone(),
            accounts.authority.clone(),
            accounts.payer.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for InitializeInsuranceFundStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            spot_market: &arr[0],
            insurance_fund_stake: &arr[1],
            user_stats: &arr[2],
            state: &arr[3],
            authority: &arr[4],
            payer: &arr[5],
            rent: &arr[6],
            system_program: &arr[7],
        }
    }
}
pub const INITIALIZE_INSURANCE_FUND_STAKE_IX_DISCM: [u8; 8] = [
    187,
    179,
    243,
    70,
    248,
    90,
    92,
    147,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeInsuranceFundStakeIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeInsuranceFundStakeIxData(pub InitializeInsuranceFundStakeIxArgs);
impl From<InitializeInsuranceFundStakeIxArgs> for InitializeInsuranceFundStakeIxData {
    fn from(args: InitializeInsuranceFundStakeIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeInsuranceFundStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_INSURANCE_FUND_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_INSURANCE_FUND_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeInsuranceFundStakeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_INSURANCE_FUND_STAKE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_insurance_fund_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeInsuranceFundStakeKeys,
    args: InitializeInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: InitializeInsuranceFundStakeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_insurance_fund_stake_ix(
    keys: InitializeInsuranceFundStakeKeys,
    args: InitializeInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    initialize_insurance_fund_stake_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_insurance_fund_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeInsuranceFundStakeAccounts<'_, '_>,
    args: InitializeInsuranceFundStakeIxArgs,
) -> ProgramResult {
    let keys: InitializeInsuranceFundStakeKeys = accounts.into();
    let ix = initialize_insurance_fund_stake_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_insurance_fund_stake_invoke(
    accounts: InitializeInsuranceFundStakeAccounts<'_, '_>,
    args: InitializeInsuranceFundStakeIxArgs,
) -> ProgramResult {
    initialize_insurance_fund_stake_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_insurance_fund_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeInsuranceFundStakeAccounts<'_, '_>,
    args: InitializeInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeInsuranceFundStakeKeys = accounts.into();
    let ix = initialize_insurance_fund_stake_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_insurance_fund_stake_invoke_signed(
    accounts: InitializeInsuranceFundStakeAccounts<'_, '_>,
    args: InitializeInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_insurance_fund_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_insurance_fund_stake_verify_account_keys(
    accounts: InitializeInsuranceFundStakeAccounts<'_, '_>,
    keys: InitializeInsuranceFundStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.state.key, keys.state),
        (*accounts.authority.key, keys.authority),
        (*accounts.payer.key, keys.payer),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_insurance_fund_stake_verify_writable_privileges<'me, 'info>(
    accounts: InitializeInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.payer,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_insurance_fund_stake_verify_signer_privileges<'me, 'info>(
    accounts: InitializeInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority, accounts.payer] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_insurance_fund_stake_verify_account_privileges<'me, 'info>(
    accounts: InitializeInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_insurance_fund_stake_verify_writable_privileges(accounts)?;
    initialize_insurance_fund_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN: usize = 10;
#[derive(Copy, Clone, Debug)]
pub struct AddInsuranceFundStakeAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub user_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct AddInsuranceFundStakeKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub user_token_account: Pubkey,
    pub token_program: Pubkey,
}
impl From<AddInsuranceFundStakeAccounts<'_, '_>> for AddInsuranceFundStakeKeys {
    fn from(accounts: AddInsuranceFundStakeAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            user_token_account: *accounts.user_token_account.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<AddInsuranceFundStakeKeys>
for [AccountMeta; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: AddInsuranceFundStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for AddInsuranceFundStakeKeys {
    fn from(pubkeys: [Pubkey; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            insurance_fund_stake: pubkeys[2],
            user_stats: pubkeys[3],
            authority: pubkeys[4],
            spot_market_vault: pubkeys[5],
            insurance_fund_vault: pubkeys[6],
            drift_signer: pubkeys[7],
            user_token_account: pubkeys[8],
            token_program: pubkeys[9],
        }
    }
}
impl<'info> From<AddInsuranceFundStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: AddInsuranceFundStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.user_token_account.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for AddInsuranceFundStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            insurance_fund_stake: &arr[2],
            user_stats: &arr[3],
            authority: &arr[4],
            spot_market_vault: &arr[5],
            insurance_fund_vault: &arr[6],
            drift_signer: &arr[7],
            user_token_account: &arr[8],
            token_program: &arr[9],
        }
    }
}
pub const ADD_INSURANCE_FUND_STAKE_IX_DISCM: [u8; 8] = [
    251,
    144,
    115,
    11,
    222,
    47,
    62,
    236,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AddInsuranceFundStakeIxArgs {
    pub market_index: u16,
    pub amount: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct AddInsuranceFundStakeIxData(pub AddInsuranceFundStakeIxArgs);
impl From<AddInsuranceFundStakeIxArgs> for AddInsuranceFundStakeIxData {
    fn from(args: AddInsuranceFundStakeIxArgs) -> Self {
        Self(args)
    }
}
impl AddInsuranceFundStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != ADD_INSURANCE_FUND_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        ADD_INSURANCE_FUND_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(AddInsuranceFundStakeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&ADD_INSURANCE_FUND_STAKE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn add_insurance_fund_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: AddInsuranceFundStakeKeys,
    args: AddInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; ADD_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] = keys.into();
    let data: AddInsuranceFundStakeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn add_insurance_fund_stake_ix(
    keys: AddInsuranceFundStakeKeys,
    args: AddInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    add_insurance_fund_stake_ix_with_program_id(crate::ID, keys, args)
}
pub fn add_insurance_fund_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: AddInsuranceFundStakeAccounts<'_, '_>,
    args: AddInsuranceFundStakeIxArgs,
) -> ProgramResult {
    let keys: AddInsuranceFundStakeKeys = accounts.into();
    let ix = add_insurance_fund_stake_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn add_insurance_fund_stake_invoke(
    accounts: AddInsuranceFundStakeAccounts<'_, '_>,
    args: AddInsuranceFundStakeIxArgs,
) -> ProgramResult {
    add_insurance_fund_stake_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn add_insurance_fund_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: AddInsuranceFundStakeAccounts<'_, '_>,
    args: AddInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: AddInsuranceFundStakeKeys = accounts.into();
    let ix = add_insurance_fund_stake_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn add_insurance_fund_stake_invoke_signed(
    accounts: AddInsuranceFundStakeAccounts<'_, '_>,
    args: AddInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    add_insurance_fund_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn add_insurance_fund_stake_verify_account_keys(
    accounts: AddInsuranceFundStakeAccounts<'_, '_>,
    keys: AddInsuranceFundStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.user_token_account.key, keys.user_token_account),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn add_insurance_fund_stake_verify_writable_privileges<'me, 'info>(
    accounts: AddInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
        accounts.user_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn add_insurance_fund_stake_verify_signer_privileges<'me, 'info>(
    accounts: AddInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn add_insurance_fund_stake_verify_account_privileges<'me, 'info>(
    accounts: AddInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    add_insurance_fund_stake_verify_writable_privileges(accounts)?;
    add_insurance_fund_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct RequestRemoveInsuranceFundStakeAccounts<'me, 'info> {
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RequestRemoveInsuranceFundStakeKeys {
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub insurance_fund_vault: Pubkey,
}
impl From<RequestRemoveInsuranceFundStakeAccounts<'_, '_>>
for RequestRemoveInsuranceFundStakeKeys {
    fn from(accounts: RequestRemoveInsuranceFundStakeAccounts) -> Self {
        Self {
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
        }
    }
}
impl From<RequestRemoveInsuranceFundStakeKeys>
for [AccountMeta; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: RequestRemoveInsuranceFundStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for RequestRemoveInsuranceFundStakeKeys {
    fn from(
        pubkeys: [Pubkey; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            spot_market: pubkeys[0],
            insurance_fund_stake: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            insurance_fund_vault: pubkeys[4],
        }
    }
}
impl<'info> From<RequestRemoveInsuranceFundStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: RequestRemoveInsuranceFundStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.insurance_fund_vault.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for RequestRemoveInsuranceFundStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            spot_market: &arr[0],
            insurance_fund_stake: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            insurance_fund_vault: &arr[4],
        }
    }
}
pub const REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM: [u8; 8] = [
    142,
    70,
    204,
    92,
    73,
    106,
    180,
    52,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RequestRemoveInsuranceFundStakeIxArgs {
    pub market_index: u16,
    pub amount: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct RequestRemoveInsuranceFundStakeIxData(
    pub RequestRemoveInsuranceFundStakeIxArgs,
);
impl From<RequestRemoveInsuranceFundStakeIxArgs>
for RequestRemoveInsuranceFundStakeIxData {
    fn from(args: RequestRemoveInsuranceFundStakeIxArgs) -> Self {
        Self(args)
    }
}
impl RequestRemoveInsuranceFundStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(RequestRemoveInsuranceFundStakeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn request_remove_insurance_fund_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: RequestRemoveInsuranceFundStakeKeys,
    args: RequestRemoveInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: RequestRemoveInsuranceFundStakeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn request_remove_insurance_fund_stake_ix(
    keys: RequestRemoveInsuranceFundStakeKeys,
    args: RequestRemoveInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    request_remove_insurance_fund_stake_ix_with_program_id(crate::ID, keys, args)
}
pub fn request_remove_insurance_fund_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RequestRemoveInsuranceFundStakeIxArgs,
) -> ProgramResult {
    let keys: RequestRemoveInsuranceFundStakeKeys = accounts.into();
    let ix = request_remove_insurance_fund_stake_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn request_remove_insurance_fund_stake_invoke(
    accounts: RequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RequestRemoveInsuranceFundStakeIxArgs,
) -> ProgramResult {
    request_remove_insurance_fund_stake_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn request_remove_insurance_fund_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RequestRemoveInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RequestRemoveInsuranceFundStakeKeys = accounts.into();
    let ix = request_remove_insurance_fund_stake_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn request_remove_insurance_fund_stake_invoke_signed(
    accounts: RequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RequestRemoveInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    request_remove_insurance_fund_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn request_remove_insurance_fund_stake_verify_account_keys(
    accounts: RequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    keys: RequestRemoveInsuranceFundStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn request_remove_insurance_fund_stake_verify_writable_privileges<'me, 'info>(
    accounts: RequestRemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn request_remove_insurance_fund_stake_verify_signer_privileges<'me, 'info>(
    accounts: RequestRemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn request_remove_insurance_fund_stake_verify_account_privileges<'me, 'info>(
    accounts: RequestRemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    request_remove_insurance_fund_stake_verify_writable_privileges(accounts)?;
    request_remove_insurance_fund_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct CancelRequestRemoveInsuranceFundStakeAccounts<'me, 'info> {
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct CancelRequestRemoveInsuranceFundStakeKeys {
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub insurance_fund_vault: Pubkey,
}
impl From<CancelRequestRemoveInsuranceFundStakeAccounts<'_, '_>>
for CancelRequestRemoveInsuranceFundStakeKeys {
    fn from(accounts: CancelRequestRemoveInsuranceFundStakeAccounts) -> Self {
        Self {
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
        }
    }
}
impl From<CancelRequestRemoveInsuranceFundStakeKeys>
for [AccountMeta; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: CancelRequestRemoveInsuranceFundStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for CancelRequestRemoveInsuranceFundStakeKeys {
    fn from(
        pubkeys: [Pubkey; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            spot_market: pubkeys[0],
            insurance_fund_stake: pubkeys[1],
            user_stats: pubkeys[2],
            authority: pubkeys[3],
            insurance_fund_vault: pubkeys[4],
        }
    }
}
impl<'info> From<CancelRequestRemoveInsuranceFundStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.insurance_fund_vault.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
> for CancelRequestRemoveInsuranceFundStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            spot_market: &arr[0],
            insurance_fund_stake: &arr[1],
            user_stats: &arr[2],
            authority: &arr[3],
            insurance_fund_vault: &arr[4],
        }
    }
}
pub const CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM: [u8; 8] = [
    97,
    235,
    78,
    62,
    212,
    42,
    241,
    127,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CancelRequestRemoveInsuranceFundStakeIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct CancelRequestRemoveInsuranceFundStakeIxData(
    pub CancelRequestRemoveInsuranceFundStakeIxArgs,
);
impl From<CancelRequestRemoveInsuranceFundStakeIxArgs>
for CancelRequestRemoveInsuranceFundStakeIxData {
    fn from(args: CancelRequestRemoveInsuranceFundStakeIxArgs) -> Self {
        Self(args)
    }
}
impl CancelRequestRemoveInsuranceFundStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(CancelRequestRemoveInsuranceFundStakeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn cancel_request_remove_insurance_fund_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: CancelRequestRemoveInsuranceFundStakeKeys,
    args: CancelRequestRemoveInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; CANCEL_REQUEST_REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: CancelRequestRemoveInsuranceFundStakeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn cancel_request_remove_insurance_fund_stake_ix(
    keys: CancelRequestRemoveInsuranceFundStakeKeys,
    args: CancelRequestRemoveInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    cancel_request_remove_insurance_fund_stake_ix_with_program_id(crate::ID, keys, args)
}
pub fn cancel_request_remove_insurance_fund_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: CancelRequestRemoveInsuranceFundStakeIxArgs,
) -> ProgramResult {
    let keys: CancelRequestRemoveInsuranceFundStakeKeys = accounts.into();
    let ix = cancel_request_remove_insurance_fund_stake_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn cancel_request_remove_insurance_fund_stake_invoke(
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: CancelRequestRemoveInsuranceFundStakeIxArgs,
) -> ProgramResult {
    cancel_request_remove_insurance_fund_stake_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn cancel_request_remove_insurance_fund_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: CancelRequestRemoveInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: CancelRequestRemoveInsuranceFundStakeKeys = accounts.into();
    let ix = cancel_request_remove_insurance_fund_stake_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn cancel_request_remove_insurance_fund_stake_invoke_signed(
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    args: CancelRequestRemoveInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    cancel_request_remove_insurance_fund_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn cancel_request_remove_insurance_fund_stake_verify_account_keys(
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'_, '_>,
    keys: CancelRequestRemoveInsuranceFundStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn cancel_request_remove_insurance_fund_stake_verify_writable_privileges<'me, 'info>(
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn cancel_request_remove_insurance_fund_stake_verify_signer_privileges<'me, 'info>(
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn cancel_request_remove_insurance_fund_stake_verify_account_privileges<'me, 'info>(
    accounts: CancelRequestRemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    cancel_request_remove_insurance_fund_stake_verify_writable_privileges(accounts)?;
    cancel_request_remove_insurance_fund_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN: usize = 9;
#[derive(Copy, Clone, Debug)]
pub struct RemoveInsuranceFundStakeAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub user_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RemoveInsuranceFundStakeKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub user_token_account: Pubkey,
    pub token_program: Pubkey,
}
impl From<RemoveInsuranceFundStakeAccounts<'_, '_>> for RemoveInsuranceFundStakeKeys {
    fn from(accounts: RemoveInsuranceFundStakeAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            user_token_account: *accounts.user_token_account.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<RemoveInsuranceFundStakeKeys>
for [AccountMeta; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(keys: RemoveInsuranceFundStakeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for RemoveInsuranceFundStakeKeys {
    fn from(pubkeys: [Pubkey; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            insurance_fund_stake: pubkeys[2],
            user_stats: pubkeys[3],
            authority: pubkeys[4],
            insurance_fund_vault: pubkeys[5],
            drift_signer: pubkeys[6],
            user_token_account: pubkeys[7],
            token_program: pubkeys[8],
        }
    }
}
impl<'info> From<RemoveInsuranceFundStakeAccounts<'_, 'info>>
for [AccountInfo<'info>; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] {
    fn from(accounts: RemoveInsuranceFundStakeAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.user_token_account.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN]>
for RemoveInsuranceFundStakeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            insurance_fund_stake: &arr[2],
            user_stats: &arr[3],
            authority: &arr[4],
            insurance_fund_vault: &arr[5],
            drift_signer: &arr[6],
            user_token_account: &arr[7],
            token_program: &arr[8],
        }
    }
}
pub const REMOVE_INSURANCE_FUND_STAKE_IX_DISCM: [u8; 8] = [
    128,
    166,
    142,
    9,
    254,
    187,
    143,
    174,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RemoveInsuranceFundStakeIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct RemoveInsuranceFundStakeIxData(pub RemoveInsuranceFundStakeIxArgs);
impl From<RemoveInsuranceFundStakeIxArgs> for RemoveInsuranceFundStakeIxData {
    fn from(args: RemoveInsuranceFundStakeIxArgs) -> Self {
        Self(args)
    }
}
impl RemoveInsuranceFundStakeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != REMOVE_INSURANCE_FUND_STAKE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        REMOVE_INSURANCE_FUND_STAKE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(RemoveInsuranceFundStakeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&REMOVE_INSURANCE_FUND_STAKE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn remove_insurance_fund_stake_ix_with_program_id(
    program_id: Pubkey,
    keys: RemoveInsuranceFundStakeKeys,
    args: RemoveInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; REMOVE_INSURANCE_FUND_STAKE_IX_ACCOUNTS_LEN] = keys.into();
    let data: RemoveInsuranceFundStakeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn remove_insurance_fund_stake_ix(
    keys: RemoveInsuranceFundStakeKeys,
    args: RemoveInsuranceFundStakeIxArgs,
) -> std::io::Result<Instruction> {
    remove_insurance_fund_stake_ix_with_program_id(crate::ID, keys, args)
}
pub fn remove_insurance_fund_stake_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RemoveInsuranceFundStakeIxArgs,
) -> ProgramResult {
    let keys: RemoveInsuranceFundStakeKeys = accounts.into();
    let ix = remove_insurance_fund_stake_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn remove_insurance_fund_stake_invoke(
    accounts: RemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RemoveInsuranceFundStakeIxArgs,
) -> ProgramResult {
    remove_insurance_fund_stake_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn remove_insurance_fund_stake_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RemoveInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RemoveInsuranceFundStakeKeys = accounts.into();
    let ix = remove_insurance_fund_stake_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn remove_insurance_fund_stake_invoke_signed(
    accounts: RemoveInsuranceFundStakeAccounts<'_, '_>,
    args: RemoveInsuranceFundStakeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    remove_insurance_fund_stake_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn remove_insurance_fund_stake_verify_account_keys(
    accounts: RemoveInsuranceFundStakeAccounts<'_, '_>,
    keys: RemoveInsuranceFundStakeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.user_token_account.key, keys.user_token_account),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn remove_insurance_fund_stake_verify_writable_privileges<'me, 'info>(
    accounts: RemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
        accounts.insurance_fund_vault,
        accounts.user_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn remove_insurance_fund_stake_verify_signer_privileges<'me, 'info>(
    accounts: RemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn remove_insurance_fund_stake_verify_account_privileges<'me, 'info>(
    accounts: RemoveInsuranceFundStakeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    remove_insurance_fund_stake_verify_writable_privileges(accounts)?;
    remove_insurance_fund_stake_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN: usize = 8;
#[derive(Copy, Clone, Debug)]
pub struct TransferProtocolIfSharesAccounts<'me, 'info> {
    pub signer: &'me AccountInfo<'info>,
    pub transfer_config: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub insurance_fund_stake: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct TransferProtocolIfSharesKeys {
    pub signer: Pubkey,
    pub transfer_config: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub insurance_fund_stake: Pubkey,
    pub user_stats: Pubkey,
    pub authority: Pubkey,
    pub insurance_fund_vault: Pubkey,
}
impl From<TransferProtocolIfSharesAccounts<'_, '_>> for TransferProtocolIfSharesKeys {
    fn from(accounts: TransferProtocolIfSharesAccounts) -> Self {
        Self {
            signer: *accounts.signer.key,
            transfer_config: *accounts.transfer_config.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            insurance_fund_stake: *accounts.insurance_fund_stake.key,
            user_stats: *accounts.user_stats.key,
            authority: *accounts.authority.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
        }
    }
}
impl From<TransferProtocolIfSharesKeys>
for [AccountMeta; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN] {
    fn from(keys: TransferProtocolIfSharesKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.signer,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.transfer_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_stake,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN]>
for TransferProtocolIfSharesKeys {
    fn from(pubkeys: [Pubkey; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            signer: pubkeys[0],
            transfer_config: pubkeys[1],
            state: pubkeys[2],
            spot_market: pubkeys[3],
            insurance_fund_stake: pubkeys[4],
            user_stats: pubkeys[5],
            authority: pubkeys[6],
            insurance_fund_vault: pubkeys[7],
        }
    }
}
impl<'info> From<TransferProtocolIfSharesAccounts<'_, 'info>>
for [AccountInfo<'info>; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN] {
    fn from(accounts: TransferProtocolIfSharesAccounts<'_, 'info>) -> Self {
        [
            accounts.signer.clone(),
            accounts.transfer_config.clone(),
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.insurance_fund_stake.clone(),
            accounts.user_stats.clone(),
            accounts.authority.clone(),
            accounts.insurance_fund_vault.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN]>
for TransferProtocolIfSharesAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            signer: &arr[0],
            transfer_config: &arr[1],
            state: &arr[2],
            spot_market: &arr[3],
            insurance_fund_stake: &arr[4],
            user_stats: &arr[5],
            authority: &arr[6],
            insurance_fund_vault: &arr[7],
        }
    }
}
pub const TRANSFER_PROTOCOL_IF_SHARES_IX_DISCM: [u8; 8] = [
    94,
    93,
    226,
    240,
    195,
    201,
    184,
    109,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct TransferProtocolIfSharesIxArgs {
    pub market_index: u16,
    pub shares: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct TransferProtocolIfSharesIxData(pub TransferProtocolIfSharesIxArgs);
impl From<TransferProtocolIfSharesIxArgs> for TransferProtocolIfSharesIxData {
    fn from(args: TransferProtocolIfSharesIxArgs) -> Self {
        Self(args)
    }
}
impl TransferProtocolIfSharesIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != TRANSFER_PROTOCOL_IF_SHARES_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        TRANSFER_PROTOCOL_IF_SHARES_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(TransferProtocolIfSharesIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&TRANSFER_PROTOCOL_IF_SHARES_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn transfer_protocol_if_shares_ix_with_program_id(
    program_id: Pubkey,
    keys: TransferProtocolIfSharesKeys,
    args: TransferProtocolIfSharesIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; TRANSFER_PROTOCOL_IF_SHARES_IX_ACCOUNTS_LEN] = keys.into();
    let data: TransferProtocolIfSharesIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn transfer_protocol_if_shares_ix(
    keys: TransferProtocolIfSharesKeys,
    args: TransferProtocolIfSharesIxArgs,
) -> std::io::Result<Instruction> {
    transfer_protocol_if_shares_ix_with_program_id(crate::ID, keys, args)
}
pub fn transfer_protocol_if_shares_invoke_with_program_id(
    program_id: Pubkey,
    accounts: TransferProtocolIfSharesAccounts<'_, '_>,
    args: TransferProtocolIfSharesIxArgs,
) -> ProgramResult {
    let keys: TransferProtocolIfSharesKeys = accounts.into();
    let ix = transfer_protocol_if_shares_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn transfer_protocol_if_shares_invoke(
    accounts: TransferProtocolIfSharesAccounts<'_, '_>,
    args: TransferProtocolIfSharesIxArgs,
) -> ProgramResult {
    transfer_protocol_if_shares_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn transfer_protocol_if_shares_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: TransferProtocolIfSharesAccounts<'_, '_>,
    args: TransferProtocolIfSharesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: TransferProtocolIfSharesKeys = accounts.into();
    let ix = transfer_protocol_if_shares_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn transfer_protocol_if_shares_invoke_signed(
    accounts: TransferProtocolIfSharesAccounts<'_, '_>,
    args: TransferProtocolIfSharesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    transfer_protocol_if_shares_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn transfer_protocol_if_shares_verify_account_keys(
    accounts: TransferProtocolIfSharesAccounts<'_, '_>,
    keys: TransferProtocolIfSharesKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.signer.key, keys.signer),
        (*accounts.transfer_config.key, keys.transfer_config),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.insurance_fund_stake.key, keys.insurance_fund_stake),
        (*accounts.user_stats.key, keys.user_stats),
        (*accounts.authority.key, keys.authority),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn transfer_protocol_if_shares_verify_writable_privileges<'me, 'info>(
    accounts: TransferProtocolIfSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.transfer_config,
        accounts.spot_market,
        accounts.insurance_fund_stake,
        accounts.user_stats,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn transfer_protocol_if_shares_verify_signer_privileges<'me, 'info>(
    accounts: TransferProtocolIfSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.signer, accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn transfer_protocol_if_shares_verify_account_privileges<'me, 'info>(
    accounts: TransferProtocolIfSharesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    transfer_protocol_if_shares_verify_writable_privileges(accounts)?;
    transfer_protocol_if_shares_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePythPullOracleAccounts<'me, 'info> {
    pub keeper: &'me AccountInfo<'info>,
    pub pyth_solana_receiver: &'me AccountInfo<'info>,
    pub encoded_vaa: &'me AccountInfo<'info>,
    pub price_feed: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePythPullOracleKeys {
    pub keeper: Pubkey,
    pub pyth_solana_receiver: Pubkey,
    pub encoded_vaa: Pubkey,
    pub price_feed: Pubkey,
}
impl From<UpdatePythPullOracleAccounts<'_, '_>> for UpdatePythPullOracleKeys {
    fn from(accounts: UpdatePythPullOracleAccounts) -> Self {
        Self {
            keeper: *accounts.keeper.key,
            pyth_solana_receiver: *accounts.pyth_solana_receiver.key,
            encoded_vaa: *accounts.encoded_vaa.key,
            price_feed: *accounts.price_feed.key,
        }
    }
}
impl From<UpdatePythPullOracleKeys>
for [AccountMeta; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePythPullOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.keeper,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.pyth_solana_receiver,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.encoded_vaa,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.price_feed,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN]>
for UpdatePythPullOracleKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            keeper: pubkeys[0],
            pyth_solana_receiver: pubkeys[1],
            encoded_vaa: pubkeys[2],
            price_feed: pubkeys[3],
        }
    }
}
impl<'info> From<UpdatePythPullOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePythPullOracleAccounts<'_, 'info>) -> Self {
        [
            accounts.keeper.clone(),
            accounts.pyth_solana_receiver.clone(),
            accounts.encoded_vaa.clone(),
            accounts.price_feed.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN]>
for UpdatePythPullOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            keeper: &arr[0],
            pyth_solana_receiver: &arr[1],
            encoded_vaa: &arr[2],
            price_feed: &arr[3],
        }
    }
}
pub const UPDATE_PYTH_PULL_ORACLE_IX_DISCM: [u8; 8] = [
    230,
    191,
    189,
    94,
    108,
    59,
    74,
    197,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePythPullOracleIxArgs {
    pub feed_id: [u8; 32],
    pub params: Vec<u8>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePythPullOracleIxData(pub UpdatePythPullOracleIxArgs);
impl From<UpdatePythPullOracleIxArgs> for UpdatePythPullOracleIxData {
    fn from(args: UpdatePythPullOracleIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePythPullOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PYTH_PULL_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PYTH_PULL_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePythPullOracleIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PYTH_PULL_ORACLE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_pyth_pull_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePythPullOracleKeys,
    args: UpdatePythPullOracleIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePythPullOracleIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_pyth_pull_oracle_ix(
    keys: UpdatePythPullOracleKeys,
    args: UpdatePythPullOracleIxArgs,
) -> std::io::Result<Instruction> {
    update_pyth_pull_oracle_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_pyth_pull_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePythPullOracleAccounts<'_, '_>,
    args: UpdatePythPullOracleIxArgs,
) -> ProgramResult {
    let keys: UpdatePythPullOracleKeys = accounts.into();
    let ix = update_pyth_pull_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_pyth_pull_oracle_invoke(
    accounts: UpdatePythPullOracleAccounts<'_, '_>,
    args: UpdatePythPullOracleIxArgs,
) -> ProgramResult {
    update_pyth_pull_oracle_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_pyth_pull_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePythPullOracleAccounts<'_, '_>,
    args: UpdatePythPullOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePythPullOracleKeys = accounts.into();
    let ix = update_pyth_pull_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_pyth_pull_oracle_invoke_signed(
    accounts: UpdatePythPullOracleAccounts<'_, '_>,
    args: UpdatePythPullOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_pyth_pull_oracle_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_pyth_pull_oracle_verify_account_keys(
    accounts: UpdatePythPullOracleAccounts<'_, '_>,
    keys: UpdatePythPullOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.keeper.key, keys.keeper),
        (*accounts.pyth_solana_receiver.key, keys.pyth_solana_receiver),
        (*accounts.encoded_vaa.key, keys.encoded_vaa),
        (*accounts.price_feed.key, keys.price_feed),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_pyth_pull_oracle_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePythPullOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.keeper, accounts.price_feed] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_pyth_pull_oracle_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePythPullOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.keeper] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_pyth_pull_oracle_verify_account_privileges<'me, 'info>(
    accounts: UpdatePythPullOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_pyth_pull_oracle_verify_writable_privileges(accounts)?;
    update_pyth_pull_oracle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct PostPythPullOracleUpdateAtomicAccounts<'me, 'info> {
    pub keeper: &'me AccountInfo<'info>,
    pub pyth_solana_receiver: &'me AccountInfo<'info>,
    pub guardian_set: &'me AccountInfo<'info>,
    pub price_feed: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PostPythPullOracleUpdateAtomicKeys {
    pub keeper: Pubkey,
    pub pyth_solana_receiver: Pubkey,
    pub guardian_set: Pubkey,
    pub price_feed: Pubkey,
}
impl From<PostPythPullOracleUpdateAtomicAccounts<'_, '_>>
for PostPythPullOracleUpdateAtomicKeys {
    fn from(accounts: PostPythPullOracleUpdateAtomicAccounts) -> Self {
        Self {
            keeper: *accounts.keeper.key,
            pyth_solana_receiver: *accounts.pyth_solana_receiver.key,
            guardian_set: *accounts.guardian_set.key,
            price_feed: *accounts.price_feed.key,
        }
    }
}
impl From<PostPythPullOracleUpdateAtomicKeys>
for [AccountMeta; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN] {
    fn from(keys: PostPythPullOracleUpdateAtomicKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.keeper,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.pyth_solana_receiver,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.guardian_set,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.price_feed,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN]>
for PostPythPullOracleUpdateAtomicKeys {
    fn from(
        pubkeys: [Pubkey; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            keeper: pubkeys[0],
            pyth_solana_receiver: pubkeys[1],
            guardian_set: pubkeys[2],
            price_feed: pubkeys[3],
        }
    }
}
impl<'info> From<PostPythPullOracleUpdateAtomicAccounts<'_, 'info>>
for [AccountInfo<'info>; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN] {
    fn from(accounts: PostPythPullOracleUpdateAtomicAccounts<'_, 'info>) -> Self {
        [
            accounts.keeper.clone(),
            accounts.pyth_solana_receiver.clone(),
            accounts.guardian_set.clone(),
            accounts.price_feed.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN]>
for PostPythPullOracleUpdateAtomicAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            keeper: &arr[0],
            pyth_solana_receiver: &arr[1],
            guardian_set: &arr[2],
            price_feed: &arr[3],
        }
    }
}
pub const POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_DISCM: [u8; 8] = [
    116,
    122,
    137,
    158,
    224,
    195,
    173,
    119,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PostPythPullOracleUpdateAtomicIxArgs {
    pub feed_id: [u8; 32],
    pub params: Vec<u8>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PostPythPullOracleUpdateAtomicIxData(
    pub PostPythPullOracleUpdateAtomicIxArgs,
);
impl From<PostPythPullOracleUpdateAtomicIxArgs>
for PostPythPullOracleUpdateAtomicIxData {
    fn from(args: PostPythPullOracleUpdateAtomicIxArgs) -> Self {
        Self(args)
    }
}
impl PostPythPullOracleUpdateAtomicIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PostPythPullOracleUpdateAtomicIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn post_pyth_pull_oracle_update_atomic_ix_with_program_id(
    program_id: Pubkey,
    keys: PostPythPullOracleUpdateAtomicKeys,
    args: PostPythPullOracleUpdateAtomicIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; POST_PYTH_PULL_ORACLE_UPDATE_ATOMIC_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: PostPythPullOracleUpdateAtomicIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn post_pyth_pull_oracle_update_atomic_ix(
    keys: PostPythPullOracleUpdateAtomicKeys,
    args: PostPythPullOracleUpdateAtomicIxArgs,
) -> std::io::Result<Instruction> {
    post_pyth_pull_oracle_update_atomic_ix_with_program_id(crate::ID, keys, args)
}
pub fn post_pyth_pull_oracle_update_atomic_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PostPythPullOracleUpdateAtomicAccounts<'_, '_>,
    args: PostPythPullOracleUpdateAtomicIxArgs,
) -> ProgramResult {
    let keys: PostPythPullOracleUpdateAtomicKeys = accounts.into();
    let ix = post_pyth_pull_oracle_update_atomic_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn post_pyth_pull_oracle_update_atomic_invoke(
    accounts: PostPythPullOracleUpdateAtomicAccounts<'_, '_>,
    args: PostPythPullOracleUpdateAtomicIxArgs,
) -> ProgramResult {
    post_pyth_pull_oracle_update_atomic_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn post_pyth_pull_oracle_update_atomic_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PostPythPullOracleUpdateAtomicAccounts<'_, '_>,
    args: PostPythPullOracleUpdateAtomicIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PostPythPullOracleUpdateAtomicKeys = accounts.into();
    let ix = post_pyth_pull_oracle_update_atomic_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn post_pyth_pull_oracle_update_atomic_invoke_signed(
    accounts: PostPythPullOracleUpdateAtomicAccounts<'_, '_>,
    args: PostPythPullOracleUpdateAtomicIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    post_pyth_pull_oracle_update_atomic_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn post_pyth_pull_oracle_update_atomic_verify_account_keys(
    accounts: PostPythPullOracleUpdateAtomicAccounts<'_, '_>,
    keys: PostPythPullOracleUpdateAtomicKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.keeper.key, keys.keeper),
        (*accounts.pyth_solana_receiver.key, keys.pyth_solana_receiver),
        (*accounts.guardian_set.key, keys.guardian_set),
        (*accounts.price_feed.key, keys.price_feed),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn post_pyth_pull_oracle_update_atomic_verify_writable_privileges<'me, 'info>(
    accounts: PostPythPullOracleUpdateAtomicAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.keeper, accounts.price_feed] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn post_pyth_pull_oracle_update_atomic_verify_signer_privileges<'me, 'info>(
    accounts: PostPythPullOracleUpdateAtomicAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.keeper] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn post_pyth_pull_oracle_update_atomic_verify_account_privileges<'me, 'info>(
    accounts: PostPythPullOracleUpdateAtomicAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    post_pyth_pull_oracle_update_atomic_verify_writable_privileges(accounts)?;
    post_pyth_pull_oracle_update_atomic_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct PostMultiPythPullOracleUpdatesAtomicAccounts<'me, 'info> {
    pub keeper: &'me AccountInfo<'info>,
    pub pyth_solana_receiver: &'me AccountInfo<'info>,
    pub guardian_set: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PostMultiPythPullOracleUpdatesAtomicKeys {
    pub keeper: Pubkey,
    pub pyth_solana_receiver: Pubkey,
    pub guardian_set: Pubkey,
}
impl From<PostMultiPythPullOracleUpdatesAtomicAccounts<'_, '_>>
for PostMultiPythPullOracleUpdatesAtomicKeys {
    fn from(accounts: PostMultiPythPullOracleUpdatesAtomicAccounts) -> Self {
        Self {
            keeper: *accounts.keeper.key,
            pyth_solana_receiver: *accounts.pyth_solana_receiver.key,
            guardian_set: *accounts.guardian_set.key,
        }
    }
}
impl From<PostMultiPythPullOracleUpdatesAtomicKeys>
for [AccountMeta; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN] {
    fn from(keys: PostMultiPythPullOracleUpdatesAtomicKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.keeper,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.pyth_solana_receiver,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.guardian_set,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN]>
for PostMultiPythPullOracleUpdatesAtomicKeys {
    fn from(
        pubkeys: [Pubkey; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            keeper: pubkeys[0],
            pyth_solana_receiver: pubkeys[1],
            guardian_set: pubkeys[2],
        }
    }
}
impl<'info> From<PostMultiPythPullOracleUpdatesAtomicAccounts<'_, 'info>>
for [AccountInfo<'info>; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN] {
    fn from(accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'_, 'info>) -> Self {
        [
            accounts.keeper.clone(),
            accounts.pyth_solana_receiver.clone(),
            accounts.guardian_set.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN],
> for PostMultiPythPullOracleUpdatesAtomicAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            keeper: &arr[0],
            pyth_solana_receiver: &arr[1],
            guardian_set: &arr[2],
        }
    }
}
pub const POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_DISCM: [u8; 8] = [
    243,
    79,
    204,
    228,
    227,
    208,
    100,
    244,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PostMultiPythPullOracleUpdatesAtomicIxArgs {
    pub params: Vec<u8>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PostMultiPythPullOracleUpdatesAtomicIxData(
    pub PostMultiPythPullOracleUpdatesAtomicIxArgs,
);
impl From<PostMultiPythPullOracleUpdatesAtomicIxArgs>
for PostMultiPythPullOracleUpdatesAtomicIxData {
    fn from(args: PostMultiPythPullOracleUpdatesAtomicIxArgs) -> Self {
        Self(args)
    }
}
impl PostMultiPythPullOracleUpdatesAtomicIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PostMultiPythPullOracleUpdatesAtomicIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_ix_with_program_id(
    program_id: Pubkey,
    keys: PostMultiPythPullOracleUpdatesAtomicKeys,
    args: PostMultiPythPullOracleUpdatesAtomicIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; POST_MULTI_PYTH_PULL_ORACLE_UPDATES_ATOMIC_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: PostMultiPythPullOracleUpdatesAtomicIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_ix(
    keys: PostMultiPythPullOracleUpdatesAtomicKeys,
    args: PostMultiPythPullOracleUpdatesAtomicIxArgs,
) -> std::io::Result<Instruction> {
    post_multi_pyth_pull_oracle_updates_atomic_ix_with_program_id(crate::ID, keys, args)
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'_, '_>,
    args: PostMultiPythPullOracleUpdatesAtomicIxArgs,
) -> ProgramResult {
    let keys: PostMultiPythPullOracleUpdatesAtomicKeys = accounts.into();
    let ix = post_multi_pyth_pull_oracle_updates_atomic_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_invoke(
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'_, '_>,
    args: PostMultiPythPullOracleUpdatesAtomicIxArgs,
) -> ProgramResult {
    post_multi_pyth_pull_oracle_updates_atomic_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'_, '_>,
    args: PostMultiPythPullOracleUpdatesAtomicIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PostMultiPythPullOracleUpdatesAtomicKeys = accounts.into();
    let ix = post_multi_pyth_pull_oracle_updates_atomic_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_invoke_signed(
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'_, '_>,
    args: PostMultiPythPullOracleUpdatesAtomicIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    post_multi_pyth_pull_oracle_updates_atomic_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_verify_account_keys(
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'_, '_>,
    keys: PostMultiPythPullOracleUpdatesAtomicKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.keeper.key, keys.keeper),
        (*accounts.pyth_solana_receiver.key, keys.pyth_solana_receiver),
        (*accounts.guardian_set.key, keys.guardian_set),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_verify_writable_privileges<'me, 'info>(
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.keeper] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_verify_signer_privileges<'me, 'info>(
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.keeper] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn post_multi_pyth_pull_oracle_updates_atomic_verify_account_privileges<'me, 'info>(
    accounts: PostMultiPythPullOracleUpdatesAtomicAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    post_multi_pyth_pull_oracle_updates_atomic_verify_writable_privileges(accounts)?;
    post_multi_pyth_pull_oracle_updates_atomic_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_IX_ACCOUNTS_LEN: usize = 7;
#[derive(Copy, Clone, Debug)]
pub struct InitializeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub quote_asset_mint: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub quote_asset_mint: Pubkey,
    pub drift_signer: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
    pub token_program: Pubkey,
}
impl From<InitializeAccounts<'_, '_>> for InitializeKeys {
    fn from(accounts: InitializeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            quote_asset_mint: *accounts.quote_asset_mint.key,
            drift_signer: *accounts.drift_signer.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<InitializeKeys> for [AccountMeta; INITIALIZE_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.quote_asset_mint,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_IX_ACCOUNTS_LEN]> for InitializeKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            quote_asset_mint: pubkeys[2],
            drift_signer: pubkeys[3],
            rent: pubkeys[4],
            system_program: pubkeys[5],
            token_program: pubkeys[6],
        }
    }
}
impl<'info> From<InitializeAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.quote_asset_mint.clone(),
            accounts.drift_signer.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; INITIALIZE_IX_ACCOUNTS_LEN]>
for InitializeAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; INITIALIZE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            quote_asset_mint: &arr[2],
            drift_signer: &arr[3],
            rent: &arr[4],
            system_program: &arr[5],
            token_program: &arr[6],
        }
    }
}
pub const INITIALIZE_IX_DISCM: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeIxData;
impl InitializeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: InitializeIxData.try_to_vec()?,
    })
}
pub fn initialize_ix(keys: InitializeKeys) -> std::io::Result<Instruction> {
    initialize_ix_with_program_id(crate::ID, keys)
}
pub fn initialize_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeAccounts<'_, '_>,
) -> ProgramResult {
    let keys: InitializeKeys = accounts.into();
    let ix = initialize_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_invoke(accounts: InitializeAccounts<'_, '_>) -> ProgramResult {
    initialize_invoke_with_program_id(crate::ID, accounts)
}
pub fn initialize_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeKeys = accounts.into();
    let ix = initialize_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_invoke_signed(
    accounts: InitializeAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn initialize_verify_account_keys(
    accounts: InitializeAccounts<'_, '_>,
    keys: InitializeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.quote_asset_mint.key, keys.quote_asset_mint),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_verify_writable_privileges<'me, 'info>(
    accounts: InitializeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_verify_signer_privileges<'me, 'info>(
    accounts: InitializeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_verify_account_privileges<'me, 'info>(
    accounts: InitializeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_verify_writable_privileges(accounts)?;
    initialize_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN: usize = 11;
#[derive(Copy, Clone, Debug)]
pub struct InitializeSpotMarketAccounts<'me, 'info> {
    pub spot_market: &'me AccountInfo<'info>,
    pub spot_market_mint: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeSpotMarketKeys {
    pub spot_market: Pubkey,
    pub spot_market_mint: Pubkey,
    pub spot_market_vault: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub state: Pubkey,
    pub oracle: Pubkey,
    pub admin: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
    pub token_program: Pubkey,
}
impl From<InitializeSpotMarketAccounts<'_, '_>> for InitializeSpotMarketKeys {
    fn from(accounts: InitializeSpotMarketAccounts) -> Self {
        Self {
            spot_market: *accounts.spot_market.key,
            spot_market_mint: *accounts.spot_market_mint.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            state: *accounts.state.key,
            oracle: *accounts.oracle.key,
            admin: *accounts.admin.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<InitializeSpotMarketKeys>
for [AccountMeta; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeSpotMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_mint,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN]>
for InitializeSpotMarketKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            spot_market: pubkeys[0],
            spot_market_mint: pubkeys[1],
            spot_market_vault: pubkeys[2],
            insurance_fund_vault: pubkeys[3],
            drift_signer: pubkeys[4],
            state: pubkeys[5],
            oracle: pubkeys[6],
            admin: pubkeys[7],
            rent: pubkeys[8],
            system_program: pubkeys[9],
            token_program: pubkeys[10],
        }
    }
}
impl<'info> From<InitializeSpotMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeSpotMarketAccounts<'_, 'info>) -> Self {
        [
            accounts.spot_market.clone(),
            accounts.spot_market_mint.clone(),
            accounts.spot_market_vault.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.state.clone(),
            accounts.oracle.clone(),
            accounts.admin.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN]>
for InitializeSpotMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            spot_market: &arr[0],
            spot_market_mint: &arr[1],
            spot_market_vault: &arr[2],
            insurance_fund_vault: &arr[3],
            drift_signer: &arr[4],
            state: &arr[5],
            oracle: &arr[6],
            admin: &arr[7],
            rent: &arr[8],
            system_program: &arr[9],
            token_program: &arr[10],
        }
    }
}
pub const INITIALIZE_SPOT_MARKET_IX_DISCM: [u8; 8] = [
    234,
    196,
    128,
    44,
    94,
    15,
    48,
    201,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeSpotMarketIxArgs {
    pub optimal_utilization: u32,
    pub optimal_borrow_rate: u32,
    pub max_borrow_rate: u32,
    pub oracle_source: OracleSource,
    pub initial_asset_weight: u32,
    pub maintenance_asset_weight: u32,
    pub initial_liability_weight: u32,
    pub maintenance_liability_weight: u32,
    pub imf_factor: u32,
    pub liquidator_fee: u32,
    pub if_liquidation_fee: u32,
    pub active_status: bool,
    pub asset_tier: AssetTier,
    pub scale_initial_asset_weight_start: u64,
    pub withdraw_guard_threshold: u64,
    pub order_tick_size: u64,
    pub order_step_size: u64,
    pub if_total_factor: u32,
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeSpotMarketIxData(pub InitializeSpotMarketIxArgs);
impl From<InitializeSpotMarketIxArgs> for InitializeSpotMarketIxData {
    fn from(args: InitializeSpotMarketIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeSpotMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_SPOT_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_SPOT_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeSpotMarketIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_SPOT_MARKET_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_spot_market_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeSpotMarketKeys,
    args: InitializeSpotMarketIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_SPOT_MARKET_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitializeSpotMarketIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_spot_market_ix(
    keys: InitializeSpotMarketKeys,
    args: InitializeSpotMarketIxArgs,
) -> std::io::Result<Instruction> {
    initialize_spot_market_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_spot_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeSpotMarketAccounts<'_, '_>,
    args: InitializeSpotMarketIxArgs,
) -> ProgramResult {
    let keys: InitializeSpotMarketKeys = accounts.into();
    let ix = initialize_spot_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_spot_market_invoke(
    accounts: InitializeSpotMarketAccounts<'_, '_>,
    args: InitializeSpotMarketIxArgs,
) -> ProgramResult {
    initialize_spot_market_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_spot_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeSpotMarketAccounts<'_, '_>,
    args: InitializeSpotMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeSpotMarketKeys = accounts.into();
    let ix = initialize_spot_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_spot_market_invoke_signed(
    accounts: InitializeSpotMarketAccounts<'_, '_>,
    args: InitializeSpotMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_spot_market_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_spot_market_verify_account_keys(
    accounts: InitializeSpotMarketAccounts<'_, '_>,
    keys: InitializeSpotMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.spot_market_mint.key, keys.spot_market_mint),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.state.key, keys.state),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.admin.key, keys.admin),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_spot_market_verify_writable_privileges<'me, 'info>(
    accounts: InitializeSpotMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
        accounts.state,
        accounts.admin,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_spot_market_verify_signer_privileges<'me, 'info>(
    accounts: InitializeSpotMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_spot_market_verify_account_privileges<'me, 'info>(
    accounts: InitializeSpotMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_spot_market_verify_writable_privileges(accounts)?;
    initialize_spot_market_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN: usize = 7;
#[derive(Copy, Clone, Debug)]
pub struct DeleteInitializedSpotMarketAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub insurance_fund_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DeleteInitializedSpotMarketKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub spot_market_vault: Pubkey,
    pub insurance_fund_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub token_program: Pubkey,
}
impl From<DeleteInitializedSpotMarketAccounts<'_, '_>>
for DeleteInitializedSpotMarketKeys {
    fn from(accounts: DeleteInitializedSpotMarketAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            insurance_fund_vault: *accounts.insurance_fund_vault.key,
            drift_signer: *accounts.drift_signer.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<DeleteInitializedSpotMarketKeys>
for [AccountMeta; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: DeleteInitializedSpotMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.insurance_fund_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN]>
for DeleteInitializedSpotMarketKeys {
    fn from(pubkeys: [Pubkey; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
            spot_market_vault: pubkeys[3],
            insurance_fund_vault: pubkeys[4],
            drift_signer: pubkeys[5],
            token_program: pubkeys[6],
        }
    }
}
impl<'info> From<DeleteInitializedSpotMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: DeleteInitializedSpotMarketAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.spot_market_vault.clone(),
            accounts.insurance_fund_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN]>
for DeleteInitializedSpotMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
            spot_market_vault: &arr[3],
            insurance_fund_vault: &arr[4],
            drift_signer: &arr[5],
            token_program: &arr[6],
        }
    }
}
pub const DELETE_INITIALIZED_SPOT_MARKET_IX_DISCM: [u8; 8] = [
    31,
    140,
    67,
    191,
    189,
    20,
    101,
    221,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DeleteInitializedSpotMarketIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DeleteInitializedSpotMarketIxData(pub DeleteInitializedSpotMarketIxArgs);
impl From<DeleteInitializedSpotMarketIxArgs> for DeleteInitializedSpotMarketIxData {
    fn from(args: DeleteInitializedSpotMarketIxArgs) -> Self {
        Self(args)
    }
}
impl DeleteInitializedSpotMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DELETE_INITIALIZED_SPOT_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DELETE_INITIALIZED_SPOT_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DeleteInitializedSpotMarketIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DELETE_INITIALIZED_SPOT_MARKET_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn delete_initialized_spot_market_ix_with_program_id(
    program_id: Pubkey,
    keys: DeleteInitializedSpotMarketKeys,
    args: DeleteInitializedSpotMarketIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DELETE_INITIALIZED_SPOT_MARKET_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: DeleteInitializedSpotMarketIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn delete_initialized_spot_market_ix(
    keys: DeleteInitializedSpotMarketKeys,
    args: DeleteInitializedSpotMarketIxArgs,
) -> std::io::Result<Instruction> {
    delete_initialized_spot_market_ix_with_program_id(crate::ID, keys, args)
}
pub fn delete_initialized_spot_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DeleteInitializedSpotMarketAccounts<'_, '_>,
    args: DeleteInitializedSpotMarketIxArgs,
) -> ProgramResult {
    let keys: DeleteInitializedSpotMarketKeys = accounts.into();
    let ix = delete_initialized_spot_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn delete_initialized_spot_market_invoke(
    accounts: DeleteInitializedSpotMarketAccounts<'_, '_>,
    args: DeleteInitializedSpotMarketIxArgs,
) -> ProgramResult {
    delete_initialized_spot_market_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn delete_initialized_spot_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DeleteInitializedSpotMarketAccounts<'_, '_>,
    args: DeleteInitializedSpotMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DeleteInitializedSpotMarketKeys = accounts.into();
    let ix = delete_initialized_spot_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn delete_initialized_spot_market_invoke_signed(
    accounts: DeleteInitializedSpotMarketAccounts<'_, '_>,
    args: DeleteInitializedSpotMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    delete_initialized_spot_market_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn delete_initialized_spot_market_verify_account_keys(
    accounts: DeleteInitializedSpotMarketAccounts<'_, '_>,
    keys: DeleteInitializedSpotMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.insurance_fund_vault.key, keys.insurance_fund_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn delete_initialized_spot_market_verify_writable_privileges<'me, 'info>(
    accounts: DeleteInitializedSpotMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.admin,
        accounts.state,
        accounts.spot_market,
        accounts.spot_market_vault,
        accounts.insurance_fund_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn delete_initialized_spot_market_verify_signer_privileges<'me, 'info>(
    accounts: DeleteInitializedSpotMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn delete_initialized_spot_market_verify_account_privileges<'me, 'info>(
    accounts: DeleteInitializedSpotMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    delete_initialized_spot_market_verify_writable_privileges(accounts)?;
    delete_initialized_spot_market_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN: usize = 11;
#[derive(Copy, Clone, Debug)]
pub struct InitializeSerumFulfillmentConfigAccounts<'me, 'info> {
    pub base_spot_market: &'me AccountInfo<'info>,
    pub quote_spot_market: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub serum_program: &'me AccountInfo<'info>,
    pub serum_market: &'me AccountInfo<'info>,
    pub serum_open_orders: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub serum_fulfillment_config: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeSerumFulfillmentConfigKeys {
    pub base_spot_market: Pubkey,
    pub quote_spot_market: Pubkey,
    pub state: Pubkey,
    pub serum_program: Pubkey,
    pub serum_market: Pubkey,
    pub serum_open_orders: Pubkey,
    pub drift_signer: Pubkey,
    pub serum_fulfillment_config: Pubkey,
    pub admin: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeSerumFulfillmentConfigAccounts<'_, '_>>
for InitializeSerumFulfillmentConfigKeys {
    fn from(accounts: InitializeSerumFulfillmentConfigAccounts) -> Self {
        Self {
            base_spot_market: *accounts.base_spot_market.key,
            quote_spot_market: *accounts.quote_spot_market.key,
            state: *accounts.state.key,
            serum_program: *accounts.serum_program.key,
            serum_market: *accounts.serum_market.key,
            serum_open_orders: *accounts.serum_open_orders.key,
            drift_signer: *accounts.drift_signer.key,
            serum_fulfillment_config: *accounts.serum_fulfillment_config.key,
            admin: *accounts.admin.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeSerumFulfillmentConfigKeys>
for [AccountMeta; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeSerumFulfillmentConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.base_spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.quote_spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.serum_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.serum_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.serum_open_orders,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.serum_fulfillment_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN]>
for InitializeSerumFulfillmentConfigKeys {
    fn from(
        pubkeys: [Pubkey; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            base_spot_market: pubkeys[0],
            quote_spot_market: pubkeys[1],
            state: pubkeys[2],
            serum_program: pubkeys[3],
            serum_market: pubkeys[4],
            serum_open_orders: pubkeys[5],
            drift_signer: pubkeys[6],
            serum_fulfillment_config: pubkeys[7],
            admin: pubkeys[8],
            rent: pubkeys[9],
            system_program: pubkeys[10],
        }
    }
}
impl<'info> From<InitializeSerumFulfillmentConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeSerumFulfillmentConfigAccounts<'_, 'info>) -> Self {
        [
            accounts.base_spot_market.clone(),
            accounts.quote_spot_market.clone(),
            accounts.state.clone(),
            accounts.serum_program.clone(),
            accounts.serum_market.clone(),
            accounts.serum_open_orders.clone(),
            accounts.drift_signer.clone(),
            accounts.serum_fulfillment_config.clone(),
            accounts.admin.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN]>
for InitializeSerumFulfillmentConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            base_spot_market: &arr[0],
            quote_spot_market: &arr[1],
            state: &arr[2],
            serum_program: &arr[3],
            serum_market: &arr[4],
            serum_open_orders: &arr[5],
            drift_signer: &arr[6],
            serum_fulfillment_config: &arr[7],
            admin: &arr[8],
            rent: &arr[9],
            system_program: &arr[10],
        }
    }
}
pub const INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_DISCM: [u8; 8] = [
    193,
    211,
    132,
    172,
    70,
    171,
    7,
    94,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeSerumFulfillmentConfigIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeSerumFulfillmentConfigIxData(
    pub InitializeSerumFulfillmentConfigIxArgs,
);
impl From<InitializeSerumFulfillmentConfigIxArgs>
for InitializeSerumFulfillmentConfigIxData {
    fn from(args: InitializeSerumFulfillmentConfigIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeSerumFulfillmentConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeSerumFulfillmentConfigIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_serum_fulfillment_config_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeSerumFulfillmentConfigKeys,
    args: InitializeSerumFulfillmentConfigIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_SERUM_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: InitializeSerumFulfillmentConfigIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_serum_fulfillment_config_ix(
    keys: InitializeSerumFulfillmentConfigKeys,
    args: InitializeSerumFulfillmentConfigIxArgs,
) -> std::io::Result<Instruction> {
    initialize_serum_fulfillment_config_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_serum_fulfillment_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeSerumFulfillmentConfigAccounts<'_, '_>,
    args: InitializeSerumFulfillmentConfigIxArgs,
) -> ProgramResult {
    let keys: InitializeSerumFulfillmentConfigKeys = accounts.into();
    let ix = initialize_serum_fulfillment_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_serum_fulfillment_config_invoke(
    accounts: InitializeSerumFulfillmentConfigAccounts<'_, '_>,
    args: InitializeSerumFulfillmentConfigIxArgs,
) -> ProgramResult {
    initialize_serum_fulfillment_config_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_serum_fulfillment_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeSerumFulfillmentConfigAccounts<'_, '_>,
    args: InitializeSerumFulfillmentConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeSerumFulfillmentConfigKeys = accounts.into();
    let ix = initialize_serum_fulfillment_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_serum_fulfillment_config_invoke_signed(
    accounts: InitializeSerumFulfillmentConfigAccounts<'_, '_>,
    args: InitializeSerumFulfillmentConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_serum_fulfillment_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_serum_fulfillment_config_verify_account_keys(
    accounts: InitializeSerumFulfillmentConfigAccounts<'_, '_>,
    keys: InitializeSerumFulfillmentConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.base_spot_market.key, keys.base_spot_market),
        (*accounts.quote_spot_market.key, keys.quote_spot_market),
        (*accounts.state.key, keys.state),
        (*accounts.serum_program.key, keys.serum_program),
        (*accounts.serum_market.key, keys.serum_market),
        (*accounts.serum_open_orders.key, keys.serum_open_orders),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.serum_fulfillment_config.key, keys.serum_fulfillment_config),
        (*accounts.admin.key, keys.admin),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_serum_fulfillment_config_verify_writable_privileges<'me, 'info>(
    accounts: InitializeSerumFulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.state,
        accounts.serum_open_orders,
        accounts.serum_fulfillment_config,
        accounts.admin,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_serum_fulfillment_config_verify_signer_privileges<'me, 'info>(
    accounts: InitializeSerumFulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_serum_fulfillment_config_verify_account_privileges<'me, 'info>(
    accounts: InitializeSerumFulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_serum_fulfillment_config_verify_writable_privileges(accounts)?;
    initialize_serum_fulfillment_config_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSerumFulfillmentConfigStatusAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub serum_fulfillment_config: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSerumFulfillmentConfigStatusKeys {
    pub state: Pubkey,
    pub serum_fulfillment_config: Pubkey,
    pub admin: Pubkey,
}
impl From<UpdateSerumFulfillmentConfigStatusAccounts<'_, '_>>
for UpdateSerumFulfillmentConfigStatusKeys {
    fn from(accounts: UpdateSerumFulfillmentConfigStatusAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            serum_fulfillment_config: *accounts.serum_fulfillment_config.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<UpdateSerumFulfillmentConfigStatusKeys>
for [AccountMeta; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSerumFulfillmentConfigStatusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.serum_fulfillment_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN]>
for UpdateSerumFulfillmentConfigStatusKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            serum_fulfillment_config: pubkeys[1],
            admin: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSerumFulfillmentConfigStatusAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSerumFulfillmentConfigStatusAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.serum_fulfillment_config.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN]>
for UpdateSerumFulfillmentConfigStatusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            serum_fulfillment_config: &arr[1],
            admin: &arr[2],
        }
    }
}
pub const UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_DISCM: [u8; 8] = [
    171,
    109,
    240,
    251,
    95,
    1,
    149,
    89,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSerumFulfillmentConfigStatusIxArgs {
    pub status: SpotFulfillmentConfigStatus,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSerumFulfillmentConfigStatusIxData(
    pub UpdateSerumFulfillmentConfigStatusIxArgs,
);
impl From<UpdateSerumFulfillmentConfigStatusIxArgs>
for UpdateSerumFulfillmentConfigStatusIxData {
    fn from(args: UpdateSerumFulfillmentConfigStatusIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSerumFulfillmentConfigStatusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSerumFulfillmentConfigStatusIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_serum_fulfillment_config_status_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSerumFulfillmentConfigStatusKeys,
    args: UpdateSerumFulfillmentConfigStatusIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SERUM_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSerumFulfillmentConfigStatusIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_serum_fulfillment_config_status_ix(
    keys: UpdateSerumFulfillmentConfigStatusKeys,
    args: UpdateSerumFulfillmentConfigStatusIxArgs,
) -> std::io::Result<Instruction> {
    update_serum_fulfillment_config_status_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_serum_fulfillment_config_status_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'_, '_>,
    args: UpdateSerumFulfillmentConfigStatusIxArgs,
) -> ProgramResult {
    let keys: UpdateSerumFulfillmentConfigStatusKeys = accounts.into();
    let ix = update_serum_fulfillment_config_status_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_serum_fulfillment_config_status_invoke(
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'_, '_>,
    args: UpdateSerumFulfillmentConfigStatusIxArgs,
) -> ProgramResult {
    update_serum_fulfillment_config_status_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_serum_fulfillment_config_status_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'_, '_>,
    args: UpdateSerumFulfillmentConfigStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSerumFulfillmentConfigStatusKeys = accounts.into();
    let ix = update_serum_fulfillment_config_status_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_serum_fulfillment_config_status_invoke_signed(
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'_, '_>,
    args: UpdateSerumFulfillmentConfigStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_serum_fulfillment_config_status_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_serum_fulfillment_config_status_verify_account_keys(
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'_, '_>,
    keys: UpdateSerumFulfillmentConfigStatusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.serum_fulfillment_config.key, keys.serum_fulfillment_config),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_serum_fulfillment_config_status_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.serum_fulfillment_config, accounts.admin] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_serum_fulfillment_config_status_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_serum_fulfillment_config_status_verify_account_privileges<'me, 'info>(
    accounts: UpdateSerumFulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_serum_fulfillment_config_status_verify_writable_privileges(accounts)?;
    update_serum_fulfillment_config_status_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN: usize = 10;
#[derive(Copy, Clone, Debug)]
pub struct InitializeOpenbookV2FulfillmentConfigAccounts<'me, 'info> {
    pub base_spot_market: &'me AccountInfo<'info>,
    pub quote_spot_market: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub openbook_v2_program: &'me AccountInfo<'info>,
    pub openbook_v2_market: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub openbook_v2_fulfillment_config: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeOpenbookV2FulfillmentConfigKeys {
    pub base_spot_market: Pubkey,
    pub quote_spot_market: Pubkey,
    pub state: Pubkey,
    pub openbook_v2_program: Pubkey,
    pub openbook_v2_market: Pubkey,
    pub drift_signer: Pubkey,
    pub openbook_v2_fulfillment_config: Pubkey,
    pub admin: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeOpenbookV2FulfillmentConfigAccounts<'_, '_>>
for InitializeOpenbookV2FulfillmentConfigKeys {
    fn from(accounts: InitializeOpenbookV2FulfillmentConfigAccounts) -> Self {
        Self {
            base_spot_market: *accounts.base_spot_market.key,
            quote_spot_market: *accounts.quote_spot_market.key,
            state: *accounts.state.key,
            openbook_v2_program: *accounts.openbook_v2_program.key,
            openbook_v2_market: *accounts.openbook_v2_market.key,
            drift_signer: *accounts.drift_signer.key,
            openbook_v2_fulfillment_config: *accounts.openbook_v2_fulfillment_config.key,
            admin: *accounts.admin.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeOpenbookV2FulfillmentConfigKeys>
for [AccountMeta; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeOpenbookV2FulfillmentConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.base_spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.quote_spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.openbook_v2_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.openbook_v2_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.openbook_v2_fulfillment_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN]>
for InitializeOpenbookV2FulfillmentConfigKeys {
    fn from(
        pubkeys: [Pubkey; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            base_spot_market: pubkeys[0],
            quote_spot_market: pubkeys[1],
            state: pubkeys[2],
            openbook_v2_program: pubkeys[3],
            openbook_v2_market: pubkeys[4],
            drift_signer: pubkeys[5],
            openbook_v2_fulfillment_config: pubkeys[6],
            admin: pubkeys[7],
            rent: pubkeys[8],
            system_program: pubkeys[9],
        }
    }
}
impl<'info> From<InitializeOpenbookV2FulfillmentConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'_, 'info>) -> Self {
        [
            accounts.base_spot_market.clone(),
            accounts.quote_spot_market.clone(),
            accounts.state.clone(),
            accounts.openbook_v2_program.clone(),
            accounts.openbook_v2_market.clone(),
            accounts.drift_signer.clone(),
            accounts.openbook_v2_fulfillment_config.clone(),
            accounts.admin.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
> for InitializeOpenbookV2FulfillmentConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            base_spot_market: &arr[0],
            quote_spot_market: &arr[1],
            state: &arr[2],
            openbook_v2_program: &arr[3],
            openbook_v2_market: &arr[4],
            drift_signer: &arr[5],
            openbook_v2_fulfillment_config: &arr[6],
            admin: &arr[7],
            rent: &arr[8],
            system_program: &arr[9],
        }
    }
}
pub const INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_DISCM: [u8; 8] = [
    7,
    221,
    103,
    153,
    107,
    57,
    27,
    197,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeOpenbookV2FulfillmentConfigIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeOpenbookV2FulfillmentConfigIxData(
    pub InitializeOpenbookV2FulfillmentConfigIxArgs,
);
impl From<InitializeOpenbookV2FulfillmentConfigIxArgs>
for InitializeOpenbookV2FulfillmentConfigIxData {
    fn from(args: InitializeOpenbookV2FulfillmentConfigIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeOpenbookV2FulfillmentConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeOpenbookV2FulfillmentConfigIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_openbook_v2_fulfillment_config_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeOpenbookV2FulfillmentConfigKeys,
    args: InitializeOpenbookV2FulfillmentConfigIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_OPENBOOK_V2_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: InitializeOpenbookV2FulfillmentConfigIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_openbook_v2_fulfillment_config_ix(
    keys: InitializeOpenbookV2FulfillmentConfigKeys,
    args: InitializeOpenbookV2FulfillmentConfigIxArgs,
) -> std::io::Result<Instruction> {
    initialize_openbook_v2_fulfillment_config_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_openbook_v2_fulfillment_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'_, '_>,
    args: InitializeOpenbookV2FulfillmentConfigIxArgs,
) -> ProgramResult {
    let keys: InitializeOpenbookV2FulfillmentConfigKeys = accounts.into();
    let ix = initialize_openbook_v2_fulfillment_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_openbook_v2_fulfillment_config_invoke(
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'_, '_>,
    args: InitializeOpenbookV2FulfillmentConfigIxArgs,
) -> ProgramResult {
    initialize_openbook_v2_fulfillment_config_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn initialize_openbook_v2_fulfillment_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'_, '_>,
    args: InitializeOpenbookV2FulfillmentConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeOpenbookV2FulfillmentConfigKeys = accounts.into();
    let ix = initialize_openbook_v2_fulfillment_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_openbook_v2_fulfillment_config_invoke_signed(
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'_, '_>,
    args: InitializeOpenbookV2FulfillmentConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_openbook_v2_fulfillment_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_openbook_v2_fulfillment_config_verify_account_keys(
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'_, '_>,
    keys: InitializeOpenbookV2FulfillmentConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.base_spot_market.key, keys.base_spot_market),
        (*accounts.quote_spot_market.key, keys.quote_spot_market),
        (*accounts.state.key, keys.state),
        (*accounts.openbook_v2_program.key, keys.openbook_v2_program),
        (*accounts.openbook_v2_market.key, keys.openbook_v2_market),
        (*accounts.drift_signer.key, keys.drift_signer),
        (
            *accounts.openbook_v2_fulfillment_config.key,
            keys.openbook_v2_fulfillment_config,
        ),
        (*accounts.admin.key, keys.admin),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_openbook_v2_fulfillment_config_verify_writable_privileges<'me, 'info>(
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.state,
        accounts.openbook_v2_fulfillment_config,
        accounts.admin,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_openbook_v2_fulfillment_config_verify_signer_privileges<'me, 'info>(
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_openbook_v2_fulfillment_config_verify_account_privileges<'me, 'info>(
    accounts: InitializeOpenbookV2FulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_openbook_v2_fulfillment_config_verify_writable_privileges(accounts)?;
    initialize_openbook_v2_fulfillment_config_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct OpenbookV2FulfillmentConfigStatusAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub openbook_v2_fulfillment_config: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct OpenbookV2FulfillmentConfigStatusKeys {
    pub state: Pubkey,
    pub openbook_v2_fulfillment_config: Pubkey,
    pub admin: Pubkey,
}
impl From<OpenbookV2FulfillmentConfigStatusAccounts<'_, '_>>
for OpenbookV2FulfillmentConfigStatusKeys {
    fn from(accounts: OpenbookV2FulfillmentConfigStatusAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            openbook_v2_fulfillment_config: *accounts.openbook_v2_fulfillment_config.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<OpenbookV2FulfillmentConfigStatusKeys>
for [AccountMeta; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] {
    fn from(keys: OpenbookV2FulfillmentConfigStatusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.openbook_v2_fulfillment_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN]>
for OpenbookV2FulfillmentConfigStatusKeys {
    fn from(
        pubkeys: [Pubkey; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            openbook_v2_fulfillment_config: pubkeys[1],
            admin: pubkeys[2],
        }
    }
}
impl<'info> From<OpenbookV2FulfillmentConfigStatusAccounts<'_, 'info>>
for [AccountInfo<'info>; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: OpenbookV2FulfillmentConfigStatusAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.openbook_v2_fulfillment_config.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN]>
for OpenbookV2FulfillmentConfigStatusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            openbook_v2_fulfillment_config: &arr[1],
            admin: &arr[2],
        }
    }
}
pub const OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_DISCM: [u8; 8] = [
    25,
    173,
    19,
    189,
    4,
    211,
    64,
    238,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct OpenbookV2FulfillmentConfigStatusIxArgs {
    pub status: SpotFulfillmentConfigStatus,
}
#[derive(Clone, Debug, PartialEq)]
pub struct OpenbookV2FulfillmentConfigStatusIxData(
    pub OpenbookV2FulfillmentConfigStatusIxArgs,
);
impl From<OpenbookV2FulfillmentConfigStatusIxArgs>
for OpenbookV2FulfillmentConfigStatusIxData {
    fn from(args: OpenbookV2FulfillmentConfigStatusIxArgs) -> Self {
        Self(args)
    }
}
impl OpenbookV2FulfillmentConfigStatusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(OpenbookV2FulfillmentConfigStatusIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn openbook_v2_fulfillment_config_status_ix_with_program_id(
    program_id: Pubkey,
    keys: OpenbookV2FulfillmentConfigStatusKeys,
    args: OpenbookV2FulfillmentConfigStatusIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; OPENBOOK_V2_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: OpenbookV2FulfillmentConfigStatusIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn openbook_v2_fulfillment_config_status_ix(
    keys: OpenbookV2FulfillmentConfigStatusKeys,
    args: OpenbookV2FulfillmentConfigStatusIxArgs,
) -> std::io::Result<Instruction> {
    openbook_v2_fulfillment_config_status_ix_with_program_id(crate::ID, keys, args)
}
pub fn openbook_v2_fulfillment_config_status_invoke_with_program_id(
    program_id: Pubkey,
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'_, '_>,
    args: OpenbookV2FulfillmentConfigStatusIxArgs,
) -> ProgramResult {
    let keys: OpenbookV2FulfillmentConfigStatusKeys = accounts.into();
    let ix = openbook_v2_fulfillment_config_status_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn openbook_v2_fulfillment_config_status_invoke(
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'_, '_>,
    args: OpenbookV2FulfillmentConfigStatusIxArgs,
) -> ProgramResult {
    openbook_v2_fulfillment_config_status_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn openbook_v2_fulfillment_config_status_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'_, '_>,
    args: OpenbookV2FulfillmentConfigStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: OpenbookV2FulfillmentConfigStatusKeys = accounts.into();
    let ix = openbook_v2_fulfillment_config_status_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn openbook_v2_fulfillment_config_status_invoke_signed(
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'_, '_>,
    args: OpenbookV2FulfillmentConfigStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    openbook_v2_fulfillment_config_status_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn openbook_v2_fulfillment_config_status_verify_account_keys(
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'_, '_>,
    keys: OpenbookV2FulfillmentConfigStatusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (
            *accounts.openbook_v2_fulfillment_config.key,
            keys.openbook_v2_fulfillment_config,
        ),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn openbook_v2_fulfillment_config_status_verify_writable_privileges<'me, 'info>(
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.openbook_v2_fulfillment_config, accounts.admin] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn openbook_v2_fulfillment_config_status_verify_signer_privileges<'me, 'info>(
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn openbook_v2_fulfillment_config_status_verify_account_privileges<'me, 'info>(
    accounts: OpenbookV2FulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    openbook_v2_fulfillment_config_status_verify_writable_privileges(accounts)?;
    openbook_v2_fulfillment_config_status_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN: usize = 10;
#[derive(Copy, Clone, Debug)]
pub struct InitializePhoenixFulfillmentConfigAccounts<'me, 'info> {
    pub base_spot_market: &'me AccountInfo<'info>,
    pub quote_spot_market: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub phoenix_program: &'me AccountInfo<'info>,
    pub phoenix_market: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub phoenix_fulfillment_config: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializePhoenixFulfillmentConfigKeys {
    pub base_spot_market: Pubkey,
    pub quote_spot_market: Pubkey,
    pub state: Pubkey,
    pub phoenix_program: Pubkey,
    pub phoenix_market: Pubkey,
    pub drift_signer: Pubkey,
    pub phoenix_fulfillment_config: Pubkey,
    pub admin: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializePhoenixFulfillmentConfigAccounts<'_, '_>>
for InitializePhoenixFulfillmentConfigKeys {
    fn from(accounts: InitializePhoenixFulfillmentConfigAccounts) -> Self {
        Self {
            base_spot_market: *accounts.base_spot_market.key,
            quote_spot_market: *accounts.quote_spot_market.key,
            state: *accounts.state.key,
            phoenix_program: *accounts.phoenix_program.key,
            phoenix_market: *accounts.phoenix_market.key,
            drift_signer: *accounts.drift_signer.key,
            phoenix_fulfillment_config: *accounts.phoenix_fulfillment_config.key,
            admin: *accounts.admin.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializePhoenixFulfillmentConfigKeys>
for [AccountMeta; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializePhoenixFulfillmentConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.base_spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.quote_spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.phoenix_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.phoenix_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.phoenix_fulfillment_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN]>
for InitializePhoenixFulfillmentConfigKeys {
    fn from(
        pubkeys: [Pubkey; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            base_spot_market: pubkeys[0],
            quote_spot_market: pubkeys[1],
            state: pubkeys[2],
            phoenix_program: pubkeys[3],
            phoenix_market: pubkeys[4],
            drift_signer: pubkeys[5],
            phoenix_fulfillment_config: pubkeys[6],
            admin: pubkeys[7],
            rent: pubkeys[8],
            system_program: pubkeys[9],
        }
    }
}
impl<'info> From<InitializePhoenixFulfillmentConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializePhoenixFulfillmentConfigAccounts<'_, 'info>) -> Self {
        [
            accounts.base_spot_market.clone(),
            accounts.quote_spot_market.clone(),
            accounts.state.clone(),
            accounts.phoenix_program.clone(),
            accounts.phoenix_market.clone(),
            accounts.drift_signer.clone(),
            accounts.phoenix_fulfillment_config.clone(),
            accounts.admin.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN]>
for InitializePhoenixFulfillmentConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            base_spot_market: &arr[0],
            quote_spot_market: &arr[1],
            state: &arr[2],
            phoenix_program: &arr[3],
            phoenix_market: &arr[4],
            drift_signer: &arr[5],
            phoenix_fulfillment_config: &arr[6],
            admin: &arr[7],
            rent: &arr[8],
            system_program: &arr[9],
        }
    }
}
pub const INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_DISCM: [u8; 8] = [
    135,
    132,
    110,
    107,
    185,
    160,
    169,
    154,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializePhoenixFulfillmentConfigIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializePhoenixFulfillmentConfigIxData(
    pub InitializePhoenixFulfillmentConfigIxArgs,
);
impl From<InitializePhoenixFulfillmentConfigIxArgs>
for InitializePhoenixFulfillmentConfigIxData {
    fn from(args: InitializePhoenixFulfillmentConfigIxArgs) -> Self {
        Self(args)
    }
}
impl InitializePhoenixFulfillmentConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializePhoenixFulfillmentConfigIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_phoenix_fulfillment_config_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializePhoenixFulfillmentConfigKeys,
    args: InitializePhoenixFulfillmentConfigIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_PHOENIX_FULFILLMENT_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: InitializePhoenixFulfillmentConfigIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_phoenix_fulfillment_config_ix(
    keys: InitializePhoenixFulfillmentConfigKeys,
    args: InitializePhoenixFulfillmentConfigIxArgs,
) -> std::io::Result<Instruction> {
    initialize_phoenix_fulfillment_config_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_phoenix_fulfillment_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializePhoenixFulfillmentConfigAccounts<'_, '_>,
    args: InitializePhoenixFulfillmentConfigIxArgs,
) -> ProgramResult {
    let keys: InitializePhoenixFulfillmentConfigKeys = accounts.into();
    let ix = initialize_phoenix_fulfillment_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_phoenix_fulfillment_config_invoke(
    accounts: InitializePhoenixFulfillmentConfigAccounts<'_, '_>,
    args: InitializePhoenixFulfillmentConfigIxArgs,
) -> ProgramResult {
    initialize_phoenix_fulfillment_config_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn initialize_phoenix_fulfillment_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializePhoenixFulfillmentConfigAccounts<'_, '_>,
    args: InitializePhoenixFulfillmentConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializePhoenixFulfillmentConfigKeys = accounts.into();
    let ix = initialize_phoenix_fulfillment_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_phoenix_fulfillment_config_invoke_signed(
    accounts: InitializePhoenixFulfillmentConfigAccounts<'_, '_>,
    args: InitializePhoenixFulfillmentConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_phoenix_fulfillment_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_phoenix_fulfillment_config_verify_account_keys(
    accounts: InitializePhoenixFulfillmentConfigAccounts<'_, '_>,
    keys: InitializePhoenixFulfillmentConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.base_spot_market.key, keys.base_spot_market),
        (*accounts.quote_spot_market.key, keys.quote_spot_market),
        (*accounts.state.key, keys.state),
        (*accounts.phoenix_program.key, keys.phoenix_program),
        (*accounts.phoenix_market.key, keys.phoenix_market),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.phoenix_fulfillment_config.key, keys.phoenix_fulfillment_config),
        (*accounts.admin.key, keys.admin),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_phoenix_fulfillment_config_verify_writable_privileges<'me, 'info>(
    accounts: InitializePhoenixFulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.state,
        accounts.phoenix_fulfillment_config,
        accounts.admin,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_phoenix_fulfillment_config_verify_signer_privileges<'me, 'info>(
    accounts: InitializePhoenixFulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_phoenix_fulfillment_config_verify_account_privileges<'me, 'info>(
    accounts: InitializePhoenixFulfillmentConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_phoenix_fulfillment_config_verify_writable_privileges(accounts)?;
    initialize_phoenix_fulfillment_config_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct PhoenixFulfillmentConfigStatusAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub phoenix_fulfillment_config: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct PhoenixFulfillmentConfigStatusKeys {
    pub state: Pubkey,
    pub phoenix_fulfillment_config: Pubkey,
    pub admin: Pubkey,
}
impl From<PhoenixFulfillmentConfigStatusAccounts<'_, '_>>
for PhoenixFulfillmentConfigStatusKeys {
    fn from(accounts: PhoenixFulfillmentConfigStatusAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            phoenix_fulfillment_config: *accounts.phoenix_fulfillment_config.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<PhoenixFulfillmentConfigStatusKeys>
for [AccountMeta; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] {
    fn from(keys: PhoenixFulfillmentConfigStatusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.phoenix_fulfillment_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN]>
for PhoenixFulfillmentConfigStatusKeys {
    fn from(
        pubkeys: [Pubkey; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            phoenix_fulfillment_config: pubkeys[1],
            admin: pubkeys[2],
        }
    }
}
impl<'info> From<PhoenixFulfillmentConfigStatusAccounts<'_, 'info>>
for [AccountInfo<'info>; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: PhoenixFulfillmentConfigStatusAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.phoenix_fulfillment_config.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN]>
for PhoenixFulfillmentConfigStatusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            phoenix_fulfillment_config: &arr[1],
            admin: &arr[2],
        }
    }
}
pub const PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_DISCM: [u8; 8] = [
    96,
    31,
    113,
    32,
    12,
    203,
    7,
    154,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PhoenixFulfillmentConfigStatusIxArgs {
    pub status: SpotFulfillmentConfigStatus,
}
#[derive(Clone, Debug, PartialEq)]
pub struct PhoenixFulfillmentConfigStatusIxData(
    pub PhoenixFulfillmentConfigStatusIxArgs,
);
impl From<PhoenixFulfillmentConfigStatusIxArgs>
for PhoenixFulfillmentConfigStatusIxData {
    fn from(args: PhoenixFulfillmentConfigStatusIxArgs) -> Self {
        Self(args)
    }
}
impl PhoenixFulfillmentConfigStatusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(PhoenixFulfillmentConfigStatusIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn phoenix_fulfillment_config_status_ix_with_program_id(
    program_id: Pubkey,
    keys: PhoenixFulfillmentConfigStatusKeys,
    args: PhoenixFulfillmentConfigStatusIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; PHOENIX_FULFILLMENT_CONFIG_STATUS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: PhoenixFulfillmentConfigStatusIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn phoenix_fulfillment_config_status_ix(
    keys: PhoenixFulfillmentConfigStatusKeys,
    args: PhoenixFulfillmentConfigStatusIxArgs,
) -> std::io::Result<Instruction> {
    phoenix_fulfillment_config_status_ix_with_program_id(crate::ID, keys, args)
}
pub fn phoenix_fulfillment_config_status_invoke_with_program_id(
    program_id: Pubkey,
    accounts: PhoenixFulfillmentConfigStatusAccounts<'_, '_>,
    args: PhoenixFulfillmentConfigStatusIxArgs,
) -> ProgramResult {
    let keys: PhoenixFulfillmentConfigStatusKeys = accounts.into();
    let ix = phoenix_fulfillment_config_status_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn phoenix_fulfillment_config_status_invoke(
    accounts: PhoenixFulfillmentConfigStatusAccounts<'_, '_>,
    args: PhoenixFulfillmentConfigStatusIxArgs,
) -> ProgramResult {
    phoenix_fulfillment_config_status_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn phoenix_fulfillment_config_status_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: PhoenixFulfillmentConfigStatusAccounts<'_, '_>,
    args: PhoenixFulfillmentConfigStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: PhoenixFulfillmentConfigStatusKeys = accounts.into();
    let ix = phoenix_fulfillment_config_status_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn phoenix_fulfillment_config_status_invoke_signed(
    accounts: PhoenixFulfillmentConfigStatusAccounts<'_, '_>,
    args: PhoenixFulfillmentConfigStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    phoenix_fulfillment_config_status_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn phoenix_fulfillment_config_status_verify_account_keys(
    accounts: PhoenixFulfillmentConfigStatusAccounts<'_, '_>,
    keys: PhoenixFulfillmentConfigStatusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.phoenix_fulfillment_config.key, keys.phoenix_fulfillment_config),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn phoenix_fulfillment_config_status_verify_writable_privileges<'me, 'info>(
    accounts: PhoenixFulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.phoenix_fulfillment_config, accounts.admin] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn phoenix_fulfillment_config_status_verify_signer_privileges<'me, 'info>(
    accounts: PhoenixFulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn phoenix_fulfillment_config_status_verify_account_privileges<'me, 'info>(
    accounts: PhoenixFulfillmentConfigStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    phoenix_fulfillment_config_status_verify_writable_privileges(accounts)?;
    phoenix_fulfillment_config_status_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSerumVaultAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub srm_vault: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSerumVaultKeys {
    pub state: Pubkey,
    pub admin: Pubkey,
    pub srm_vault: Pubkey,
}
impl From<UpdateSerumVaultAccounts<'_, '_>> for UpdateSerumVaultKeys {
    fn from(accounts: UpdateSerumVaultAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            admin: *accounts.admin.key,
            srm_vault: *accounts.srm_vault.key,
        }
    }
}
impl From<UpdateSerumVaultKeys> for [AccountMeta; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSerumVaultKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.srm_vault,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN]> for UpdateSerumVaultKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            admin: pubkeys[1],
            srm_vault: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSerumVaultAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSerumVaultAccounts<'_, 'info>) -> Self {
        [accounts.state.clone(), accounts.admin.clone(), accounts.srm_vault.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN]>
for UpdateSerumVaultAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            admin: &arr[1],
            srm_vault: &arr[2],
        }
    }
}
pub const UPDATE_SERUM_VAULT_IX_DISCM: [u8; 8] = [219, 8, 246, 96, 169, 121, 91, 110];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSerumVaultIxData;
impl UpdateSerumVaultIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SERUM_VAULT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SERUM_VAULT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SERUM_VAULT_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_serum_vault_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSerumVaultKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SERUM_VAULT_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdateSerumVaultIxData.try_to_vec()?,
    })
}
pub fn update_serum_vault_ix(
    keys: UpdateSerumVaultKeys,
) -> std::io::Result<Instruction> {
    update_serum_vault_ix_with_program_id(crate::ID, keys)
}
pub fn update_serum_vault_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSerumVaultAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdateSerumVaultKeys = accounts.into();
    let ix = update_serum_vault_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_serum_vault_invoke(
    accounts: UpdateSerumVaultAccounts<'_, '_>,
) -> ProgramResult {
    update_serum_vault_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_serum_vault_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSerumVaultAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSerumVaultKeys = accounts.into();
    let ix = update_serum_vault_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_serum_vault_invoke_signed(
    accounts: UpdateSerumVaultAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_serum_vault_invoke_signed_with_program_id(crate::ID, accounts, seeds)
}
pub fn update_serum_vault_verify_account_keys(
    accounts: UpdateSerumVaultAccounts<'_, '_>,
    keys: UpdateSerumVaultKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.admin.key, keys.admin),
        (*accounts.srm_vault.key, keys.srm_vault),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_serum_vault_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSerumVaultAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state, accounts.admin] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_serum_vault_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSerumVaultAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_serum_vault_verify_account_privileges<'me, 'info>(
    accounts: UpdateSerumVaultAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_serum_vault_verify_writable_privileges(accounts)?;
    update_serum_vault_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct InitializePerpMarketAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializePerpMarketKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializePerpMarketAccounts<'_, '_>> for InitializePerpMarketKeys {
    fn from(accounts: InitializePerpMarketAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializePerpMarketKeys>
for [AccountMeta; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializePerpMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN]>
for InitializePerpMarketKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
            oracle: pubkeys[3],
            rent: pubkeys[4],
            system_program: pubkeys[5],
        }
    }
}
impl<'info> From<InitializePerpMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializePerpMarketAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN]>
for InitializePerpMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
            oracle: &arr[3],
            rent: &arr[4],
            system_program: &arr[5],
        }
    }
}
pub const INITIALIZE_PERP_MARKET_IX_DISCM: [u8; 8] = [
    132,
    9,
    229,
    118,
    117,
    118,
    117,
    62,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializePerpMarketIxArgs {
    pub market_index: u16,
    pub amm_base_asset_reserve: u128,
    pub amm_quote_asset_reserve: u128,
    pub amm_periodicity: i64,
    pub amm_peg_multiplier: u128,
    pub oracle_source: OracleSource,
    pub contract_tier: ContractTier,
    pub margin_ratio_initial: u32,
    pub margin_ratio_maintenance: u32,
    pub liquidator_fee: u32,
    pub if_liquidation_fee: u32,
    pub imf_factor: u32,
    pub active_status: bool,
    pub base_spread: u32,
    pub max_spread: u32,
    pub max_open_interest: u128,
    pub max_revenue_withdraw_per_period: u64,
    pub quote_max_insurance: u64,
    pub order_step_size: u64,
    pub order_tick_size: u64,
    pub min_order_size: u64,
    pub concentration_coef_scale: u128,
    pub curve_update_intensity: u8,
    pub amm_jit_intensity: u8,
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializePerpMarketIxData(pub InitializePerpMarketIxArgs);
impl From<InitializePerpMarketIxArgs> for InitializePerpMarketIxData {
    fn from(args: InitializePerpMarketIxArgs) -> Self {
        Self(args)
    }
}
impl InitializePerpMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_PERP_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_PERP_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializePerpMarketIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_PERP_MARKET_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_perp_market_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializePerpMarketKeys,
    args: InitializePerpMarketIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_PERP_MARKET_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitializePerpMarketIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_perp_market_ix(
    keys: InitializePerpMarketKeys,
    args: InitializePerpMarketIxArgs,
) -> std::io::Result<Instruction> {
    initialize_perp_market_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_perp_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializePerpMarketAccounts<'_, '_>,
    args: InitializePerpMarketIxArgs,
) -> ProgramResult {
    let keys: InitializePerpMarketKeys = accounts.into();
    let ix = initialize_perp_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_perp_market_invoke(
    accounts: InitializePerpMarketAccounts<'_, '_>,
    args: InitializePerpMarketIxArgs,
) -> ProgramResult {
    initialize_perp_market_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_perp_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializePerpMarketAccounts<'_, '_>,
    args: InitializePerpMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializePerpMarketKeys = accounts.into();
    let ix = initialize_perp_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_perp_market_invoke_signed(
    accounts: InitializePerpMarketAccounts<'_, '_>,
    args: InitializePerpMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_perp_market_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_perp_market_verify_account_keys(
    accounts: InitializePerpMarketAccounts<'_, '_>,
    keys: InitializePerpMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_perp_market_verify_writable_privileges<'me, 'info>(
    accounts: InitializePerpMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.state, accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_perp_market_verify_signer_privileges<'me, 'info>(
    accounts: InitializePerpMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_perp_market_verify_account_privileges<'me, 'info>(
    accounts: InitializePerpMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_perp_market_verify_writable_privileges(accounts)?;
    initialize_perp_market_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct InitializePredictionMarketAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializePredictionMarketKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<InitializePredictionMarketAccounts<'_, '_>>
for InitializePredictionMarketKeys {
    fn from(accounts: InitializePredictionMarketAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<InitializePredictionMarketKeys>
for [AccountMeta; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializePredictionMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN]>
for InitializePredictionMarketKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<InitializePredictionMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializePredictionMarketAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN]>
for InitializePredictionMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const INITIALIZE_PREDICTION_MARKET_IX_DISCM: [u8; 8] = [
    248,
    70,
    198,
    224,
    224,
    105,
    125,
    195,
];
#[derive(Clone, Debug, PartialEq)]
pub struct InitializePredictionMarketIxData;
impl InitializePredictionMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_PREDICTION_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_PREDICTION_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_PREDICTION_MARKET_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_prediction_market_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializePredictionMarketKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_PREDICTION_MARKET_IX_ACCOUNTS_LEN] = keys.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: InitializePredictionMarketIxData.try_to_vec()?,
    })
}
pub fn initialize_prediction_market_ix(
    keys: InitializePredictionMarketKeys,
) -> std::io::Result<Instruction> {
    initialize_prediction_market_ix_with_program_id(crate::ID, keys)
}
pub fn initialize_prediction_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializePredictionMarketAccounts<'_, '_>,
) -> ProgramResult {
    let keys: InitializePredictionMarketKeys = accounts.into();
    let ix = initialize_prediction_market_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_prediction_market_invoke(
    accounts: InitializePredictionMarketAccounts<'_, '_>,
) -> ProgramResult {
    initialize_prediction_market_invoke_with_program_id(crate::ID, accounts)
}
pub fn initialize_prediction_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializePredictionMarketAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializePredictionMarketKeys = accounts.into();
    let ix = initialize_prediction_market_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_prediction_market_invoke_signed(
    accounts: InitializePredictionMarketAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_prediction_market_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn initialize_prediction_market_verify_account_keys(
    accounts: InitializePredictionMarketAccounts<'_, '_>,
    keys: InitializePredictionMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_prediction_market_verify_writable_privileges<'me, 'info>(
    accounts: InitializePredictionMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_prediction_market_verify_signer_privileges<'me, 'info>(
    accounts: InitializePredictionMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_prediction_market_verify_account_privileges<'me, 'info>(
    accounts: InitializePredictionMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_prediction_market_verify_writable_privileges(accounts)?;
    initialize_prediction_market_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct DeleteInitializedPerpMarketAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DeleteInitializedPerpMarketKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<DeleteInitializedPerpMarketAccounts<'_, '_>>
for DeleteInitializedPerpMarketKeys {
    fn from(accounts: DeleteInitializedPerpMarketAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<DeleteInitializedPerpMarketKeys>
for [AccountMeta; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN] {
    fn from(keys: DeleteInitializedPerpMarketKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN]>
for DeleteInitializedPerpMarketKeys {
    fn from(pubkeys: [Pubkey; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<DeleteInitializedPerpMarketAccounts<'_, 'info>>
for [AccountInfo<'info>; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN] {
    fn from(accounts: DeleteInitializedPerpMarketAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN]>
for DeleteInitializedPerpMarketAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const DELETE_INITIALIZED_PERP_MARKET_IX_DISCM: [u8; 8] = [
    91,
    154,
    24,
    87,
    106,
    59,
    190,
    66,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DeleteInitializedPerpMarketIxArgs {
    pub market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DeleteInitializedPerpMarketIxData(pub DeleteInitializedPerpMarketIxArgs);
impl From<DeleteInitializedPerpMarketIxArgs> for DeleteInitializedPerpMarketIxData {
    fn from(args: DeleteInitializedPerpMarketIxArgs) -> Self {
        Self(args)
    }
}
impl DeleteInitializedPerpMarketIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DELETE_INITIALIZED_PERP_MARKET_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DELETE_INITIALIZED_PERP_MARKET_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DeleteInitializedPerpMarketIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DELETE_INITIALIZED_PERP_MARKET_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn delete_initialized_perp_market_ix_with_program_id(
    program_id: Pubkey,
    keys: DeleteInitializedPerpMarketKeys,
    args: DeleteInitializedPerpMarketIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DELETE_INITIALIZED_PERP_MARKET_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: DeleteInitializedPerpMarketIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn delete_initialized_perp_market_ix(
    keys: DeleteInitializedPerpMarketKeys,
    args: DeleteInitializedPerpMarketIxArgs,
) -> std::io::Result<Instruction> {
    delete_initialized_perp_market_ix_with_program_id(crate::ID, keys, args)
}
pub fn delete_initialized_perp_market_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DeleteInitializedPerpMarketAccounts<'_, '_>,
    args: DeleteInitializedPerpMarketIxArgs,
) -> ProgramResult {
    let keys: DeleteInitializedPerpMarketKeys = accounts.into();
    let ix = delete_initialized_perp_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn delete_initialized_perp_market_invoke(
    accounts: DeleteInitializedPerpMarketAccounts<'_, '_>,
    args: DeleteInitializedPerpMarketIxArgs,
) -> ProgramResult {
    delete_initialized_perp_market_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn delete_initialized_perp_market_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DeleteInitializedPerpMarketAccounts<'_, '_>,
    args: DeleteInitializedPerpMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DeleteInitializedPerpMarketKeys = accounts.into();
    let ix = delete_initialized_perp_market_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn delete_initialized_perp_market_invoke_signed(
    accounts: DeleteInitializedPerpMarketAccounts<'_, '_>,
    args: DeleteInitializedPerpMarketIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    delete_initialized_perp_market_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn delete_initialized_perp_market_verify_account_keys(
    accounts: DeleteInitializedPerpMarketAccounts<'_, '_>,
    keys: DeleteInitializedPerpMarketKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn delete_initialized_perp_market_verify_writable_privileges<'me, 'info>(
    accounts: DeleteInitializedPerpMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.state, accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn delete_initialized_perp_market_verify_signer_privileges<'me, 'info>(
    accounts: DeleteInitializedPerpMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn delete_initialized_perp_market_verify_account_privileges<'me, 'info>(
    accounts: DeleteInitializedPerpMarketAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    delete_initialized_perp_market_verify_writable_privileges(accounts)?;
    delete_initialized_perp_market_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const MOVE_AMM_PRICE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct MoveAmmPriceAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct MoveAmmPriceKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<MoveAmmPriceAccounts<'_, '_>> for MoveAmmPriceKeys {
    fn from(accounts: MoveAmmPriceAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<MoveAmmPriceKeys> for [AccountMeta; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN] {
    fn from(keys: MoveAmmPriceKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN]> for MoveAmmPriceKeys {
    fn from(pubkeys: [Pubkey; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<MoveAmmPriceAccounts<'_, 'info>>
for [AccountInfo<'info>; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN] {
    fn from(accounts: MoveAmmPriceAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN]>
for MoveAmmPriceAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const MOVE_AMM_PRICE_IX_DISCM: [u8; 8] = [235, 109, 2, 82, 219, 118, 6, 159];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MoveAmmPriceIxArgs {
    pub base_asset_reserve: u128,
    pub quote_asset_reserve: u128,
    pub sqrt_k: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct MoveAmmPriceIxData(pub MoveAmmPriceIxArgs);
impl From<MoveAmmPriceIxArgs> for MoveAmmPriceIxData {
    fn from(args: MoveAmmPriceIxArgs) -> Self {
        Self(args)
    }
}
impl MoveAmmPriceIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != MOVE_AMM_PRICE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        MOVE_AMM_PRICE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(MoveAmmPriceIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&MOVE_AMM_PRICE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn move_amm_price_ix_with_program_id(
    program_id: Pubkey,
    keys: MoveAmmPriceKeys,
    args: MoveAmmPriceIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; MOVE_AMM_PRICE_IX_ACCOUNTS_LEN] = keys.into();
    let data: MoveAmmPriceIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn move_amm_price_ix(
    keys: MoveAmmPriceKeys,
    args: MoveAmmPriceIxArgs,
) -> std::io::Result<Instruction> {
    move_amm_price_ix_with_program_id(crate::ID, keys, args)
}
pub fn move_amm_price_invoke_with_program_id(
    program_id: Pubkey,
    accounts: MoveAmmPriceAccounts<'_, '_>,
    args: MoveAmmPriceIxArgs,
) -> ProgramResult {
    let keys: MoveAmmPriceKeys = accounts.into();
    let ix = move_amm_price_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn move_amm_price_invoke(
    accounts: MoveAmmPriceAccounts<'_, '_>,
    args: MoveAmmPriceIxArgs,
) -> ProgramResult {
    move_amm_price_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn move_amm_price_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: MoveAmmPriceAccounts<'_, '_>,
    args: MoveAmmPriceIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: MoveAmmPriceKeys = accounts.into();
    let ix = move_amm_price_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn move_amm_price_invoke_signed(
    accounts: MoveAmmPriceAccounts<'_, '_>,
    args: MoveAmmPriceIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    move_amm_price_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn move_amm_price_verify_account_keys(
    accounts: MoveAmmPriceAccounts<'_, '_>,
    keys: MoveAmmPriceKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn move_amm_price_verify_writable_privileges<'me, 'info>(
    accounts: MoveAmmPriceAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn move_amm_price_verify_signer_privileges<'me, 'info>(
    accounts: MoveAmmPriceAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn move_amm_price_verify_account_privileges<'me, 'info>(
    accounts: MoveAmmPriceAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    move_amm_price_verify_writable_privileges(accounts)?;
    move_amm_price_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct RecenterPerpMarketAmmAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RecenterPerpMarketAmmKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<RecenterPerpMarketAmmAccounts<'_, '_>> for RecenterPerpMarketAmmKeys {
    fn from(accounts: RecenterPerpMarketAmmAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<RecenterPerpMarketAmmKeys>
for [AccountMeta; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN] {
    fn from(keys: RecenterPerpMarketAmmKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN]>
for RecenterPerpMarketAmmKeys {
    fn from(pubkeys: [Pubkey; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<RecenterPerpMarketAmmAccounts<'_, 'info>>
for [AccountInfo<'info>; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN] {
    fn from(accounts: RecenterPerpMarketAmmAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN]>
for RecenterPerpMarketAmmAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const RECENTER_PERP_MARKET_AMM_IX_DISCM: [u8; 8] = [
    24,
    87,
    10,
    115,
    165,
    190,
    80,
    139,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RecenterPerpMarketAmmIxArgs {
    pub peg_multiplier: u128,
    pub sqrt_k: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct RecenterPerpMarketAmmIxData(pub RecenterPerpMarketAmmIxArgs);
impl From<RecenterPerpMarketAmmIxArgs> for RecenterPerpMarketAmmIxData {
    fn from(args: RecenterPerpMarketAmmIxArgs) -> Self {
        Self(args)
    }
}
impl RecenterPerpMarketAmmIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != RECENTER_PERP_MARKET_AMM_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        RECENTER_PERP_MARKET_AMM_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(RecenterPerpMarketAmmIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&RECENTER_PERP_MARKET_AMM_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn recenter_perp_market_amm_ix_with_program_id(
    program_id: Pubkey,
    keys: RecenterPerpMarketAmmKeys,
    args: RecenterPerpMarketAmmIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; RECENTER_PERP_MARKET_AMM_IX_ACCOUNTS_LEN] = keys.into();
    let data: RecenterPerpMarketAmmIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn recenter_perp_market_amm_ix(
    keys: RecenterPerpMarketAmmKeys,
    args: RecenterPerpMarketAmmIxArgs,
) -> std::io::Result<Instruction> {
    recenter_perp_market_amm_ix_with_program_id(crate::ID, keys, args)
}
pub fn recenter_perp_market_amm_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RecenterPerpMarketAmmAccounts<'_, '_>,
    args: RecenterPerpMarketAmmIxArgs,
) -> ProgramResult {
    let keys: RecenterPerpMarketAmmKeys = accounts.into();
    let ix = recenter_perp_market_amm_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn recenter_perp_market_amm_invoke(
    accounts: RecenterPerpMarketAmmAccounts<'_, '_>,
    args: RecenterPerpMarketAmmIxArgs,
) -> ProgramResult {
    recenter_perp_market_amm_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn recenter_perp_market_amm_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RecenterPerpMarketAmmAccounts<'_, '_>,
    args: RecenterPerpMarketAmmIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RecenterPerpMarketAmmKeys = accounts.into();
    let ix = recenter_perp_market_amm_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn recenter_perp_market_amm_invoke_signed(
    accounts: RecenterPerpMarketAmmAccounts<'_, '_>,
    args: RecenterPerpMarketAmmIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    recenter_perp_market_amm_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn recenter_perp_market_amm_verify_account_keys(
    accounts: RecenterPerpMarketAmmAccounts<'_, '_>,
    keys: RecenterPerpMarketAmmKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn recenter_perp_market_amm_verify_writable_privileges<'me, 'info>(
    accounts: RecenterPerpMarketAmmAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn recenter_perp_market_amm_verify_signer_privileges<'me, 'info>(
    accounts: RecenterPerpMarketAmmAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn recenter_perp_market_amm_verify_account_privileges<'me, 'info>(
    accounts: RecenterPerpMarketAmmAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    recenter_perp_market_amm_verify_writable_privileges(accounts)?;
    recenter_perp_market_amm_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketAmmSummaryStatsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketAmmSummaryStatsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub spot_market: Pubkey,
    pub oracle: Pubkey,
}
impl From<UpdatePerpMarketAmmSummaryStatsAccounts<'_, '_>>
for UpdatePerpMarketAmmSummaryStatsKeys {
    fn from(accounts: UpdatePerpMarketAmmSummaryStatsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            spot_market: *accounts.spot_market.key,
            oracle: *accounts.oracle.key,
        }
    }
}
impl From<UpdatePerpMarketAmmSummaryStatsKeys>
for [AccountMeta; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketAmmSummaryStatsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketAmmSummaryStatsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
            spot_market: pubkeys[3],
            oracle: pubkeys[4],
        }
    }
}
impl<'info> From<UpdatePerpMarketAmmSummaryStatsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.spot_market.clone(),
            accounts.oracle.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketAmmSummaryStatsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
            spot_market: &arr[3],
            oracle: &arr[4],
        }
    }
}
pub const UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_DISCM: [u8; 8] = [
    122,
    101,
    249,
    238,
    209,
    9,
    241,
    245,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketAmmSummaryStatsIxArgs {
    pub params: UpdatePerpMarketSummaryStatsParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketAmmSummaryStatsIxData(
    pub UpdatePerpMarketAmmSummaryStatsIxArgs,
);
impl From<UpdatePerpMarketAmmSummaryStatsIxArgs>
for UpdatePerpMarketAmmSummaryStatsIxData {
    fn from(args: UpdatePerpMarketAmmSummaryStatsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketAmmSummaryStatsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketAmmSummaryStatsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_amm_summary_stats_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketAmmSummaryStatsKeys,
    args: UpdatePerpMarketAmmSummaryStatsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_AMM_SUMMARY_STATS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketAmmSummaryStatsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_amm_summary_stats_ix(
    keys: UpdatePerpMarketAmmSummaryStatsKeys,
    args: UpdatePerpMarketAmmSummaryStatsIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_amm_summary_stats_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_amm_summary_stats_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'_, '_>,
    args: UpdatePerpMarketAmmSummaryStatsIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketAmmSummaryStatsKeys = accounts.into();
    let ix = update_perp_market_amm_summary_stats_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_amm_summary_stats_invoke(
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'_, '_>,
    args: UpdatePerpMarketAmmSummaryStatsIxArgs,
) -> ProgramResult {
    update_perp_market_amm_summary_stats_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_amm_summary_stats_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'_, '_>,
    args: UpdatePerpMarketAmmSummaryStatsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketAmmSummaryStatsKeys = accounts.into();
    let ix = update_perp_market_amm_summary_stats_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_amm_summary_stats_invoke_signed(
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'_, '_>,
    args: UpdatePerpMarketAmmSummaryStatsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_amm_summary_stats_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_amm_summary_stats_verify_account_keys(
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'_, '_>,
    keys: UpdatePerpMarketAmmSummaryStatsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.oracle.key, keys.oracle),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_amm_summary_stats_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_amm_summary_stats_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_amm_summary_stats_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketAmmSummaryStatsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_amm_summary_stats_verify_writable_privileges(accounts)?;
    update_perp_market_amm_summary_stats_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketExpiryAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketExpiryKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketExpiryAccounts<'_, '_>> for UpdatePerpMarketExpiryKeys {
    fn from(accounts: UpdatePerpMarketExpiryAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketExpiryKeys>
for [AccountMeta; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketExpiryKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketExpiryKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketExpiryAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketExpiryAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketExpiryAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_EXPIRY_IX_DISCM: [u8; 8] = [
    44,
    221,
    227,
    151,
    131,
    140,
    22,
    110,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketExpiryIxArgs {
    pub expiry_ts: i64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketExpiryIxData(pub UpdatePerpMarketExpiryIxArgs);
impl From<UpdatePerpMarketExpiryIxArgs> for UpdatePerpMarketExpiryIxData {
    fn from(args: UpdatePerpMarketExpiryIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketExpiryIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_EXPIRY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_EXPIRY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketExpiryIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_EXPIRY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_expiry_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketExpiryKeys,
    args: UpdatePerpMarketExpiryIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_EXPIRY_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpMarketExpiryIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_expiry_ix(
    keys: UpdatePerpMarketExpiryKeys,
    args: UpdatePerpMarketExpiryIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_expiry_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_expiry_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketExpiryAccounts<'_, '_>,
    args: UpdatePerpMarketExpiryIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketExpiryKeys = accounts.into();
    let ix = update_perp_market_expiry_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_expiry_invoke(
    accounts: UpdatePerpMarketExpiryAccounts<'_, '_>,
    args: UpdatePerpMarketExpiryIxArgs,
) -> ProgramResult {
    update_perp_market_expiry_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_expiry_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketExpiryAccounts<'_, '_>,
    args: UpdatePerpMarketExpiryIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketExpiryKeys = accounts.into();
    let ix = update_perp_market_expiry_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_expiry_invoke_signed(
    accounts: UpdatePerpMarketExpiryAccounts<'_, '_>,
    args: UpdatePerpMarketExpiryIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_expiry_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_expiry_verify_account_keys(
    accounts: UpdatePerpMarketExpiryAccounts<'_, '_>,
    keys: UpdatePerpMarketExpiryKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_expiry_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketExpiryAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_expiry_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketExpiryAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_expiry_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketExpiryAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_expiry_verify_writable_privileges(accounts)?;
    update_perp_market_expiry_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct SettleExpiredMarketPoolsToRevenuePoolAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct SettleExpiredMarketPoolsToRevenuePoolKeys {
    pub state: Pubkey,
    pub admin: Pubkey,
    pub spot_market: Pubkey,
    pub perp_market: Pubkey,
}
impl From<SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, '_>>
for SettleExpiredMarketPoolsToRevenuePoolKeys {
    fn from(accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            admin: *accounts.admin.key,
            spot_market: *accounts.spot_market.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<SettleExpiredMarketPoolsToRevenuePoolKeys>
for [AccountMeta; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN] {
    fn from(keys: SettleExpiredMarketPoolsToRevenuePoolKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN]>
for SettleExpiredMarketPoolsToRevenuePoolKeys {
    fn from(
        pubkeys: [Pubkey; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            admin: pubkeys[1],
            spot_market: pubkeys[2],
            perp_market: pubkeys[3],
        }
    }
}
impl<'info> From<SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, 'info>>
for [AccountInfo<'info>; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN] {
    fn from(accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.admin.clone(),
            accounts.spot_market.clone(),
            accounts.perp_market.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<
        'info,
    >; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN],
> for SettleExpiredMarketPoolsToRevenuePoolAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            admin: &arr[1],
            spot_market: &arr[2],
            perp_market: &arr[3],
        }
    }
}
pub const SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_DISCM: [u8; 8] = [
    55,
    19,
    238,
    169,
    227,
    90,
    200,
    184,
];
#[derive(Clone, Debug, PartialEq)]
pub struct SettleExpiredMarketPoolsToRevenuePoolIxData;
impl SettleExpiredMarketPoolsToRevenuePoolIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn settle_expired_market_pools_to_revenue_pool_ix_with_program_id(
    program_id: Pubkey,
    keys: SettleExpiredMarketPoolsToRevenuePoolKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; SETTLE_EXPIRED_MARKET_POOLS_TO_REVENUE_POOL_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: SettleExpiredMarketPoolsToRevenuePoolIxData.try_to_vec()?,
    })
}
pub fn settle_expired_market_pools_to_revenue_pool_ix(
    keys: SettleExpiredMarketPoolsToRevenuePoolKeys,
) -> std::io::Result<Instruction> {
    settle_expired_market_pools_to_revenue_pool_ix_with_program_id(crate::ID, keys)
}
pub fn settle_expired_market_pools_to_revenue_pool_invoke_with_program_id(
    program_id: Pubkey,
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, '_>,
) -> ProgramResult {
    let keys: SettleExpiredMarketPoolsToRevenuePoolKeys = accounts.into();
    let ix = settle_expired_market_pools_to_revenue_pool_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn settle_expired_market_pools_to_revenue_pool_invoke(
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, '_>,
) -> ProgramResult {
    settle_expired_market_pools_to_revenue_pool_invoke_with_program_id(
        crate::ID,
        accounts,
    )
}
pub fn settle_expired_market_pools_to_revenue_pool_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: SettleExpiredMarketPoolsToRevenuePoolKeys = accounts.into();
    let ix = settle_expired_market_pools_to_revenue_pool_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn settle_expired_market_pools_to_revenue_pool_invoke_signed(
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    settle_expired_market_pools_to_revenue_pool_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn settle_expired_market_pools_to_revenue_pool_verify_account_keys(
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'_, '_>,
    keys: SettleExpiredMarketPoolsToRevenuePoolKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.admin.key, keys.admin),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn settle_expired_market_pools_to_revenue_pool_verify_writable_privileges<
    'me,
    'info,
>(
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market, accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn settle_expired_market_pools_to_revenue_pool_verify_signer_privileges<'me, 'info>(
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn settle_expired_market_pools_to_revenue_pool_verify_account_privileges<'me, 'info>(
    accounts: SettleExpiredMarketPoolsToRevenuePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    settle_expired_market_pools_to_revenue_pool_verify_writable_privileges(accounts)?;
    settle_expired_market_pools_to_revenue_pool_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN: usize = 8;
#[derive(Copy, Clone, Debug)]
pub struct DepositIntoPerpMarketFeePoolAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub source_vault: &'me AccountInfo<'info>,
    pub drift_signer: &'me AccountInfo<'info>,
    pub quote_spot_market: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DepositIntoPerpMarketFeePoolKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub admin: Pubkey,
    pub source_vault: Pubkey,
    pub drift_signer: Pubkey,
    pub quote_spot_market: Pubkey,
    pub spot_market_vault: Pubkey,
    pub token_program: Pubkey,
}
impl From<DepositIntoPerpMarketFeePoolAccounts<'_, '_>>
for DepositIntoPerpMarketFeePoolKeys {
    fn from(accounts: DepositIntoPerpMarketFeePoolAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            admin: *accounts.admin.key,
            source_vault: *accounts.source_vault.key,
            drift_signer: *accounts.drift_signer.key,
            quote_spot_market: *accounts.quote_spot_market.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<DepositIntoPerpMarketFeePoolKeys>
for [AccountMeta; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN] {
    fn from(keys: DepositIntoPerpMarketFeePoolKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.source_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.drift_signer,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.quote_spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN]>
for DepositIntoPerpMarketFeePoolKeys {
    fn from(
        pubkeys: [Pubkey; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            admin: pubkeys[2],
            source_vault: pubkeys[3],
            drift_signer: pubkeys[4],
            quote_spot_market: pubkeys[5],
            spot_market_vault: pubkeys[6],
            token_program: pubkeys[7],
        }
    }
}
impl<'info> From<DepositIntoPerpMarketFeePoolAccounts<'_, 'info>>
for [AccountInfo<'info>; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN] {
    fn from(accounts: DepositIntoPerpMarketFeePoolAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.admin.clone(),
            accounts.source_vault.clone(),
            accounts.drift_signer.clone(),
            accounts.quote_spot_market.clone(),
            accounts.spot_market_vault.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN]>
for DepositIntoPerpMarketFeePoolAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            admin: &arr[2],
            source_vault: &arr[3],
            drift_signer: &arr[4],
            quote_spot_market: &arr[5],
            spot_market_vault: &arr[6],
            token_program: &arr[7],
        }
    }
}
pub const DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_DISCM: [u8; 8] = [
    34,
    58,
    57,
    68,
    97,
    80,
    244,
    6,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DepositIntoPerpMarketFeePoolIxArgs {
    pub amount: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DepositIntoPerpMarketFeePoolIxData(pub DepositIntoPerpMarketFeePoolIxArgs);
impl From<DepositIntoPerpMarketFeePoolIxArgs> for DepositIntoPerpMarketFeePoolIxData {
    fn from(args: DepositIntoPerpMarketFeePoolIxArgs) -> Self {
        Self(args)
    }
}
impl DepositIntoPerpMarketFeePoolIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DepositIntoPerpMarketFeePoolIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn deposit_into_perp_market_fee_pool_ix_with_program_id(
    program_id: Pubkey,
    keys: DepositIntoPerpMarketFeePoolKeys,
    args: DepositIntoPerpMarketFeePoolIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DEPOSIT_INTO_PERP_MARKET_FEE_POOL_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: DepositIntoPerpMarketFeePoolIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn deposit_into_perp_market_fee_pool_ix(
    keys: DepositIntoPerpMarketFeePoolKeys,
    args: DepositIntoPerpMarketFeePoolIxArgs,
) -> std::io::Result<Instruction> {
    deposit_into_perp_market_fee_pool_ix_with_program_id(crate::ID, keys, args)
}
pub fn deposit_into_perp_market_fee_pool_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DepositIntoPerpMarketFeePoolAccounts<'_, '_>,
    args: DepositIntoPerpMarketFeePoolIxArgs,
) -> ProgramResult {
    let keys: DepositIntoPerpMarketFeePoolKeys = accounts.into();
    let ix = deposit_into_perp_market_fee_pool_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn deposit_into_perp_market_fee_pool_invoke(
    accounts: DepositIntoPerpMarketFeePoolAccounts<'_, '_>,
    args: DepositIntoPerpMarketFeePoolIxArgs,
) -> ProgramResult {
    deposit_into_perp_market_fee_pool_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn deposit_into_perp_market_fee_pool_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DepositIntoPerpMarketFeePoolAccounts<'_, '_>,
    args: DepositIntoPerpMarketFeePoolIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DepositIntoPerpMarketFeePoolKeys = accounts.into();
    let ix = deposit_into_perp_market_fee_pool_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn deposit_into_perp_market_fee_pool_invoke_signed(
    accounts: DepositIntoPerpMarketFeePoolAccounts<'_, '_>,
    args: DepositIntoPerpMarketFeePoolIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    deposit_into_perp_market_fee_pool_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn deposit_into_perp_market_fee_pool_verify_account_keys(
    accounts: DepositIntoPerpMarketFeePoolAccounts<'_, '_>,
    keys: DepositIntoPerpMarketFeePoolKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.admin.key, keys.admin),
        (*accounts.source_vault.key, keys.source_vault),
        (*accounts.drift_signer.key, keys.drift_signer),
        (*accounts.quote_spot_market.key, keys.quote_spot_market),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn deposit_into_perp_market_fee_pool_verify_writable_privileges<'me, 'info>(
    accounts: DepositIntoPerpMarketFeePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.state,
        accounts.perp_market,
        accounts.source_vault,
        accounts.quote_spot_market,
        accounts.spot_market_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn deposit_into_perp_market_fee_pool_verify_signer_privileges<'me, 'info>(
    accounts: DepositIntoPerpMarketFeePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn deposit_into_perp_market_fee_pool_verify_account_privileges<'me, 'info>(
    accounts: DepositIntoPerpMarketFeePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    deposit_into_perp_market_fee_pool_verify_writable_privileges(accounts)?;
    deposit_into_perp_market_fee_pool_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct DepositIntoSpotMarketVaultAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
    pub source_vault: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DepositIntoSpotMarketVaultKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub admin: Pubkey,
    pub source_vault: Pubkey,
    pub spot_market_vault: Pubkey,
    pub token_program: Pubkey,
}
impl From<DepositIntoSpotMarketVaultAccounts<'_, '_>>
for DepositIntoSpotMarketVaultKeys {
    fn from(accounts: DepositIntoSpotMarketVaultAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            admin: *accounts.admin.key,
            source_vault: *accounts.source_vault.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<DepositIntoSpotMarketVaultKeys>
for [AccountMeta; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN] {
    fn from(keys: DepositIntoSpotMarketVaultKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.source_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN]>
for DepositIntoSpotMarketVaultKeys {
    fn from(pubkeys: [Pubkey; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            admin: pubkeys[2],
            source_vault: pubkeys[3],
            spot_market_vault: pubkeys[4],
            token_program: pubkeys[5],
        }
    }
}
impl<'info> From<DepositIntoSpotMarketVaultAccounts<'_, 'info>>
for [AccountInfo<'info>; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN] {
    fn from(accounts: DepositIntoSpotMarketVaultAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.admin.clone(),
            accounts.source_vault.clone(),
            accounts.spot_market_vault.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN]>
for DepositIntoSpotMarketVaultAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            admin: &arr[2],
            source_vault: &arr[3],
            spot_market_vault: &arr[4],
            token_program: &arr[5],
        }
    }
}
pub const DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_DISCM: [u8; 8] = [
    48,
    252,
    119,
    73,
    255,
    205,
    174,
    247,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DepositIntoSpotMarketVaultIxArgs {
    pub amount: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DepositIntoSpotMarketVaultIxData(pub DepositIntoSpotMarketVaultIxArgs);
impl From<DepositIntoSpotMarketVaultIxArgs> for DepositIntoSpotMarketVaultIxData {
    fn from(args: DepositIntoSpotMarketVaultIxArgs) -> Self {
        Self(args)
    }
}
impl DepositIntoSpotMarketVaultIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DepositIntoSpotMarketVaultIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn deposit_into_spot_market_vault_ix_with_program_id(
    program_id: Pubkey,
    keys: DepositIntoSpotMarketVaultKeys,
    args: DepositIntoSpotMarketVaultIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DEPOSIT_INTO_SPOT_MARKET_VAULT_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: DepositIntoSpotMarketVaultIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn deposit_into_spot_market_vault_ix(
    keys: DepositIntoSpotMarketVaultKeys,
    args: DepositIntoSpotMarketVaultIxArgs,
) -> std::io::Result<Instruction> {
    deposit_into_spot_market_vault_ix_with_program_id(crate::ID, keys, args)
}
pub fn deposit_into_spot_market_vault_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DepositIntoSpotMarketVaultAccounts<'_, '_>,
    args: DepositIntoSpotMarketVaultIxArgs,
) -> ProgramResult {
    let keys: DepositIntoSpotMarketVaultKeys = accounts.into();
    let ix = deposit_into_spot_market_vault_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn deposit_into_spot_market_vault_invoke(
    accounts: DepositIntoSpotMarketVaultAccounts<'_, '_>,
    args: DepositIntoSpotMarketVaultIxArgs,
) -> ProgramResult {
    deposit_into_spot_market_vault_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn deposit_into_spot_market_vault_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DepositIntoSpotMarketVaultAccounts<'_, '_>,
    args: DepositIntoSpotMarketVaultIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DepositIntoSpotMarketVaultKeys = accounts.into();
    let ix = deposit_into_spot_market_vault_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn deposit_into_spot_market_vault_invoke_signed(
    accounts: DepositIntoSpotMarketVaultAccounts<'_, '_>,
    args: DepositIntoSpotMarketVaultIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    deposit_into_spot_market_vault_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn deposit_into_spot_market_vault_verify_account_keys(
    accounts: DepositIntoSpotMarketVaultAccounts<'_, '_>,
    keys: DepositIntoSpotMarketVaultKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.admin.key, keys.admin),
        (*accounts.source_vault.key, keys.source_vault),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn deposit_into_spot_market_vault_verify_writable_privileges<'me, 'info>(
    accounts: DepositIntoSpotMarketVaultAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.source_vault,
        accounts.spot_market_vault,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn deposit_into_spot_market_vault_verify_signer_privileges<'me, 'info>(
    accounts: DepositIntoSpotMarketVaultAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn deposit_into_spot_market_vault_verify_account_privileges<'me, 'info>(
    accounts: DepositIntoSpotMarketVaultAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    deposit_into_spot_market_vault_verify_writable_privileges(accounts)?;
    deposit_into_spot_market_vault_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN: usize = 6;
#[derive(Copy, Clone, Debug)]
pub struct DepositIntoSpotMarketRevenuePoolAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub authority: &'me AccountInfo<'info>,
    pub spot_market_vault: &'me AccountInfo<'info>,
    pub user_token_account: &'me AccountInfo<'info>,
    pub token_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DepositIntoSpotMarketRevenuePoolKeys {
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub authority: Pubkey,
    pub spot_market_vault: Pubkey,
    pub user_token_account: Pubkey,
    pub token_program: Pubkey,
}
impl From<DepositIntoSpotMarketRevenuePoolAccounts<'_, '_>>
for DepositIntoSpotMarketRevenuePoolKeys {
    fn from(accounts: DepositIntoSpotMarketRevenuePoolAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            authority: *accounts.authority.key,
            spot_market_vault: *accounts.spot_market_vault.key,
            user_token_account: *accounts.user_token_account.key,
            token_program: *accounts.token_program.key,
        }
    }
}
impl From<DepositIntoSpotMarketRevenuePoolKeys>
for [AccountMeta; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN] {
    fn from(keys: DepositIntoSpotMarketRevenuePoolKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.authority,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.spot_market_vault,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_token_account,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.token_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN]>
for DepositIntoSpotMarketRevenuePoolKeys {
    fn from(
        pubkeys: [Pubkey; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            spot_market: pubkeys[1],
            authority: pubkeys[2],
            spot_market_vault: pubkeys[3],
            user_token_account: pubkeys[4],
            token_program: pubkeys[5],
        }
    }
}
impl<'info> From<DepositIntoSpotMarketRevenuePoolAccounts<'_, 'info>>
for [AccountInfo<'info>; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN] {
    fn from(accounts: DepositIntoSpotMarketRevenuePoolAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.authority.clone(),
            accounts.spot_market_vault.clone(),
            accounts.user_token_account.clone(),
            accounts.token_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN]>
for DepositIntoSpotMarketRevenuePoolAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            spot_market: &arr[1],
            authority: &arr[2],
            spot_market_vault: &arr[3],
            user_token_account: &arr[4],
            token_program: &arr[5],
        }
    }
}
pub const DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_DISCM: [u8; 8] = [
    92,
    40,
    151,
    42,
    122,
    254,
    139,
    246,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DepositIntoSpotMarketRevenuePoolIxArgs {
    pub amount: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DepositIntoSpotMarketRevenuePoolIxData(
    pub DepositIntoSpotMarketRevenuePoolIxArgs,
);
impl From<DepositIntoSpotMarketRevenuePoolIxArgs>
for DepositIntoSpotMarketRevenuePoolIxData {
    fn from(args: DepositIntoSpotMarketRevenuePoolIxArgs) -> Self {
        Self(args)
    }
}
impl DepositIntoSpotMarketRevenuePoolIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DepositIntoSpotMarketRevenuePoolIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn deposit_into_spot_market_revenue_pool_ix_with_program_id(
    program_id: Pubkey,
    keys: DepositIntoSpotMarketRevenuePoolKeys,
    args: DepositIntoSpotMarketRevenuePoolIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DEPOSIT_INTO_SPOT_MARKET_REVENUE_POOL_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: DepositIntoSpotMarketRevenuePoolIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn deposit_into_spot_market_revenue_pool_ix(
    keys: DepositIntoSpotMarketRevenuePoolKeys,
    args: DepositIntoSpotMarketRevenuePoolIxArgs,
) -> std::io::Result<Instruction> {
    deposit_into_spot_market_revenue_pool_ix_with_program_id(crate::ID, keys, args)
}
pub fn deposit_into_spot_market_revenue_pool_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'_, '_>,
    args: DepositIntoSpotMarketRevenuePoolIxArgs,
) -> ProgramResult {
    let keys: DepositIntoSpotMarketRevenuePoolKeys = accounts.into();
    let ix = deposit_into_spot_market_revenue_pool_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn deposit_into_spot_market_revenue_pool_invoke(
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'_, '_>,
    args: DepositIntoSpotMarketRevenuePoolIxArgs,
) -> ProgramResult {
    deposit_into_spot_market_revenue_pool_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn deposit_into_spot_market_revenue_pool_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'_, '_>,
    args: DepositIntoSpotMarketRevenuePoolIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DepositIntoSpotMarketRevenuePoolKeys = accounts.into();
    let ix = deposit_into_spot_market_revenue_pool_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn deposit_into_spot_market_revenue_pool_invoke_signed(
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'_, '_>,
    args: DepositIntoSpotMarketRevenuePoolIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    deposit_into_spot_market_revenue_pool_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn deposit_into_spot_market_revenue_pool_verify_account_keys(
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'_, '_>,
    keys: DepositIntoSpotMarketRevenuePoolKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.authority.key, keys.authority),
        (*accounts.spot_market_vault.key, keys.spot_market_vault),
        (*accounts.user_token_account.key, keys.user_token_account),
        (*accounts.token_program.key, keys.token_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn deposit_into_spot_market_revenue_pool_verify_writable_privileges<'me, 'info>(
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.spot_market,
        accounts.authority,
        accounts.spot_market_vault,
        accounts.user_token_account,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn deposit_into_spot_market_revenue_pool_verify_signer_privileges<'me, 'info>(
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.authority] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn deposit_into_spot_market_revenue_pool_verify_account_privileges<'me, 'info>(
    accounts: DepositIntoSpotMarketRevenuePoolAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    deposit_into_spot_market_revenue_pool_verify_writable_privileges(accounts)?;
    deposit_into_spot_market_revenue_pool_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const REPEG_AMM_CURVE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct RepegAmmCurveAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct RepegAmmCurveKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
    pub admin: Pubkey,
}
impl From<RepegAmmCurveAccounts<'_, '_>> for RepegAmmCurveKeys {
    fn from(accounts: RepegAmmCurveAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<RepegAmmCurveKeys> for [AccountMeta; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN] {
    fn from(keys: RepegAmmCurveKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN]> for RepegAmmCurveKeys {
    fn from(pubkeys: [Pubkey; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
            admin: pubkeys[3],
        }
    }
}
impl<'info> From<RepegAmmCurveAccounts<'_, 'info>>
for [AccountInfo<'info>; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN] {
    fn from(accounts: RepegAmmCurveAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN]>
for RepegAmmCurveAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
            admin: &arr[3],
        }
    }
}
pub const REPEG_AMM_CURVE_IX_DISCM: [u8; 8] = [3, 36, 102, 89, 180, 128, 120, 213];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RepegAmmCurveIxArgs {
    pub new_peg_candidate: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct RepegAmmCurveIxData(pub RepegAmmCurveIxArgs);
impl From<RepegAmmCurveIxArgs> for RepegAmmCurveIxData {
    fn from(args: RepegAmmCurveIxArgs) -> Self {
        Self(args)
    }
}
impl RepegAmmCurveIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != REPEG_AMM_CURVE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        REPEG_AMM_CURVE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(RepegAmmCurveIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&REPEG_AMM_CURVE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn repeg_amm_curve_ix_with_program_id(
    program_id: Pubkey,
    keys: RepegAmmCurveKeys,
    args: RepegAmmCurveIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; REPEG_AMM_CURVE_IX_ACCOUNTS_LEN] = keys.into();
    let data: RepegAmmCurveIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn repeg_amm_curve_ix(
    keys: RepegAmmCurveKeys,
    args: RepegAmmCurveIxArgs,
) -> std::io::Result<Instruction> {
    repeg_amm_curve_ix_with_program_id(crate::ID, keys, args)
}
pub fn repeg_amm_curve_invoke_with_program_id(
    program_id: Pubkey,
    accounts: RepegAmmCurveAccounts<'_, '_>,
    args: RepegAmmCurveIxArgs,
) -> ProgramResult {
    let keys: RepegAmmCurveKeys = accounts.into();
    let ix = repeg_amm_curve_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn repeg_amm_curve_invoke(
    accounts: RepegAmmCurveAccounts<'_, '_>,
    args: RepegAmmCurveIxArgs,
) -> ProgramResult {
    repeg_amm_curve_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn repeg_amm_curve_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: RepegAmmCurveAccounts<'_, '_>,
    args: RepegAmmCurveIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: RepegAmmCurveKeys = accounts.into();
    let ix = repeg_amm_curve_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn repeg_amm_curve_invoke_signed(
    accounts: RepegAmmCurveAccounts<'_, '_>,
    args: RepegAmmCurveIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    repeg_amm_curve_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn repeg_amm_curve_verify_account_keys(
    accounts: RepegAmmCurveAccounts<'_, '_>,
    keys: RepegAmmCurveKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn repeg_amm_curve_verify_writable_privileges<'me, 'info>(
    accounts: RepegAmmCurveAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn repeg_amm_curve_verify_signer_privileges<'me, 'info>(
    accounts: RepegAmmCurveAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn repeg_amm_curve_verify_account_privileges<'me, 'info>(
    accounts: RepegAmmCurveAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    repeg_amm_curve_verify_writable_privileges(accounts)?;
    repeg_amm_curve_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketAmmOracleTwapAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketAmmOracleTwapKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
    pub admin: Pubkey,
}
impl From<UpdatePerpMarketAmmOracleTwapAccounts<'_, '_>>
for UpdatePerpMarketAmmOracleTwapKeys {
    fn from(accounts: UpdatePerpMarketAmmOracleTwapAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<UpdatePerpMarketAmmOracleTwapKeys>
for [AccountMeta; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketAmmOracleTwapKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketAmmOracleTwapKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
            admin: pubkeys[3],
        }
    }
}
impl<'info> From<UpdatePerpMarketAmmOracleTwapAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketAmmOracleTwapAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketAmmOracleTwapAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
            admin: &arr[3],
        }
    }
}
pub const UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM: [u8; 8] = [
    241,
    74,
    114,
    123,
    206,
    153,
    24,
    202,
];
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketAmmOracleTwapIxData;
impl UpdatePerpMarketAmmOracleTwapIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_amm_oracle_twap_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketAmmOracleTwapKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: UpdatePerpMarketAmmOracleTwapIxData.try_to_vec()?,
    })
}
pub fn update_perp_market_amm_oracle_twap_ix(
    keys: UpdatePerpMarketAmmOracleTwapKeys,
) -> std::io::Result<Instruction> {
    update_perp_market_amm_oracle_twap_ix_with_program_id(crate::ID, keys)
}
pub fn update_perp_market_amm_oracle_twap_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'_, '_>,
) -> ProgramResult {
    let keys: UpdatePerpMarketAmmOracleTwapKeys = accounts.into();
    let ix = update_perp_market_amm_oracle_twap_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_amm_oracle_twap_invoke(
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'_, '_>,
) -> ProgramResult {
    update_perp_market_amm_oracle_twap_invoke_with_program_id(crate::ID, accounts)
}
pub fn update_perp_market_amm_oracle_twap_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketAmmOracleTwapKeys = accounts.into();
    let ix = update_perp_market_amm_oracle_twap_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_amm_oracle_twap_invoke_signed(
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_amm_oracle_twap_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn update_perp_market_amm_oracle_twap_verify_account_keys(
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'_, '_>,
    keys: UpdatePerpMarketAmmOracleTwapKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_amm_oracle_twap_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_amm_oracle_twap_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_amm_oracle_twap_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketAmmOracleTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_amm_oracle_twap_verify_writable_privileges(accounts)?;
    update_perp_market_amm_oracle_twap_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct ResetPerpMarketAmmOracleTwapAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct ResetPerpMarketAmmOracleTwapKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
    pub admin: Pubkey,
}
impl From<ResetPerpMarketAmmOracleTwapAccounts<'_, '_>>
for ResetPerpMarketAmmOracleTwapKeys {
    fn from(accounts: ResetPerpMarketAmmOracleTwapAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<ResetPerpMarketAmmOracleTwapKeys>
for [AccountMeta; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN] {
    fn from(keys: ResetPerpMarketAmmOracleTwapKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN]>
for ResetPerpMarketAmmOracleTwapKeys {
    fn from(
        pubkeys: [Pubkey; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
            admin: pubkeys[3],
        }
    }
}
impl<'info> From<ResetPerpMarketAmmOracleTwapAccounts<'_, 'info>>
for [AccountInfo<'info>; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN] {
    fn from(accounts: ResetPerpMarketAmmOracleTwapAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN]>
for ResetPerpMarketAmmOracleTwapAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
            admin: &arr[3],
        }
    }
}
pub const RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM: [u8; 8] = [
    127,
    10,
    55,
    164,
    123,
    226,
    47,
    24,
];
#[derive(Clone, Debug, PartialEq)]
pub struct ResetPerpMarketAmmOracleTwapIxData;
impl ResetPerpMarketAmmOracleTwapIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn reset_perp_market_amm_oracle_twap_ix_with_program_id(
    program_id: Pubkey,
    keys: ResetPerpMarketAmmOracleTwapKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; RESET_PERP_MARKET_AMM_ORACLE_TWAP_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: ResetPerpMarketAmmOracleTwapIxData.try_to_vec()?,
    })
}
pub fn reset_perp_market_amm_oracle_twap_ix(
    keys: ResetPerpMarketAmmOracleTwapKeys,
) -> std::io::Result<Instruction> {
    reset_perp_market_amm_oracle_twap_ix_with_program_id(crate::ID, keys)
}
pub fn reset_perp_market_amm_oracle_twap_invoke_with_program_id(
    program_id: Pubkey,
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'_, '_>,
) -> ProgramResult {
    let keys: ResetPerpMarketAmmOracleTwapKeys = accounts.into();
    let ix = reset_perp_market_amm_oracle_twap_ix_with_program_id(program_id, keys)?;
    invoke_instruction(&ix, accounts)
}
pub fn reset_perp_market_amm_oracle_twap_invoke(
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'_, '_>,
) -> ProgramResult {
    reset_perp_market_amm_oracle_twap_invoke_with_program_id(crate::ID, accounts)
}
pub fn reset_perp_market_amm_oracle_twap_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: ResetPerpMarketAmmOracleTwapKeys = accounts.into();
    let ix = reset_perp_market_amm_oracle_twap_ix_with_program_id(program_id, keys)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn reset_perp_market_amm_oracle_twap_invoke_signed(
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    reset_perp_market_amm_oracle_twap_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn reset_perp_market_amm_oracle_twap_verify_account_keys(
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'_, '_>,
    keys: ResetPerpMarketAmmOracleTwapKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn reset_perp_market_amm_oracle_twap_verify_writable_privileges<'me, 'info>(
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn reset_perp_market_amm_oracle_twap_verify_signer_privileges<'me, 'info>(
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn reset_perp_market_amm_oracle_twap_verify_account_privileges<'me, 'info>(
    accounts: ResetPerpMarketAmmOracleTwapAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    reset_perp_market_amm_oracle_twap_verify_writable_privileges(accounts)?;
    reset_perp_market_amm_oracle_twap_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_K_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdateKAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateKKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
}
impl From<UpdateKAccounts<'_, '_>> for UpdateKKeys {
    fn from(accounts: UpdateKAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
        }
    }
}
impl From<UpdateKKeys> for [AccountMeta; UPDATE_K_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateKKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_K_IX_ACCOUNTS_LEN]> for UpdateKKeys {
    fn from(pubkeys: [Pubkey; UPDATE_K_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
            oracle: pubkeys[3],
        }
    }
}
impl<'info> From<UpdateKAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_K_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateKAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_K_IX_ACCOUNTS_LEN]>
for UpdateKAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; UPDATE_K_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
            oracle: &arr[3],
        }
    }
}
pub const UPDATE_K_IX_DISCM: [u8; 8] = [72, 98, 9, 139, 129, 229, 172, 56];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateKIxArgs {
    pub sqrt_k: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateKIxData(pub UpdateKIxArgs);
impl From<UpdateKIxArgs> for UpdateKIxData {
    fn from(args: UpdateKIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateKIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_K_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_K_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateKIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_K_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_k_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateKKeys,
    args: UpdateKIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_K_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateKIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_k_ix(
    keys: UpdateKKeys,
    args: UpdateKIxArgs,
) -> std::io::Result<Instruction> {
    update_k_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_k_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateKAccounts<'_, '_>,
    args: UpdateKIxArgs,
) -> ProgramResult {
    let keys: UpdateKKeys = accounts.into();
    let ix = update_k_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_k_invoke(
    accounts: UpdateKAccounts<'_, '_>,
    args: UpdateKIxArgs,
) -> ProgramResult {
    update_k_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_k_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateKAccounts<'_, '_>,
    args: UpdateKIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateKKeys = accounts.into();
    let ix = update_k_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_k_invoke_signed(
    accounts: UpdateKAccounts<'_, '_>,
    args: UpdateKIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_k_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_k_verify_account_keys(
    accounts: UpdateKAccounts<'_, '_>,
    keys: UpdateKKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_k_verify_writable_privileges<'me, 'info>(
    accounts: UpdateKAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_k_verify_signer_privileges<'me, 'info>(
    accounts: UpdateKAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_k_verify_account_privileges<'me, 'info>(
    accounts: UpdateKAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_k_verify_writable_privileges(accounts)?;
    update_k_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMarginRatioAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMarginRatioKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMarginRatioAccounts<'_, '_>>
for UpdatePerpMarketMarginRatioKeys {
    fn from(accounts: UpdatePerpMarketMarginRatioAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMarginRatioKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMarginRatioKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMarginRatioKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMarginRatioAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketMarginRatioAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMarginRatioAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MARGIN_RATIO_IX_DISCM: [u8; 8] = [
    130,
    173,
    107,
    45,
    119,
    105,
    26,
    113,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMarginRatioIxArgs {
    pub margin_ratio_initial: u32,
    pub margin_ratio_maintenance: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMarginRatioIxData(pub UpdatePerpMarketMarginRatioIxArgs);
impl From<UpdatePerpMarketMarginRatioIxArgs> for UpdatePerpMarketMarginRatioIxData {
    fn from(args: UpdatePerpMarketMarginRatioIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMarginRatioIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MARGIN_RATIO_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MARGIN_RATIO_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMarginRatioIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MARGIN_RATIO_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_margin_ratio_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMarginRatioKeys,
    args: UpdatePerpMarketMarginRatioIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MARGIN_RATIO_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMarginRatioIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_margin_ratio_ix(
    keys: UpdatePerpMarketMarginRatioKeys,
    args: UpdatePerpMarketMarginRatioIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_margin_ratio_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_margin_ratio_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMarginRatioIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMarginRatioKeys = accounts.into();
    let ix = update_perp_market_margin_ratio_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_margin_ratio_invoke(
    accounts: UpdatePerpMarketMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMarginRatioIxArgs,
) -> ProgramResult {
    update_perp_market_margin_ratio_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_margin_ratio_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMarginRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMarginRatioKeys = accounts.into();
    let ix = update_perp_market_margin_ratio_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_margin_ratio_invoke_signed(
    accounts: UpdatePerpMarketMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMarginRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_margin_ratio_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_margin_ratio_verify_account_keys(
    accounts: UpdatePerpMarketMarginRatioAccounts<'_, '_>,
    keys: UpdatePerpMarketMarginRatioKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_margin_ratio_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_margin_ratio_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_margin_ratio_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_margin_ratio_verify_writable_privileges(accounts)?;
    update_perp_market_margin_ratio_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketHighLeverageMarginRatioAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketHighLeverageMarginRatioKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, '_>>
for UpdatePerpMarketHighLeverageMarginRatioKeys {
    fn from(accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketHighLeverageMarginRatioKeys>
for [AccountMeta; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketHighLeverageMarginRatioKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketHighLeverageMarginRatioKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN] {
    fn from(
        accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, 'info>,
    ) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<
        'info,
    >; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN],
> for UpdatePerpMarketHighLeverageMarginRatioAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_DISCM: [u8; 8] = [
    88,
    112,
    86,
    49,
    24,
    116,
    74,
    157,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketHighLeverageMarginRatioIxArgs {
    pub margin_ratio_initial: u16,
    pub margin_ratio_maintenance: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketHighLeverageMarginRatioIxData(
    pub UpdatePerpMarketHighLeverageMarginRatioIxArgs,
);
impl From<UpdatePerpMarketHighLeverageMarginRatioIxArgs>
for UpdatePerpMarketHighLeverageMarginRatioIxData {
    fn from(args: UpdatePerpMarketHighLeverageMarginRatioIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketHighLeverageMarginRatioIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_DISCM,
                        maybe_discm
                    ),
                ),
            );
        }
        Ok(
            Self(
                UpdatePerpMarketHighLeverageMarginRatioIxArgs::deserialize(&mut reader)?,
            ),
        )
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_high_leverage_margin_ratio_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketHighLeverageMarginRatioKeys,
    args: UpdatePerpMarketHighLeverageMarginRatioIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_HIGH_LEVERAGE_MARGIN_RATIO_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketHighLeverageMarginRatioIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_high_leverage_margin_ratio_ix(
    keys: UpdatePerpMarketHighLeverageMarginRatioKeys,
    args: UpdatePerpMarketHighLeverageMarginRatioIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_high_leverage_margin_ratio_ix_with_program_id(
        crate::ID,
        keys,
        args,
    )
}
pub fn update_perp_market_high_leverage_margin_ratio_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketHighLeverageMarginRatioIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketHighLeverageMarginRatioKeys = accounts.into();
    let ix = update_perp_market_high_leverage_margin_ratio_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_high_leverage_margin_ratio_invoke(
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketHighLeverageMarginRatioIxArgs,
) -> ProgramResult {
    update_perp_market_high_leverage_margin_ratio_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_high_leverage_margin_ratio_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketHighLeverageMarginRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketHighLeverageMarginRatioKeys = accounts.into();
    let ix = update_perp_market_high_leverage_margin_ratio_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_high_leverage_margin_ratio_invoke_signed(
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, '_>,
    args: UpdatePerpMarketHighLeverageMarginRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_high_leverage_margin_ratio_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_high_leverage_margin_ratio_verify_account_keys(
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'_, '_>,
    keys: UpdatePerpMarketHighLeverageMarginRatioKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_high_leverage_margin_ratio_verify_writable_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_high_leverage_margin_ratio_verify_signer_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_high_leverage_margin_ratio_verify_account_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketHighLeverageMarginRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_high_leverage_margin_ratio_verify_writable_privileges(accounts)?;
    update_perp_market_high_leverage_margin_ratio_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketFundingPeriodAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketFundingPeriodKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketFundingPeriodAccounts<'_, '_>>
for UpdatePerpMarketFundingPeriodKeys {
    fn from(accounts: UpdatePerpMarketFundingPeriodAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketFundingPeriodKeys>
for [AccountMeta; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketFundingPeriodKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketFundingPeriodKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketFundingPeriodAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketFundingPeriodAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketFundingPeriodAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_DISCM: [u8; 8] = [
    171,
    161,
    69,
    91,
    129,
    139,
    161,
    28,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketFundingPeriodIxArgs {
    pub funding_period: i64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketFundingPeriodIxData(pub UpdatePerpMarketFundingPeriodIxArgs);
impl From<UpdatePerpMarketFundingPeriodIxArgs> for UpdatePerpMarketFundingPeriodIxData {
    fn from(args: UpdatePerpMarketFundingPeriodIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketFundingPeriodIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketFundingPeriodIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_funding_period_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketFundingPeriodKeys,
    args: UpdatePerpMarketFundingPeriodIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_FUNDING_PERIOD_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketFundingPeriodIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_funding_period_ix(
    keys: UpdatePerpMarketFundingPeriodKeys,
    args: UpdatePerpMarketFundingPeriodIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_funding_period_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_funding_period_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketFundingPeriodAccounts<'_, '_>,
    args: UpdatePerpMarketFundingPeriodIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketFundingPeriodKeys = accounts.into();
    let ix = update_perp_market_funding_period_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_funding_period_invoke(
    accounts: UpdatePerpMarketFundingPeriodAccounts<'_, '_>,
    args: UpdatePerpMarketFundingPeriodIxArgs,
) -> ProgramResult {
    update_perp_market_funding_period_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_funding_period_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketFundingPeriodAccounts<'_, '_>,
    args: UpdatePerpMarketFundingPeriodIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketFundingPeriodKeys = accounts.into();
    let ix = update_perp_market_funding_period_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_funding_period_invoke_signed(
    accounts: UpdatePerpMarketFundingPeriodAccounts<'_, '_>,
    args: UpdatePerpMarketFundingPeriodIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_funding_period_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_funding_period_verify_account_keys(
    accounts: UpdatePerpMarketFundingPeriodAccounts<'_, '_>,
    keys: UpdatePerpMarketFundingPeriodKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_funding_period_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFundingPeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_funding_period_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFundingPeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_funding_period_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFundingPeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_funding_period_verify_writable_privileges(accounts)?;
    update_perp_market_funding_period_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMaxImbalancesAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxImbalancesKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMaxImbalancesAccounts<'_, '_>>
for UpdatePerpMarketMaxImbalancesKeys {
    fn from(accounts: UpdatePerpMarketMaxImbalancesAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMaxImbalancesKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMaxImbalancesKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxImbalancesKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMaxImbalancesAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketMaxImbalancesAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxImbalancesAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_DISCM: [u8; 8] = [
    15,
    206,
    73,
    133,
    60,
    8,
    86,
    89,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMaxImbalancesIxArgs {
    pub unrealized_max_imbalance: u64,
    pub max_revenue_withdraw_per_period: u64,
    pub quote_max_insurance: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxImbalancesIxData(pub UpdatePerpMarketMaxImbalancesIxArgs);
impl From<UpdatePerpMarketMaxImbalancesIxArgs> for UpdatePerpMarketMaxImbalancesIxData {
    fn from(args: UpdatePerpMarketMaxImbalancesIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMaxImbalancesIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMaxImbalancesIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_max_imbalances_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMaxImbalancesKeys,
    args: UpdatePerpMarketMaxImbalancesIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MAX_IMBALANCES_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMaxImbalancesIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_max_imbalances_ix(
    keys: UpdatePerpMarketMaxImbalancesKeys,
    args: UpdatePerpMarketMaxImbalancesIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_max_imbalances_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_max_imbalances_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'_, '_>,
    args: UpdatePerpMarketMaxImbalancesIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxImbalancesKeys = accounts.into();
    let ix = update_perp_market_max_imbalances_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_max_imbalances_invoke(
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'_, '_>,
    args: UpdatePerpMarketMaxImbalancesIxArgs,
) -> ProgramResult {
    update_perp_market_max_imbalances_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_max_imbalances_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'_, '_>,
    args: UpdatePerpMarketMaxImbalancesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxImbalancesKeys = accounts.into();
    let ix = update_perp_market_max_imbalances_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_max_imbalances_invoke_signed(
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'_, '_>,
    args: UpdatePerpMarketMaxImbalancesIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_max_imbalances_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_max_imbalances_verify_account_keys(
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'_, '_>,
    keys: UpdatePerpMarketMaxImbalancesKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_imbalances_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_imbalances_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_imbalances_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxImbalancesAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_max_imbalances_verify_writable_privileges(accounts)?;
    update_perp_market_max_imbalances_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketLiquidationFeeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketLiquidationFeeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketLiquidationFeeAccounts<'_, '_>>
for UpdatePerpMarketLiquidationFeeKeys {
    fn from(accounts: UpdatePerpMarketLiquidationFeeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketLiquidationFeeKeys>
for [AccountMeta; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketLiquidationFeeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketLiquidationFeeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketLiquidationFeeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketLiquidationFeeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketLiquidationFeeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_DISCM: [u8; 8] = [
    90,
    137,
    9,
    145,
    41,
    8,
    148,
    117,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketLiquidationFeeIxArgs {
    pub liquidator_fee: u32,
    pub if_liquidation_fee: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketLiquidationFeeIxData(
    pub UpdatePerpMarketLiquidationFeeIxArgs,
);
impl From<UpdatePerpMarketLiquidationFeeIxArgs>
for UpdatePerpMarketLiquidationFeeIxData {
    fn from(args: UpdatePerpMarketLiquidationFeeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketLiquidationFeeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketLiquidationFeeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_liquidation_fee_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketLiquidationFeeKeys,
    args: UpdatePerpMarketLiquidationFeeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketLiquidationFeeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_liquidation_fee_ix(
    keys: UpdatePerpMarketLiquidationFeeKeys,
    args: UpdatePerpMarketLiquidationFeeIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_liquidation_fee_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_liquidation_fee_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdatePerpMarketLiquidationFeeIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketLiquidationFeeKeys = accounts.into();
    let ix = update_perp_market_liquidation_fee_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_liquidation_fee_invoke(
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdatePerpMarketLiquidationFeeIxArgs,
) -> ProgramResult {
    update_perp_market_liquidation_fee_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_liquidation_fee_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdatePerpMarketLiquidationFeeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketLiquidationFeeKeys = accounts.into();
    let ix = update_perp_market_liquidation_fee_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_liquidation_fee_invoke_signed(
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdatePerpMarketLiquidationFeeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_liquidation_fee_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_liquidation_fee_verify_account_keys(
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'_, '_>,
    keys: UpdatePerpMarketLiquidationFeeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_liquidation_fee_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_liquidation_fee_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_liquidation_fee_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketLiquidationFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_liquidation_fee_verify_writable_privileges(accounts)?;
    update_perp_market_liquidation_fee_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateInsuranceFundUnstakingPeriodAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateInsuranceFundUnstakingPeriodKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateInsuranceFundUnstakingPeriodAccounts<'_, '_>>
for UpdateInsuranceFundUnstakingPeriodKeys {
    fn from(accounts: UpdateInsuranceFundUnstakingPeriodAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateInsuranceFundUnstakingPeriodKeys>
for [AccountMeta; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateInsuranceFundUnstakingPeriodKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN]>
for UpdateInsuranceFundUnstakingPeriodKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateInsuranceFundUnstakingPeriodAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN]>
for UpdateInsuranceFundUnstakingPeriodAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_DISCM: [u8; 8] = [
    44,
    69,
    43,
    226,
    204,
    223,
    202,
    52,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateInsuranceFundUnstakingPeriodIxArgs {
    pub insurance_fund_unstaking_period: i64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateInsuranceFundUnstakingPeriodIxData(
    pub UpdateInsuranceFundUnstakingPeriodIxArgs,
);
impl From<UpdateInsuranceFundUnstakingPeriodIxArgs>
for UpdateInsuranceFundUnstakingPeriodIxData {
    fn from(args: UpdateInsuranceFundUnstakingPeriodIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateInsuranceFundUnstakingPeriodIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateInsuranceFundUnstakingPeriodIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_insurance_fund_unstaking_period_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateInsuranceFundUnstakingPeriodKeys,
    args: UpdateInsuranceFundUnstakingPeriodIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_INSURANCE_FUND_UNSTAKING_PERIOD_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateInsuranceFundUnstakingPeriodIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_insurance_fund_unstaking_period_ix(
    keys: UpdateInsuranceFundUnstakingPeriodKeys,
    args: UpdateInsuranceFundUnstakingPeriodIxArgs,
) -> std::io::Result<Instruction> {
    update_insurance_fund_unstaking_period_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_insurance_fund_unstaking_period_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'_, '_>,
    args: UpdateInsuranceFundUnstakingPeriodIxArgs,
) -> ProgramResult {
    let keys: UpdateInsuranceFundUnstakingPeriodKeys = accounts.into();
    let ix = update_insurance_fund_unstaking_period_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_insurance_fund_unstaking_period_invoke(
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'_, '_>,
    args: UpdateInsuranceFundUnstakingPeriodIxArgs,
) -> ProgramResult {
    update_insurance_fund_unstaking_period_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_insurance_fund_unstaking_period_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'_, '_>,
    args: UpdateInsuranceFundUnstakingPeriodIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateInsuranceFundUnstakingPeriodKeys = accounts.into();
    let ix = update_insurance_fund_unstaking_period_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_insurance_fund_unstaking_period_invoke_signed(
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'_, '_>,
    args: UpdateInsuranceFundUnstakingPeriodIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_insurance_fund_unstaking_period_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_insurance_fund_unstaking_period_verify_account_keys(
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'_, '_>,
    keys: UpdateInsuranceFundUnstakingPeriodKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_insurance_fund_unstaking_period_verify_writable_privileges<'me, 'info>(
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_insurance_fund_unstaking_period_verify_signer_privileges<'me, 'info>(
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_insurance_fund_unstaking_period_verify_account_privileges<'me, 'info>(
    accounts: UpdateInsuranceFundUnstakingPeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_insurance_fund_unstaking_period_verify_writable_privileges(accounts)?;
    update_insurance_fund_unstaking_period_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketLiquidationFeeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketLiquidationFeeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketLiquidationFeeAccounts<'_, '_>>
for UpdateSpotMarketLiquidationFeeKeys {
    fn from(accounts: UpdateSpotMarketLiquidationFeeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketLiquidationFeeKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketLiquidationFeeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketLiquidationFeeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketLiquidationFeeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketLiquidationFeeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketLiquidationFeeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_DISCM: [u8; 8] = [
    11,
    13,
    255,
    53,
    56,
    136,
    104,
    177,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketLiquidationFeeIxArgs {
    pub liquidator_fee: u32,
    pub if_liquidation_fee: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketLiquidationFeeIxData(
    pub UpdateSpotMarketLiquidationFeeIxArgs,
);
impl From<UpdateSpotMarketLiquidationFeeIxArgs>
for UpdateSpotMarketLiquidationFeeIxData {
    fn from(args: UpdateSpotMarketLiquidationFeeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketLiquidationFeeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketLiquidationFeeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_liquidation_fee_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketLiquidationFeeKeys,
    args: UpdateSpotMarketLiquidationFeeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_LIQUIDATION_FEE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketLiquidationFeeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_liquidation_fee_ix(
    keys: UpdateSpotMarketLiquidationFeeKeys,
    args: UpdateSpotMarketLiquidationFeeIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_liquidation_fee_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_liquidation_fee_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdateSpotMarketLiquidationFeeIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketLiquidationFeeKeys = accounts.into();
    let ix = update_spot_market_liquidation_fee_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_liquidation_fee_invoke(
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdateSpotMarketLiquidationFeeIxArgs,
) -> ProgramResult {
    update_spot_market_liquidation_fee_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_liquidation_fee_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdateSpotMarketLiquidationFeeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketLiquidationFeeKeys = accounts.into();
    let ix = update_spot_market_liquidation_fee_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_liquidation_fee_invoke_signed(
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'_, '_>,
    args: UpdateSpotMarketLiquidationFeeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_liquidation_fee_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_liquidation_fee_verify_account_keys(
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'_, '_>,
    keys: UpdateSpotMarketLiquidationFeeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_liquidation_fee_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_liquidation_fee_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_liquidation_fee_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketLiquidationFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_liquidation_fee_verify_writable_privileges(accounts)?;
    update_spot_market_liquidation_fee_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateWithdrawGuardThresholdAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateWithdrawGuardThresholdKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateWithdrawGuardThresholdAccounts<'_, '_>>
for UpdateWithdrawGuardThresholdKeys {
    fn from(accounts: UpdateWithdrawGuardThresholdAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateWithdrawGuardThresholdKeys>
for [AccountMeta; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateWithdrawGuardThresholdKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN]>
for UpdateWithdrawGuardThresholdKeys {
    fn from(pubkeys: [Pubkey; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateWithdrawGuardThresholdAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateWithdrawGuardThresholdAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN]>
for UpdateWithdrawGuardThresholdAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_DISCM: [u8; 8] = [
    56,
    18,
    39,
    61,
    155,
    211,
    44,
    133,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateWithdrawGuardThresholdIxArgs {
    pub withdraw_guard_threshold: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateWithdrawGuardThresholdIxData(pub UpdateWithdrawGuardThresholdIxArgs);
impl From<UpdateWithdrawGuardThresholdIxArgs> for UpdateWithdrawGuardThresholdIxData {
    fn from(args: UpdateWithdrawGuardThresholdIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateWithdrawGuardThresholdIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateWithdrawGuardThresholdIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_withdraw_guard_threshold_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateWithdrawGuardThresholdKeys,
    args: UpdateWithdrawGuardThresholdIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_WITHDRAW_GUARD_THRESHOLD_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateWithdrawGuardThresholdIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_withdraw_guard_threshold_ix(
    keys: UpdateWithdrawGuardThresholdKeys,
    args: UpdateWithdrawGuardThresholdIxArgs,
) -> std::io::Result<Instruction> {
    update_withdraw_guard_threshold_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_withdraw_guard_threshold_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateWithdrawGuardThresholdAccounts<'_, '_>,
    args: UpdateWithdrawGuardThresholdIxArgs,
) -> ProgramResult {
    let keys: UpdateWithdrawGuardThresholdKeys = accounts.into();
    let ix = update_withdraw_guard_threshold_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_withdraw_guard_threshold_invoke(
    accounts: UpdateWithdrawGuardThresholdAccounts<'_, '_>,
    args: UpdateWithdrawGuardThresholdIxArgs,
) -> ProgramResult {
    update_withdraw_guard_threshold_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_withdraw_guard_threshold_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateWithdrawGuardThresholdAccounts<'_, '_>,
    args: UpdateWithdrawGuardThresholdIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateWithdrawGuardThresholdKeys = accounts.into();
    let ix = update_withdraw_guard_threshold_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_withdraw_guard_threshold_invoke_signed(
    accounts: UpdateWithdrawGuardThresholdAccounts<'_, '_>,
    args: UpdateWithdrawGuardThresholdIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_withdraw_guard_threshold_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_withdraw_guard_threshold_verify_account_keys(
    accounts: UpdateWithdrawGuardThresholdAccounts<'_, '_>,
    keys: UpdateWithdrawGuardThresholdKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_withdraw_guard_threshold_verify_writable_privileges<'me, 'info>(
    accounts: UpdateWithdrawGuardThresholdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_withdraw_guard_threshold_verify_signer_privileges<'me, 'info>(
    accounts: UpdateWithdrawGuardThresholdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_withdraw_guard_threshold_verify_account_privileges<'me, 'info>(
    accounts: UpdateWithdrawGuardThresholdAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_withdraw_guard_threshold_verify_writable_privileges(accounts)?;
    update_withdraw_guard_threshold_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketIfFactorAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketIfFactorKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketIfFactorAccounts<'_, '_>> for UpdateSpotMarketIfFactorKeys {
    fn from(accounts: UpdateSpotMarketIfFactorAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketIfFactorKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketIfFactorKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketIfFactorKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketIfFactorAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketIfFactorAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketIfFactorAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_IF_FACTOR_IX_DISCM: [u8; 8] = [
    147,
    30,
    224,
    34,
    18,
    230,
    105,
    4,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketIfFactorIxArgs {
    pub spot_market_index: u16,
    pub user_if_factor: u32,
    pub total_if_factor: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketIfFactorIxData(pub UpdateSpotMarketIfFactorIxArgs);
impl From<UpdateSpotMarketIfFactorIxArgs> for UpdateSpotMarketIfFactorIxData {
    fn from(args: UpdateSpotMarketIfFactorIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketIfFactorIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_IF_FACTOR_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_IF_FACTOR_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketIfFactorIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_IF_FACTOR_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_if_factor_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketIfFactorKeys,
    args: UpdateSpotMarketIfFactorIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_IF_FACTOR_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotMarketIfFactorIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_if_factor_ix(
    keys: UpdateSpotMarketIfFactorKeys,
    args: UpdateSpotMarketIfFactorIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_if_factor_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_if_factor_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketIfFactorAccounts<'_, '_>,
    args: UpdateSpotMarketIfFactorIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketIfFactorKeys = accounts.into();
    let ix = update_spot_market_if_factor_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_if_factor_invoke(
    accounts: UpdateSpotMarketIfFactorAccounts<'_, '_>,
    args: UpdateSpotMarketIfFactorIxArgs,
) -> ProgramResult {
    update_spot_market_if_factor_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_if_factor_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketIfFactorAccounts<'_, '_>,
    args: UpdateSpotMarketIfFactorIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketIfFactorKeys = accounts.into();
    let ix = update_spot_market_if_factor_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_if_factor_invoke_signed(
    accounts: UpdateSpotMarketIfFactorAccounts<'_, '_>,
    args: UpdateSpotMarketIfFactorIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_if_factor_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_if_factor_verify_account_keys(
    accounts: UpdateSpotMarketIfFactorAccounts<'_, '_>,
    keys: UpdateSpotMarketIfFactorKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_if_factor_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketIfFactorAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_if_factor_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketIfFactorAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_if_factor_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketIfFactorAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_if_factor_verify_writable_privileges(accounts)?;
    update_spot_market_if_factor_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketRevenueSettlePeriodAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketRevenueSettlePeriodKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketRevenueSettlePeriodAccounts<'_, '_>>
for UpdateSpotMarketRevenueSettlePeriodKeys {
    fn from(accounts: UpdateSpotMarketRevenueSettlePeriodAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketRevenueSettlePeriodKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketRevenueSettlePeriodKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketRevenueSettlePeriodKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketRevenueSettlePeriodAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN],
> for UpdateSpotMarketRevenueSettlePeriodAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_DISCM: [u8; 8] = [
    81,
    92,
    126,
    41,
    250,
    225,
    156,
    219,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketRevenueSettlePeriodIxArgs {
    pub revenue_settle_period: i64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketRevenueSettlePeriodIxData(
    pub UpdateSpotMarketRevenueSettlePeriodIxArgs,
);
impl From<UpdateSpotMarketRevenueSettlePeriodIxArgs>
for UpdateSpotMarketRevenueSettlePeriodIxData {
    fn from(args: UpdateSpotMarketRevenueSettlePeriodIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketRevenueSettlePeriodIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketRevenueSettlePeriodIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_revenue_settle_period_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketRevenueSettlePeriodKeys,
    args: UpdateSpotMarketRevenueSettlePeriodIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_REVENUE_SETTLE_PERIOD_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketRevenueSettlePeriodIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_revenue_settle_period_ix(
    keys: UpdateSpotMarketRevenueSettlePeriodKeys,
    args: UpdateSpotMarketRevenueSettlePeriodIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_revenue_settle_period_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_revenue_settle_period_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'_, '_>,
    args: UpdateSpotMarketRevenueSettlePeriodIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketRevenueSettlePeriodKeys = accounts.into();
    let ix = update_spot_market_revenue_settle_period_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_revenue_settle_period_invoke(
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'_, '_>,
    args: UpdateSpotMarketRevenueSettlePeriodIxArgs,
) -> ProgramResult {
    update_spot_market_revenue_settle_period_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_revenue_settle_period_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'_, '_>,
    args: UpdateSpotMarketRevenueSettlePeriodIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketRevenueSettlePeriodKeys = accounts.into();
    let ix = update_spot_market_revenue_settle_period_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_revenue_settle_period_invoke_signed(
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'_, '_>,
    args: UpdateSpotMarketRevenueSettlePeriodIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_revenue_settle_period_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_revenue_settle_period_verify_account_keys(
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'_, '_>,
    keys: UpdateSpotMarketRevenueSettlePeriodKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_revenue_settle_period_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_revenue_settle_period_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_revenue_settle_period_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketRevenueSettlePeriodAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_revenue_settle_period_verify_writable_privileges(accounts)?;
    update_spot_market_revenue_settle_period_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketStatusAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketStatusKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketStatusAccounts<'_, '_>> for UpdateSpotMarketStatusKeys {
    fn from(accounts: UpdateSpotMarketStatusAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketStatusKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketStatusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketStatusKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketStatusAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketStatusAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketStatusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_STATUS_IX_DISCM: [u8; 8] = [
    78,
    94,
    16,
    188,
    193,
    110,
    231,
    31,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketStatusIxArgs {
    pub status: MarketStatus,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketStatusIxData(pub UpdateSpotMarketStatusIxArgs);
impl From<UpdateSpotMarketStatusIxArgs> for UpdateSpotMarketStatusIxData {
    fn from(args: UpdateSpotMarketStatusIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketStatusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_STATUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_STATUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketStatusIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_STATUS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_status_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketStatusKeys,
    args: UpdateSpotMarketStatusIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_STATUS_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotMarketStatusIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_status_ix(
    keys: UpdateSpotMarketStatusKeys,
    args: UpdateSpotMarketStatusIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_status_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_status_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketStatusAccounts<'_, '_>,
    args: UpdateSpotMarketStatusIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketStatusKeys = accounts.into();
    let ix = update_spot_market_status_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_status_invoke(
    accounts: UpdateSpotMarketStatusAccounts<'_, '_>,
    args: UpdateSpotMarketStatusIxArgs,
) -> ProgramResult {
    update_spot_market_status_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_status_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketStatusAccounts<'_, '_>,
    args: UpdateSpotMarketStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketStatusKeys = accounts.into();
    let ix = update_spot_market_status_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_status_invoke_signed(
    accounts: UpdateSpotMarketStatusAccounts<'_, '_>,
    args: UpdateSpotMarketStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_status_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_status_verify_account_keys(
    accounts: UpdateSpotMarketStatusAccounts<'_, '_>,
    keys: UpdateSpotMarketStatusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_status_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_status_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_status_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_status_verify_writable_privileges(accounts)?;
    update_spot_market_status_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketPausedOperationsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketPausedOperationsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketPausedOperationsAccounts<'_, '_>>
for UpdateSpotMarketPausedOperationsKeys {
    fn from(accounts: UpdateSpotMarketPausedOperationsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketPausedOperationsKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketPausedOperationsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketPausedOperationsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketPausedOperationsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketPausedOperationsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketPausedOperationsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_DISCM: [u8; 8] = [
    100,
    61,
    153,
    81,
    180,
    12,
    6,
    248,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketPausedOperationsIxArgs {
    pub paused_operations: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketPausedOperationsIxData(
    pub UpdateSpotMarketPausedOperationsIxArgs,
);
impl From<UpdateSpotMarketPausedOperationsIxArgs>
for UpdateSpotMarketPausedOperationsIxData {
    fn from(args: UpdateSpotMarketPausedOperationsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketPausedOperationsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketPausedOperationsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_paused_operations_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketPausedOperationsKeys,
    args: UpdateSpotMarketPausedOperationsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketPausedOperationsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_paused_operations_ix(
    keys: UpdateSpotMarketPausedOperationsKeys,
    args: UpdateSpotMarketPausedOperationsIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_paused_operations_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_paused_operations_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketPausedOperationsIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketPausedOperationsKeys = accounts.into();
    let ix = update_spot_market_paused_operations_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_paused_operations_invoke(
    accounts: UpdateSpotMarketPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketPausedOperationsIxArgs,
) -> ProgramResult {
    update_spot_market_paused_operations_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_paused_operations_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketPausedOperationsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketPausedOperationsKeys = accounts.into();
    let ix = update_spot_market_paused_operations_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_paused_operations_invoke_signed(
    accounts: UpdateSpotMarketPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketPausedOperationsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_paused_operations_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_paused_operations_verify_account_keys(
    accounts: UpdateSpotMarketPausedOperationsAccounts<'_, '_>,
    keys: UpdateSpotMarketPausedOperationsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_paused_operations_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_paused_operations_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_paused_operations_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_paused_operations_verify_writable_privileges(accounts)?;
    update_spot_market_paused_operations_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketAssetTierAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketAssetTierKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketAssetTierAccounts<'_, '_>> for UpdateSpotMarketAssetTierKeys {
    fn from(accounts: UpdateSpotMarketAssetTierAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketAssetTierKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketAssetTierKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketAssetTierKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketAssetTierAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketAssetTierAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketAssetTierAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_ASSET_TIER_IX_DISCM: [u8; 8] = [
    253,
    209,
    231,
    14,
    242,
    208,
    243,
    130,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketAssetTierIxArgs {
    pub asset_tier: AssetTier,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketAssetTierIxData(pub UpdateSpotMarketAssetTierIxArgs);
impl From<UpdateSpotMarketAssetTierIxArgs> for UpdateSpotMarketAssetTierIxData {
    fn from(args: UpdateSpotMarketAssetTierIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketAssetTierIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_ASSET_TIER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_ASSET_TIER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketAssetTierIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_ASSET_TIER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_asset_tier_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketAssetTierKeys,
    args: UpdateSpotMarketAssetTierIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_ASSET_TIER_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketAssetTierIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_asset_tier_ix(
    keys: UpdateSpotMarketAssetTierKeys,
    args: UpdateSpotMarketAssetTierIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_asset_tier_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_asset_tier_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketAssetTierAccounts<'_, '_>,
    args: UpdateSpotMarketAssetTierIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketAssetTierKeys = accounts.into();
    let ix = update_spot_market_asset_tier_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_asset_tier_invoke(
    accounts: UpdateSpotMarketAssetTierAccounts<'_, '_>,
    args: UpdateSpotMarketAssetTierIxArgs,
) -> ProgramResult {
    update_spot_market_asset_tier_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_asset_tier_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketAssetTierAccounts<'_, '_>,
    args: UpdateSpotMarketAssetTierIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketAssetTierKeys = accounts.into();
    let ix = update_spot_market_asset_tier_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_asset_tier_invoke_signed(
    accounts: UpdateSpotMarketAssetTierAccounts<'_, '_>,
    args: UpdateSpotMarketAssetTierIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_asset_tier_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_asset_tier_verify_account_keys(
    accounts: UpdateSpotMarketAssetTierAccounts<'_, '_>,
    keys: UpdateSpotMarketAssetTierKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_asset_tier_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketAssetTierAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_asset_tier_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketAssetTierAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_asset_tier_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketAssetTierAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_asset_tier_verify_writable_privileges(accounts)?;
    update_spot_market_asset_tier_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketMarginWeightsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMarginWeightsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketMarginWeightsAccounts<'_, '_>>
for UpdateSpotMarketMarginWeightsKeys {
    fn from(accounts: UpdateSpotMarketMarginWeightsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketMarginWeightsKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketMarginWeightsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMarginWeightsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketMarginWeightsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketMarginWeightsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMarginWeightsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_DISCM: [u8; 8] = [
    109,
    33,
    87,
    195,
    255,
    36,
    6,
    81,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketMarginWeightsIxArgs {
    pub initial_asset_weight: u32,
    pub maintenance_asset_weight: u32,
    pub initial_liability_weight: u32,
    pub maintenance_liability_weight: u32,
    pub imf_factor: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMarginWeightsIxData(pub UpdateSpotMarketMarginWeightsIxArgs);
impl From<UpdateSpotMarketMarginWeightsIxArgs> for UpdateSpotMarketMarginWeightsIxData {
    fn from(args: UpdateSpotMarketMarginWeightsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketMarginWeightsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketMarginWeightsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_margin_weights_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketMarginWeightsKeys,
    args: UpdateSpotMarketMarginWeightsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_MARGIN_WEIGHTS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketMarginWeightsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_margin_weights_ix(
    keys: UpdateSpotMarketMarginWeightsKeys,
    args: UpdateSpotMarketMarginWeightsIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_margin_weights_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_margin_weights_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMarginWeightsAccounts<'_, '_>,
    args: UpdateSpotMarketMarginWeightsIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketMarginWeightsKeys = accounts.into();
    let ix = update_spot_market_margin_weights_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_margin_weights_invoke(
    accounts: UpdateSpotMarketMarginWeightsAccounts<'_, '_>,
    args: UpdateSpotMarketMarginWeightsIxArgs,
) -> ProgramResult {
    update_spot_market_margin_weights_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_margin_weights_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMarginWeightsAccounts<'_, '_>,
    args: UpdateSpotMarketMarginWeightsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketMarginWeightsKeys = accounts.into();
    let ix = update_spot_market_margin_weights_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_margin_weights_invoke_signed(
    accounts: UpdateSpotMarketMarginWeightsAccounts<'_, '_>,
    args: UpdateSpotMarketMarginWeightsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_margin_weights_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_margin_weights_verify_account_keys(
    accounts: UpdateSpotMarketMarginWeightsAccounts<'_, '_>,
    keys: UpdateSpotMarketMarginWeightsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_margin_weights_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMarginWeightsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_margin_weights_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMarginWeightsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_margin_weights_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMarginWeightsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_margin_weights_verify_writable_privileges(accounts)?;
    update_spot_market_margin_weights_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketBorrowRateAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketBorrowRateKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketBorrowRateAccounts<'_, '_>>
for UpdateSpotMarketBorrowRateKeys {
    fn from(accounts: UpdateSpotMarketBorrowRateAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketBorrowRateKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketBorrowRateKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketBorrowRateKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketBorrowRateAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketBorrowRateAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketBorrowRateAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_BORROW_RATE_IX_DISCM: [u8; 8] = [
    71,
    239,
    236,
    153,
    210,
    62,
    254,
    76,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketBorrowRateIxArgs {
    pub optimal_utilization: u32,
    pub optimal_borrow_rate: u32,
    pub max_borrow_rate: u32,
    pub min_borrow_rate: Option<u8>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketBorrowRateIxData(pub UpdateSpotMarketBorrowRateIxArgs);
impl From<UpdateSpotMarketBorrowRateIxArgs> for UpdateSpotMarketBorrowRateIxData {
    fn from(args: UpdateSpotMarketBorrowRateIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketBorrowRateIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_BORROW_RATE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_BORROW_RATE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketBorrowRateIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_BORROW_RATE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_borrow_rate_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketBorrowRateKeys,
    args: UpdateSpotMarketBorrowRateIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_BORROW_RATE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketBorrowRateIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_borrow_rate_ix(
    keys: UpdateSpotMarketBorrowRateKeys,
    args: UpdateSpotMarketBorrowRateIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_borrow_rate_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_borrow_rate_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketBorrowRateAccounts<'_, '_>,
    args: UpdateSpotMarketBorrowRateIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketBorrowRateKeys = accounts.into();
    let ix = update_spot_market_borrow_rate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_borrow_rate_invoke(
    accounts: UpdateSpotMarketBorrowRateAccounts<'_, '_>,
    args: UpdateSpotMarketBorrowRateIxArgs,
) -> ProgramResult {
    update_spot_market_borrow_rate_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_borrow_rate_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketBorrowRateAccounts<'_, '_>,
    args: UpdateSpotMarketBorrowRateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketBorrowRateKeys = accounts.into();
    let ix = update_spot_market_borrow_rate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_borrow_rate_invoke_signed(
    accounts: UpdateSpotMarketBorrowRateAccounts<'_, '_>,
    args: UpdateSpotMarketBorrowRateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_borrow_rate_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_borrow_rate_verify_account_keys(
    accounts: UpdateSpotMarketBorrowRateAccounts<'_, '_>,
    keys: UpdateSpotMarketBorrowRateKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_borrow_rate_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketBorrowRateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_borrow_rate_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketBorrowRateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_borrow_rate_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketBorrowRateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_borrow_rate_verify_writable_privileges(accounts)?;
    update_spot_market_borrow_rate_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketMaxTokenDepositsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMaxTokenDepositsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketMaxTokenDepositsAccounts<'_, '_>>
for UpdateSpotMarketMaxTokenDepositsKeys {
    fn from(accounts: UpdateSpotMarketMaxTokenDepositsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketMaxTokenDepositsKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketMaxTokenDepositsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMaxTokenDepositsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketMaxTokenDepositsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMaxTokenDepositsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_DISCM: [u8; 8] = [
    56,
    191,
    79,
    18,
    26,
    121,
    80,
    208,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketMaxTokenDepositsIxArgs {
    pub max_token_deposits: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMaxTokenDepositsIxData(
    pub UpdateSpotMarketMaxTokenDepositsIxArgs,
);
impl From<UpdateSpotMarketMaxTokenDepositsIxArgs>
for UpdateSpotMarketMaxTokenDepositsIxData {
    fn from(args: UpdateSpotMarketMaxTokenDepositsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketMaxTokenDepositsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketMaxTokenDepositsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_max_token_deposits_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketMaxTokenDepositsKeys,
    args: UpdateSpotMarketMaxTokenDepositsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_MAX_TOKEN_DEPOSITS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketMaxTokenDepositsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_max_token_deposits_ix(
    keys: UpdateSpotMarketMaxTokenDepositsKeys,
    args: UpdateSpotMarketMaxTokenDepositsIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_max_token_deposits_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_max_token_deposits_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenDepositsIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketMaxTokenDepositsKeys = accounts.into();
    let ix = update_spot_market_max_token_deposits_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_max_token_deposits_invoke(
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenDepositsIxArgs,
) -> ProgramResult {
    update_spot_market_max_token_deposits_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_max_token_deposits_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenDepositsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketMaxTokenDepositsKeys = accounts.into();
    let ix = update_spot_market_max_token_deposits_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_max_token_deposits_invoke_signed(
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenDepositsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_max_token_deposits_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_max_token_deposits_verify_account_keys(
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'_, '_>,
    keys: UpdateSpotMarketMaxTokenDepositsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_max_token_deposits_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_max_token_deposits_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_max_token_deposits_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMaxTokenDepositsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_max_token_deposits_verify_writable_privileges(accounts)?;
    update_spot_market_max_token_deposits_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketMaxTokenBorrowsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMaxTokenBorrowsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketMaxTokenBorrowsAccounts<'_, '_>>
for UpdateSpotMarketMaxTokenBorrowsKeys {
    fn from(accounts: UpdateSpotMarketMaxTokenBorrowsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketMaxTokenBorrowsKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketMaxTokenBorrowsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMaxTokenBorrowsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketMaxTokenBorrowsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMaxTokenBorrowsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_DISCM: [u8; 8] = [
    57,
    102,
    204,
    212,
    253,
    95,
    13,
    199,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketMaxTokenBorrowsIxArgs {
    pub max_token_borrows_fraction: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMaxTokenBorrowsIxData(
    pub UpdateSpotMarketMaxTokenBorrowsIxArgs,
);
impl From<UpdateSpotMarketMaxTokenBorrowsIxArgs>
for UpdateSpotMarketMaxTokenBorrowsIxData {
    fn from(args: UpdateSpotMarketMaxTokenBorrowsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketMaxTokenBorrowsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketMaxTokenBorrowsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_max_token_borrows_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketMaxTokenBorrowsKeys,
    args: UpdateSpotMarketMaxTokenBorrowsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_MAX_TOKEN_BORROWS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketMaxTokenBorrowsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_max_token_borrows_ix(
    keys: UpdateSpotMarketMaxTokenBorrowsKeys,
    args: UpdateSpotMarketMaxTokenBorrowsIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_max_token_borrows_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_max_token_borrows_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenBorrowsIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketMaxTokenBorrowsKeys = accounts.into();
    let ix = update_spot_market_max_token_borrows_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_max_token_borrows_invoke(
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenBorrowsIxArgs,
) -> ProgramResult {
    update_spot_market_max_token_borrows_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_max_token_borrows_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenBorrowsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketMaxTokenBorrowsKeys = accounts.into();
    let ix = update_spot_market_max_token_borrows_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_max_token_borrows_invoke_signed(
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'_, '_>,
    args: UpdateSpotMarketMaxTokenBorrowsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_max_token_borrows_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_max_token_borrows_verify_account_keys(
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'_, '_>,
    keys: UpdateSpotMarketMaxTokenBorrowsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_max_token_borrows_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_max_token_borrows_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_max_token_borrows_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMaxTokenBorrowsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_max_token_borrows_verify_writable_privileges(accounts)?;
    update_spot_market_max_token_borrows_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketScaleInitialAssetWeightStartKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, '_>>
for UpdateSpotMarketScaleInitialAssetWeightStartKeys {
    fn from(accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketScaleInitialAssetWeightStartKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketScaleInitialAssetWeightStartKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketScaleInitialAssetWeightStartKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, 'info>>
for [AccountInfo<
    'info,
>; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN] {
    fn from(
        accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, 'info>,
    ) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<
        'info,
    >; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN],
> for UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_DISCM: [u8; 8] = [
    217,
    204,
    204,
    118,
    204,
    130,
    225,
    147,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketScaleInitialAssetWeightStartIxArgs {
    pub scale_initial_asset_weight_start: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketScaleInitialAssetWeightStartIxData(
    pub UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
);
impl From<UpdateSpotMarketScaleInitialAssetWeightStartIxArgs>
for UpdateSpotMarketScaleInitialAssetWeightStartIxData {
    fn from(args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketScaleInitialAssetWeightStartIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_DISCM,
                        maybe_discm
                    ),
                ),
            );
        }
        Ok(
            Self(
                UpdateSpotMarketScaleInitialAssetWeightStartIxArgs::deserialize(
                    &mut reader,
                )?,
            ),
        )
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_scale_initial_asset_weight_start_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketScaleInitialAssetWeightStartKeys,
    args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_SCALE_INITIAL_ASSET_WEIGHT_START_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketScaleInitialAssetWeightStartIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_scale_initial_asset_weight_start_ix(
    keys: UpdateSpotMarketScaleInitialAssetWeightStartKeys,
    args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_scale_initial_asset_weight_start_ix_with_program_id(
        crate::ID,
        keys,
        args,
    )
}
pub fn update_spot_market_scale_initial_asset_weight_start_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, '_>,
    args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketScaleInitialAssetWeightStartKeys = accounts.into();
    let ix = update_spot_market_scale_initial_asset_weight_start_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_scale_initial_asset_weight_start_invoke(
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, '_>,
    args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
) -> ProgramResult {
    update_spot_market_scale_initial_asset_weight_start_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_scale_initial_asset_weight_start_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, '_>,
    args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketScaleInitialAssetWeightStartKeys = accounts.into();
    let ix = update_spot_market_scale_initial_asset_weight_start_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_scale_initial_asset_weight_start_invoke_signed(
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, '_>,
    args: UpdateSpotMarketScaleInitialAssetWeightStartIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_scale_initial_asset_weight_start_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_scale_initial_asset_weight_start_verify_account_keys(
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'_, '_>,
    keys: UpdateSpotMarketScaleInitialAssetWeightStartKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_scale_initial_asset_weight_start_verify_writable_privileges<
    'me,
    'info,
>(
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_scale_initial_asset_weight_start_verify_signer_privileges<
    'me,
    'info,
>(
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_scale_initial_asset_weight_start_verify_account_privileges<
    'me,
    'info,
>(
    accounts: UpdateSpotMarketScaleInitialAssetWeightStartAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_scale_initial_asset_weight_start_verify_writable_privileges(
        accounts,
    )?;
    update_spot_market_scale_initial_asset_weight_start_verify_signer_privileges(
        accounts,
    )?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketOracleAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketOracleKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
    pub oracle: Pubkey,
}
impl From<UpdateSpotMarketOracleAccounts<'_, '_>> for UpdateSpotMarketOracleKeys {
    fn from(accounts: UpdateSpotMarketOracleAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
            oracle: *accounts.oracle.key,
        }
    }
}
impl From<UpdateSpotMarketOracleKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketOracleKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
            oracle: pubkeys[3],
        }
    }
}
impl<'info> From<UpdateSpotMarketOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketOracleAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.spot_market.clone(),
            accounts.oracle.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
            oracle: &arr[3],
        }
    }
}
pub const UPDATE_SPOT_MARKET_ORACLE_IX_DISCM: [u8; 8] = [
    114,
    184,
    102,
    37,
    246,
    186,
    180,
    99,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketOracleIxArgs {
    pub oracle: Pubkey,
    pub oracle_source: OracleSource,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketOracleIxData(pub UpdateSpotMarketOracleIxArgs);
impl From<UpdateSpotMarketOracleIxArgs> for UpdateSpotMarketOracleIxData {
    fn from(args: UpdateSpotMarketOracleIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketOracleIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_ORACLE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketOracleKeys,
    args: UpdateSpotMarketOracleIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotMarketOracleIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_oracle_ix(
    keys: UpdateSpotMarketOracleKeys,
    args: UpdateSpotMarketOracleIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_oracle_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketOracleAccounts<'_, '_>,
    args: UpdateSpotMarketOracleIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketOracleKeys = accounts.into();
    let ix = update_spot_market_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_oracle_invoke(
    accounts: UpdateSpotMarketOracleAccounts<'_, '_>,
    args: UpdateSpotMarketOracleIxArgs,
) -> ProgramResult {
    update_spot_market_oracle_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketOracleAccounts<'_, '_>,
    args: UpdateSpotMarketOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketOracleKeys = accounts.into();
    let ix = update_spot_market_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_oracle_invoke_signed(
    accounts: UpdateSpotMarketOracleAccounts<'_, '_>,
    args: UpdateSpotMarketOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_oracle_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_oracle_verify_account_keys(
    accounts: UpdateSpotMarketOracleAccounts<'_, '_>,
    keys: UpdateSpotMarketOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
        (*accounts.oracle.key, keys.oracle),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_oracle_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_oracle_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_oracle_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_oracle_verify_writable_privileges(accounts)?;
    update_spot_market_oracle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketStepSizeAndTickSizeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketStepSizeAndTickSizeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, '_>>
for UpdateSpotMarketStepSizeAndTickSizeKeys {
    fn from(accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketStepSizeAndTickSizeKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketStepSizeAndTickSizeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketStepSizeAndTickSizeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN],
> for UpdateSpotMarketStepSizeAndTickSizeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM: [u8; 8] = [
    238,
    153,
    137,
    80,
    206,
    59,
    250,
    61,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketStepSizeAndTickSizeIxArgs {
    pub step_size: u64,
    pub tick_size: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketStepSizeAndTickSizeIxData(
    pub UpdateSpotMarketStepSizeAndTickSizeIxArgs,
);
impl From<UpdateSpotMarketStepSizeAndTickSizeIxArgs>
for UpdateSpotMarketStepSizeAndTickSizeIxData {
    fn from(args: UpdateSpotMarketStepSizeAndTickSizeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketStepSizeAndTickSizeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketStepSizeAndTickSizeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_step_size_and_tick_size_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketStepSizeAndTickSizeKeys,
    args: UpdateSpotMarketStepSizeAndTickSizeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketStepSizeAndTickSizeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_step_size_and_tick_size_ix(
    keys: UpdateSpotMarketStepSizeAndTickSizeKeys,
    args: UpdateSpotMarketStepSizeAndTickSizeIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_step_size_and_tick_size_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_step_size_and_tick_size_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdateSpotMarketStepSizeAndTickSizeIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketStepSizeAndTickSizeKeys = accounts.into();
    let ix = update_spot_market_step_size_and_tick_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_step_size_and_tick_size_invoke(
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdateSpotMarketStepSizeAndTickSizeIxArgs,
) -> ProgramResult {
    update_spot_market_step_size_and_tick_size_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_step_size_and_tick_size_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdateSpotMarketStepSizeAndTickSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketStepSizeAndTickSizeKeys = accounts.into();
    let ix = update_spot_market_step_size_and_tick_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_step_size_and_tick_size_invoke_signed(
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdateSpotMarketStepSizeAndTickSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_step_size_and_tick_size_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_step_size_and_tick_size_verify_account_keys(
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'_, '_>,
    keys: UpdateSpotMarketStepSizeAndTickSizeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_step_size_and_tick_size_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_step_size_and_tick_size_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_step_size_and_tick_size_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketStepSizeAndTickSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_step_size_and_tick_size_verify_writable_privileges(accounts)?;
    update_spot_market_step_size_and_tick_size_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketMinOrderSizeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMinOrderSizeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketMinOrderSizeAccounts<'_, '_>>
for UpdateSpotMarketMinOrderSizeKeys {
    fn from(accounts: UpdateSpotMarketMinOrderSizeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketMinOrderSizeKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketMinOrderSizeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMinOrderSizeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketMinOrderSizeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketMinOrderSizeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketMinOrderSizeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_DISCM: [u8; 8] = [
    93,
    128,
    11,
    119,
    26,
    20,
    181,
    50,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketMinOrderSizeIxArgs {
    pub order_size: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketMinOrderSizeIxData(pub UpdateSpotMarketMinOrderSizeIxArgs);
impl From<UpdateSpotMarketMinOrderSizeIxArgs> for UpdateSpotMarketMinOrderSizeIxData {
    fn from(args: UpdateSpotMarketMinOrderSizeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketMinOrderSizeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketMinOrderSizeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_min_order_size_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketMinOrderSizeKeys,
    args: UpdateSpotMarketMinOrderSizeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketMinOrderSizeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_min_order_size_ix(
    keys: UpdateSpotMarketMinOrderSizeKeys,
    args: UpdateSpotMarketMinOrderSizeIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_min_order_size_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_min_order_size_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdateSpotMarketMinOrderSizeIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketMinOrderSizeKeys = accounts.into();
    let ix = update_spot_market_min_order_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_min_order_size_invoke(
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdateSpotMarketMinOrderSizeIxArgs,
) -> ProgramResult {
    update_spot_market_min_order_size_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_min_order_size_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdateSpotMarketMinOrderSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketMinOrderSizeKeys = accounts.into();
    let ix = update_spot_market_min_order_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_min_order_size_invoke_signed(
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdateSpotMarketMinOrderSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_min_order_size_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_min_order_size_verify_account_keys(
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'_, '_>,
    keys: UpdateSpotMarketMinOrderSizeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_min_order_size_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_min_order_size_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_min_order_size_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketMinOrderSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_min_order_size_verify_writable_privileges(accounts)?;
    update_spot_market_min_order_size_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketOrdersEnabledAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketOrdersEnabledKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketOrdersEnabledAccounts<'_, '_>>
for UpdateSpotMarketOrdersEnabledKeys {
    fn from(accounts: UpdateSpotMarketOrdersEnabledAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketOrdersEnabledKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketOrdersEnabledKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketOrdersEnabledKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketOrdersEnabledAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketOrdersEnabledAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketOrdersEnabledAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_DISCM: [u8; 8] = [
    190,
    79,
    206,
    15,
    26,
    229,
    229,
    43,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketOrdersEnabledIxArgs {
    pub orders_enabled: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketOrdersEnabledIxData(pub UpdateSpotMarketOrdersEnabledIxArgs);
impl From<UpdateSpotMarketOrdersEnabledIxArgs> for UpdateSpotMarketOrdersEnabledIxData {
    fn from(args: UpdateSpotMarketOrdersEnabledIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketOrdersEnabledIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketOrdersEnabledIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_orders_enabled_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketOrdersEnabledKeys,
    args: UpdateSpotMarketOrdersEnabledIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_ORDERS_ENABLED_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketOrdersEnabledIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_orders_enabled_ix(
    keys: UpdateSpotMarketOrdersEnabledKeys,
    args: UpdateSpotMarketOrdersEnabledIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_orders_enabled_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_orders_enabled_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'_, '_>,
    args: UpdateSpotMarketOrdersEnabledIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketOrdersEnabledKeys = accounts.into();
    let ix = update_spot_market_orders_enabled_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_orders_enabled_invoke(
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'_, '_>,
    args: UpdateSpotMarketOrdersEnabledIxArgs,
) -> ProgramResult {
    update_spot_market_orders_enabled_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_orders_enabled_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'_, '_>,
    args: UpdateSpotMarketOrdersEnabledIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketOrdersEnabledKeys = accounts.into();
    let ix = update_spot_market_orders_enabled_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_orders_enabled_invoke_signed(
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'_, '_>,
    args: UpdateSpotMarketOrdersEnabledIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_orders_enabled_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_orders_enabled_verify_account_keys(
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'_, '_>,
    keys: UpdateSpotMarketOrdersEnabledKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_orders_enabled_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_orders_enabled_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_orders_enabled_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketOrdersEnabledAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_orders_enabled_verify_writable_privileges(accounts)?;
    update_spot_market_orders_enabled_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketIfPausedOperationsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketIfPausedOperationsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketIfPausedOperationsAccounts<'_, '_>>
for UpdateSpotMarketIfPausedOperationsKeys {
    fn from(accounts: UpdateSpotMarketIfPausedOperationsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketIfPausedOperationsKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketIfPausedOperationsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketIfPausedOperationsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketIfPausedOperationsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketIfPausedOperationsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
> for UpdateSpotMarketIfPausedOperationsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_DISCM: [u8; 8] = [
    101,
    215,
    79,
    74,
    59,
    41,
    79,
    12,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketIfPausedOperationsIxArgs {
    pub paused_operations: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketIfPausedOperationsIxData(
    pub UpdateSpotMarketIfPausedOperationsIxArgs,
);
impl From<UpdateSpotMarketIfPausedOperationsIxArgs>
for UpdateSpotMarketIfPausedOperationsIxData {
    fn from(args: UpdateSpotMarketIfPausedOperationsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketIfPausedOperationsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketIfPausedOperationsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_if_paused_operations_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketIfPausedOperationsKeys,
    args: UpdateSpotMarketIfPausedOperationsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_IF_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketIfPausedOperationsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_if_paused_operations_ix(
    keys: UpdateSpotMarketIfPausedOperationsKeys,
    args: UpdateSpotMarketIfPausedOperationsIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_if_paused_operations_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_if_paused_operations_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketIfPausedOperationsIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketIfPausedOperationsKeys = accounts.into();
    let ix = update_spot_market_if_paused_operations_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_if_paused_operations_invoke(
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketIfPausedOperationsIxArgs,
) -> ProgramResult {
    update_spot_market_if_paused_operations_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_spot_market_if_paused_operations_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketIfPausedOperationsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketIfPausedOperationsKeys = accounts.into();
    let ix = update_spot_market_if_paused_operations_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_if_paused_operations_invoke_signed(
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'_, '_>,
    args: UpdateSpotMarketIfPausedOperationsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_if_paused_operations_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_if_paused_operations_verify_account_keys(
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'_, '_>,
    keys: UpdateSpotMarketIfPausedOperationsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_if_paused_operations_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_if_paused_operations_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_if_paused_operations_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketIfPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_if_paused_operations_verify_writable_privileges(accounts)?;
    update_spot_market_if_paused_operations_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketNameAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketNameKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketNameAccounts<'_, '_>> for UpdateSpotMarketNameKeys {
    fn from(accounts: UpdateSpotMarketNameAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketNameKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketNameKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketNameKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketNameAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketNameAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketNameAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_NAME_IX_DISCM: [u8; 8] = [
    17,
    208,
    1,
    1,
    162,
    211,
    188,
    224,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketNameIxArgs {
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketNameIxData(pub UpdateSpotMarketNameIxArgs);
impl From<UpdateSpotMarketNameIxArgs> for UpdateSpotMarketNameIxData {
    fn from(args: UpdateSpotMarketNameIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketNameIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_NAME_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_NAME_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketNameIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_NAME_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_name_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketNameKeys,
    args: UpdateSpotMarketNameIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_NAME_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotMarketNameIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_name_ix(
    keys: UpdateSpotMarketNameKeys,
    args: UpdateSpotMarketNameIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_name_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_name_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketNameAccounts<'_, '_>,
    args: UpdateSpotMarketNameIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketNameKeys = accounts.into();
    let ix = update_spot_market_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_name_invoke(
    accounts: UpdateSpotMarketNameAccounts<'_, '_>,
    args: UpdateSpotMarketNameIxArgs,
) -> ProgramResult {
    update_spot_market_name_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_name_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketNameAccounts<'_, '_>,
    args: UpdateSpotMarketNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketNameKeys = accounts.into();
    let ix = update_spot_market_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_name_invoke_signed(
    accounts: UpdateSpotMarketNameAccounts<'_, '_>,
    args: UpdateSpotMarketNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_name_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_name_verify_account_keys(
    accounts: UpdateSpotMarketNameAccounts<'_, '_>,
    keys: UpdateSpotMarketNameKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_name_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_name_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_name_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_name_verify_writable_privileges(accounts)?;
    update_spot_market_name_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketStatusAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketStatusKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketStatusAccounts<'_, '_>> for UpdatePerpMarketStatusKeys {
    fn from(accounts: UpdatePerpMarketStatusAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketStatusKeys>
for [AccountMeta; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketStatusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketStatusKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketStatusAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketStatusAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketStatusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_STATUS_IX_DISCM: [u8; 8] = [
    71,
    201,
    175,
    122,
    255,
    207,
    196,
    207,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketStatusIxArgs {
    pub status: MarketStatus,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketStatusIxData(pub UpdatePerpMarketStatusIxArgs);
impl From<UpdatePerpMarketStatusIxArgs> for UpdatePerpMarketStatusIxData {
    fn from(args: UpdatePerpMarketStatusIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketStatusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_STATUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_STATUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketStatusIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_STATUS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_status_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketStatusKeys,
    args: UpdatePerpMarketStatusIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_STATUS_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpMarketStatusIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_status_ix(
    keys: UpdatePerpMarketStatusKeys,
    args: UpdatePerpMarketStatusIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_status_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_status_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketStatusAccounts<'_, '_>,
    args: UpdatePerpMarketStatusIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketStatusKeys = accounts.into();
    let ix = update_perp_market_status_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_status_invoke(
    accounts: UpdatePerpMarketStatusAccounts<'_, '_>,
    args: UpdatePerpMarketStatusIxArgs,
) -> ProgramResult {
    update_perp_market_status_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_status_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketStatusAccounts<'_, '_>,
    args: UpdatePerpMarketStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketStatusKeys = accounts.into();
    let ix = update_perp_market_status_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_status_invoke_signed(
    accounts: UpdatePerpMarketStatusAccounts<'_, '_>,
    args: UpdatePerpMarketStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_status_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_status_verify_account_keys(
    accounts: UpdatePerpMarketStatusAccounts<'_, '_>,
    keys: UpdatePerpMarketStatusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_status_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_status_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_status_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_status_verify_writable_privileges(accounts)?;
    update_perp_market_status_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketPausedOperationsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketPausedOperationsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketPausedOperationsAccounts<'_, '_>>
for UpdatePerpMarketPausedOperationsKeys {
    fn from(accounts: UpdatePerpMarketPausedOperationsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketPausedOperationsKeys>
for [AccountMeta; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketPausedOperationsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketPausedOperationsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketPausedOperationsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketPausedOperationsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketPausedOperationsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_DISCM: [u8; 8] = [
    53,
    16,
    136,
    132,
    30,
    220,
    121,
    85,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketPausedOperationsIxArgs {
    pub paused_operations: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketPausedOperationsIxData(
    pub UpdatePerpMarketPausedOperationsIxArgs,
);
impl From<UpdatePerpMarketPausedOperationsIxArgs>
for UpdatePerpMarketPausedOperationsIxData {
    fn from(args: UpdatePerpMarketPausedOperationsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketPausedOperationsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketPausedOperationsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_paused_operations_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketPausedOperationsKeys,
    args: UpdatePerpMarketPausedOperationsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_PAUSED_OPERATIONS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketPausedOperationsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_paused_operations_ix(
    keys: UpdatePerpMarketPausedOperationsKeys,
    args: UpdatePerpMarketPausedOperationsIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_paused_operations_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_paused_operations_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketPausedOperationsAccounts<'_, '_>,
    args: UpdatePerpMarketPausedOperationsIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketPausedOperationsKeys = accounts.into();
    let ix = update_perp_market_paused_operations_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_paused_operations_invoke(
    accounts: UpdatePerpMarketPausedOperationsAccounts<'_, '_>,
    args: UpdatePerpMarketPausedOperationsIxArgs,
) -> ProgramResult {
    update_perp_market_paused_operations_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_paused_operations_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketPausedOperationsAccounts<'_, '_>,
    args: UpdatePerpMarketPausedOperationsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketPausedOperationsKeys = accounts.into();
    let ix = update_perp_market_paused_operations_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_paused_operations_invoke_signed(
    accounts: UpdatePerpMarketPausedOperationsAccounts<'_, '_>,
    args: UpdatePerpMarketPausedOperationsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_paused_operations_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_paused_operations_verify_account_keys(
    accounts: UpdatePerpMarketPausedOperationsAccounts<'_, '_>,
    keys: UpdatePerpMarketPausedOperationsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_paused_operations_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_paused_operations_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_paused_operations_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketPausedOperationsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_paused_operations_verify_writable_privileges(accounts)?;
    update_perp_market_paused_operations_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketContractTierAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketContractTierKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketContractTierAccounts<'_, '_>>
for UpdatePerpMarketContractTierKeys {
    fn from(accounts: UpdatePerpMarketContractTierAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketContractTierKeys>
for [AccountMeta; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketContractTierKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketContractTierKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketContractTierAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketContractTierAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketContractTierAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_CONTRACT_TIER_IX_DISCM: [u8; 8] = [
    236,
    128,
    15,
    95,
    203,
    214,
    68,
    117,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketContractTierIxArgs {
    pub contract_tier: ContractTier,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketContractTierIxData(pub UpdatePerpMarketContractTierIxArgs);
impl From<UpdatePerpMarketContractTierIxArgs> for UpdatePerpMarketContractTierIxData {
    fn from(args: UpdatePerpMarketContractTierIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketContractTierIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_CONTRACT_TIER_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_CONTRACT_TIER_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketContractTierIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_CONTRACT_TIER_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_contract_tier_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketContractTierKeys,
    args: UpdatePerpMarketContractTierIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_CONTRACT_TIER_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketContractTierIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_contract_tier_ix(
    keys: UpdatePerpMarketContractTierKeys,
    args: UpdatePerpMarketContractTierIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_contract_tier_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_contract_tier_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketContractTierAccounts<'_, '_>,
    args: UpdatePerpMarketContractTierIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketContractTierKeys = accounts.into();
    let ix = update_perp_market_contract_tier_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_contract_tier_invoke(
    accounts: UpdatePerpMarketContractTierAccounts<'_, '_>,
    args: UpdatePerpMarketContractTierIxArgs,
) -> ProgramResult {
    update_perp_market_contract_tier_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_contract_tier_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketContractTierAccounts<'_, '_>,
    args: UpdatePerpMarketContractTierIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketContractTierKeys = accounts.into();
    let ix = update_perp_market_contract_tier_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_contract_tier_invoke_signed(
    accounts: UpdatePerpMarketContractTierAccounts<'_, '_>,
    args: UpdatePerpMarketContractTierIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_contract_tier_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_contract_tier_verify_account_keys(
    accounts: UpdatePerpMarketContractTierAccounts<'_, '_>,
    keys: UpdatePerpMarketContractTierKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_contract_tier_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketContractTierAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_contract_tier_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketContractTierAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_contract_tier_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketContractTierAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_contract_tier_verify_writable_privileges(accounts)?;
    update_perp_market_contract_tier_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketImfFactorAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketImfFactorKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketImfFactorAccounts<'_, '_>> for UpdatePerpMarketImfFactorKeys {
    fn from(accounts: UpdatePerpMarketImfFactorAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketImfFactorKeys>
for [AccountMeta; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketImfFactorKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketImfFactorKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketImfFactorAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketImfFactorAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketImfFactorAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_IMF_FACTOR_IX_DISCM: [u8; 8] = [
    207,
    194,
    56,
    132,
    35,
    67,
    71,
    244,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketImfFactorIxArgs {
    pub imf_factor: u32,
    pub unrealized_pnl_imf_factor: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketImfFactorIxData(pub UpdatePerpMarketImfFactorIxArgs);
impl From<UpdatePerpMarketImfFactorIxArgs> for UpdatePerpMarketImfFactorIxData {
    fn from(args: UpdatePerpMarketImfFactorIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketImfFactorIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_IMF_FACTOR_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_IMF_FACTOR_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketImfFactorIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_IMF_FACTOR_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_imf_factor_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketImfFactorKeys,
    args: UpdatePerpMarketImfFactorIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_IMF_FACTOR_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketImfFactorIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_imf_factor_ix(
    keys: UpdatePerpMarketImfFactorKeys,
    args: UpdatePerpMarketImfFactorIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_imf_factor_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_imf_factor_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketImfFactorAccounts<'_, '_>,
    args: UpdatePerpMarketImfFactorIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketImfFactorKeys = accounts.into();
    let ix = update_perp_market_imf_factor_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_imf_factor_invoke(
    accounts: UpdatePerpMarketImfFactorAccounts<'_, '_>,
    args: UpdatePerpMarketImfFactorIxArgs,
) -> ProgramResult {
    update_perp_market_imf_factor_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_imf_factor_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketImfFactorAccounts<'_, '_>,
    args: UpdatePerpMarketImfFactorIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketImfFactorKeys = accounts.into();
    let ix = update_perp_market_imf_factor_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_imf_factor_invoke_signed(
    accounts: UpdatePerpMarketImfFactorAccounts<'_, '_>,
    args: UpdatePerpMarketImfFactorIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_imf_factor_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_imf_factor_verify_account_keys(
    accounts: UpdatePerpMarketImfFactorAccounts<'_, '_>,
    keys: UpdatePerpMarketImfFactorKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_imf_factor_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketImfFactorAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_imf_factor_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketImfFactorAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_imf_factor_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketImfFactorAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_imf_factor_verify_writable_privileges(accounts)?;
    update_perp_market_imf_factor_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketUnrealizedAssetWeightAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketUnrealizedAssetWeightKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, '_>>
for UpdatePerpMarketUnrealizedAssetWeightKeys {
    fn from(accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketUnrealizedAssetWeightKeys>
for [AccountMeta; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketUnrealizedAssetWeightKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketUnrealizedAssetWeightKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN],
> for UpdatePerpMarketUnrealizedAssetWeightAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_DISCM: [u8; 8] = [
    135,
    132,
    205,
    165,
    109,
    150,
    166,
    106,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketUnrealizedAssetWeightIxArgs {
    pub unrealized_initial_asset_weight: u32,
    pub unrealized_maintenance_asset_weight: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketUnrealizedAssetWeightIxData(
    pub UpdatePerpMarketUnrealizedAssetWeightIxArgs,
);
impl From<UpdatePerpMarketUnrealizedAssetWeightIxArgs>
for UpdatePerpMarketUnrealizedAssetWeightIxData {
    fn from(args: UpdatePerpMarketUnrealizedAssetWeightIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketUnrealizedAssetWeightIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketUnrealizedAssetWeightIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_unrealized_asset_weight_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketUnrealizedAssetWeightKeys,
    args: UpdatePerpMarketUnrealizedAssetWeightIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_UNREALIZED_ASSET_WEIGHT_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketUnrealizedAssetWeightIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_unrealized_asset_weight_ix(
    keys: UpdatePerpMarketUnrealizedAssetWeightKeys,
    args: UpdatePerpMarketUnrealizedAssetWeightIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_unrealized_asset_weight_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_unrealized_asset_weight_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, '_>,
    args: UpdatePerpMarketUnrealizedAssetWeightIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketUnrealizedAssetWeightKeys = accounts.into();
    let ix = update_perp_market_unrealized_asset_weight_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_unrealized_asset_weight_invoke(
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, '_>,
    args: UpdatePerpMarketUnrealizedAssetWeightIxArgs,
) -> ProgramResult {
    update_perp_market_unrealized_asset_weight_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_unrealized_asset_weight_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, '_>,
    args: UpdatePerpMarketUnrealizedAssetWeightIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketUnrealizedAssetWeightKeys = accounts.into();
    let ix = update_perp_market_unrealized_asset_weight_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_unrealized_asset_weight_invoke_signed(
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, '_>,
    args: UpdatePerpMarketUnrealizedAssetWeightIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_unrealized_asset_weight_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_unrealized_asset_weight_verify_account_keys(
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'_, '_>,
    keys: UpdatePerpMarketUnrealizedAssetWeightKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_unrealized_asset_weight_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_unrealized_asset_weight_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_unrealized_asset_weight_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketUnrealizedAssetWeightAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_unrealized_asset_weight_verify_writable_privileges(accounts)?;
    update_perp_market_unrealized_asset_weight_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketConcentrationCoefAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketConcentrationCoefKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketConcentrationCoefAccounts<'_, '_>>
for UpdatePerpMarketConcentrationCoefKeys {
    fn from(accounts: UpdatePerpMarketConcentrationCoefAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketConcentrationCoefKeys>
for [AccountMeta; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketConcentrationCoefKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketConcentrationCoefKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketConcentrationCoefAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketConcentrationCoefAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketConcentrationCoefAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_DISCM: [u8; 8] = [
    24,
    78,
    232,
    126,
    169,
    176,
    230,
    16,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketConcentrationCoefIxArgs {
    pub concentration_scale: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketConcentrationCoefIxData(
    pub UpdatePerpMarketConcentrationCoefIxArgs,
);
impl From<UpdatePerpMarketConcentrationCoefIxArgs>
for UpdatePerpMarketConcentrationCoefIxData {
    fn from(args: UpdatePerpMarketConcentrationCoefIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketConcentrationCoefIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketConcentrationCoefIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_concentration_coef_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketConcentrationCoefKeys,
    args: UpdatePerpMarketConcentrationCoefIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_CONCENTRATION_COEF_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketConcentrationCoefIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_concentration_coef_ix(
    keys: UpdatePerpMarketConcentrationCoefKeys,
    args: UpdatePerpMarketConcentrationCoefIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_concentration_coef_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_concentration_coef_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'_, '_>,
    args: UpdatePerpMarketConcentrationCoefIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketConcentrationCoefKeys = accounts.into();
    let ix = update_perp_market_concentration_coef_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_concentration_coef_invoke(
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'_, '_>,
    args: UpdatePerpMarketConcentrationCoefIxArgs,
) -> ProgramResult {
    update_perp_market_concentration_coef_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_concentration_coef_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'_, '_>,
    args: UpdatePerpMarketConcentrationCoefIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketConcentrationCoefKeys = accounts.into();
    let ix = update_perp_market_concentration_coef_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_concentration_coef_invoke_signed(
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'_, '_>,
    args: UpdatePerpMarketConcentrationCoefIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_concentration_coef_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_concentration_coef_verify_account_keys(
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'_, '_>,
    keys: UpdatePerpMarketConcentrationCoefKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_concentration_coef_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_concentration_coef_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_concentration_coef_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketConcentrationCoefAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_concentration_coef_verify_writable_privileges(accounts)?;
    update_perp_market_concentration_coef_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketCurveUpdateIntensityAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketCurveUpdateIntensityKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketCurveUpdateIntensityAccounts<'_, '_>>
for UpdatePerpMarketCurveUpdateIntensityKeys {
    fn from(accounts: UpdatePerpMarketCurveUpdateIntensityAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketCurveUpdateIntensityKeys>
for [AccountMeta; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketCurveUpdateIntensityKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketCurveUpdateIntensityKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketCurveUpdateIntensityAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN],
> for UpdatePerpMarketCurveUpdateIntensityAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_DISCM: [u8; 8] = [
    50,
    131,
    6,
    156,
    226,
    231,
    189,
    72,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketCurveUpdateIntensityIxArgs {
    pub curve_update_intensity: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketCurveUpdateIntensityIxData(
    pub UpdatePerpMarketCurveUpdateIntensityIxArgs,
);
impl From<UpdatePerpMarketCurveUpdateIntensityIxArgs>
for UpdatePerpMarketCurveUpdateIntensityIxData {
    fn from(args: UpdatePerpMarketCurveUpdateIntensityIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketCurveUpdateIntensityIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketCurveUpdateIntensityIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_curve_update_intensity_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketCurveUpdateIntensityKeys,
    args: UpdatePerpMarketCurveUpdateIntensityIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_CURVE_UPDATE_INTENSITY_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketCurveUpdateIntensityIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_curve_update_intensity_ix(
    keys: UpdatePerpMarketCurveUpdateIntensityKeys,
    args: UpdatePerpMarketCurveUpdateIntensityIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_curve_update_intensity_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_curve_update_intensity_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'_, '_>,
    args: UpdatePerpMarketCurveUpdateIntensityIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketCurveUpdateIntensityKeys = accounts.into();
    let ix = update_perp_market_curve_update_intensity_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_curve_update_intensity_invoke(
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'_, '_>,
    args: UpdatePerpMarketCurveUpdateIntensityIxArgs,
) -> ProgramResult {
    update_perp_market_curve_update_intensity_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_curve_update_intensity_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'_, '_>,
    args: UpdatePerpMarketCurveUpdateIntensityIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketCurveUpdateIntensityKeys = accounts.into();
    let ix = update_perp_market_curve_update_intensity_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_curve_update_intensity_invoke_signed(
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'_, '_>,
    args: UpdatePerpMarketCurveUpdateIntensityIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_curve_update_intensity_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_curve_update_intensity_verify_account_keys(
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'_, '_>,
    keys: UpdatePerpMarketCurveUpdateIntensityKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_curve_update_intensity_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_curve_update_intensity_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_curve_update_intensity_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketCurveUpdateIntensityAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_curve_update_intensity_verify_writable_privileges(accounts)?;
    update_perp_market_curve_update_intensity_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketTargetBaseAssetAmountPerLpKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, '_>>
for UpdatePerpMarketTargetBaseAssetAmountPerLpKeys {
    fn from(accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketTargetBaseAssetAmountPerLpKeys>
for [AccountMeta; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketTargetBaseAssetAmountPerLpKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketTargetBaseAssetAmountPerLpKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, 'info>>
for [AccountInfo<
    'info,
>; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN] {
    fn from(
        accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, 'info>,
    ) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<
        'info,
    >; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN],
> for UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_DISCM: [u8; 8] = [
    62,
    87,
    68,
    115,
    29,
    150,
    150,
    165,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs {
    pub target_base_asset_amount_per_lp: i32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketTargetBaseAssetAmountPerLpIxData(
    pub UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
);
impl From<UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs>
for UpdatePerpMarketTargetBaseAssetAmountPerLpIxData {
    fn from(args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketTargetBaseAssetAmountPerLpIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_DISCM,
                        maybe_discm
                    ),
                ),
            );
        }
        Ok(
            Self(
                UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs::deserialize(
                    &mut reader,
                )?,
            ),
        )
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_target_base_asset_amount_per_lp_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketTargetBaseAssetAmountPerLpKeys,
    args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_TARGET_BASE_ASSET_AMOUNT_PER_LP_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketTargetBaseAssetAmountPerLpIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_target_base_asset_amount_per_lp_ix(
    keys: UpdatePerpMarketTargetBaseAssetAmountPerLpKeys,
    args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_target_base_asset_amount_per_lp_ix_with_program_id(
        crate::ID,
        keys,
        args,
    )
}
pub fn update_perp_market_target_base_asset_amount_per_lp_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, '_>,
    args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketTargetBaseAssetAmountPerLpKeys = accounts.into();
    let ix = update_perp_market_target_base_asset_amount_per_lp_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_target_base_asset_amount_per_lp_invoke(
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, '_>,
    args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
) -> ProgramResult {
    update_perp_market_target_base_asset_amount_per_lp_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_target_base_asset_amount_per_lp_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, '_>,
    args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketTargetBaseAssetAmountPerLpKeys = accounts.into();
    let ix = update_perp_market_target_base_asset_amount_per_lp_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_target_base_asset_amount_per_lp_invoke_signed(
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, '_>,
    args: UpdatePerpMarketTargetBaseAssetAmountPerLpIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_target_base_asset_amount_per_lp_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_target_base_asset_amount_per_lp_verify_account_keys(
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'_, '_>,
    keys: UpdatePerpMarketTargetBaseAssetAmountPerLpKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_target_base_asset_amount_per_lp_verify_writable_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_target_base_asset_amount_per_lp_verify_signer_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_target_base_asset_amount_per_lp_verify_account_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketTargetBaseAssetAmountPerLpAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_target_base_asset_amount_per_lp_verify_writable_privileges(
        accounts,
    )?;
    update_perp_market_target_base_asset_amount_per_lp_verify_signer_privileges(
        accounts,
    )?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketPerLpBaseAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketPerLpBaseKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketPerLpBaseAccounts<'_, '_>> for UpdatePerpMarketPerLpBaseKeys {
    fn from(accounts: UpdatePerpMarketPerLpBaseAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketPerLpBaseKeys>
for [AccountMeta; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketPerLpBaseKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketPerLpBaseKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketPerLpBaseAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketPerLpBaseAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketPerLpBaseAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_PER_LP_BASE_IX_DISCM: [u8; 8] = [
    103,
    152,
    103,
    102,
    89,
    144,
    193,
    71,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketPerLpBaseIxArgs {
    pub per_lp_base: i8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketPerLpBaseIxData(pub UpdatePerpMarketPerLpBaseIxArgs);
impl From<UpdatePerpMarketPerLpBaseIxArgs> for UpdatePerpMarketPerLpBaseIxData {
    fn from(args: UpdatePerpMarketPerLpBaseIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketPerLpBaseIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_PER_LP_BASE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_PER_LP_BASE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketPerLpBaseIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_PER_LP_BASE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_per_lp_base_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketPerLpBaseKeys,
    args: UpdatePerpMarketPerLpBaseIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_PER_LP_BASE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketPerLpBaseIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_per_lp_base_ix(
    keys: UpdatePerpMarketPerLpBaseKeys,
    args: UpdatePerpMarketPerLpBaseIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_per_lp_base_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_per_lp_base_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketPerLpBaseAccounts<'_, '_>,
    args: UpdatePerpMarketPerLpBaseIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketPerLpBaseKeys = accounts.into();
    let ix = update_perp_market_per_lp_base_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_per_lp_base_invoke(
    accounts: UpdatePerpMarketPerLpBaseAccounts<'_, '_>,
    args: UpdatePerpMarketPerLpBaseIxArgs,
) -> ProgramResult {
    update_perp_market_per_lp_base_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_per_lp_base_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketPerLpBaseAccounts<'_, '_>,
    args: UpdatePerpMarketPerLpBaseIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketPerLpBaseKeys = accounts.into();
    let ix = update_perp_market_per_lp_base_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_per_lp_base_invoke_signed(
    accounts: UpdatePerpMarketPerLpBaseAccounts<'_, '_>,
    args: UpdatePerpMarketPerLpBaseIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_per_lp_base_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_per_lp_base_verify_account_keys(
    accounts: UpdatePerpMarketPerLpBaseAccounts<'_, '_>,
    keys: UpdatePerpMarketPerLpBaseKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_per_lp_base_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketPerLpBaseAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_per_lp_base_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketPerLpBaseAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_per_lp_base_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketPerLpBaseAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_per_lp_base_verify_writable_privileges(accounts)?;
    update_perp_market_per_lp_base_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateLpCooldownTimeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateLpCooldownTimeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateLpCooldownTimeAccounts<'_, '_>> for UpdateLpCooldownTimeKeys {
    fn from(accounts: UpdateLpCooldownTimeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateLpCooldownTimeKeys>
for [AccountMeta; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateLpCooldownTimeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN]>
for UpdateLpCooldownTimeKeys {
    fn from(pubkeys: [Pubkey; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateLpCooldownTimeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateLpCooldownTimeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN]>
for UpdateLpCooldownTimeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_LP_COOLDOWN_TIME_IX_DISCM: [u8; 8] = [
    198,
    133,
    88,
    41,
    241,
    119,
    61,
    14,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateLpCooldownTimeIxArgs {
    pub lp_cooldown_time: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateLpCooldownTimeIxData(pub UpdateLpCooldownTimeIxArgs);
impl From<UpdateLpCooldownTimeIxArgs> for UpdateLpCooldownTimeIxData {
    fn from(args: UpdateLpCooldownTimeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateLpCooldownTimeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_LP_COOLDOWN_TIME_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_LP_COOLDOWN_TIME_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateLpCooldownTimeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_LP_COOLDOWN_TIME_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_lp_cooldown_time_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateLpCooldownTimeKeys,
    args: UpdateLpCooldownTimeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_LP_COOLDOWN_TIME_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateLpCooldownTimeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_lp_cooldown_time_ix(
    keys: UpdateLpCooldownTimeKeys,
    args: UpdateLpCooldownTimeIxArgs,
) -> std::io::Result<Instruction> {
    update_lp_cooldown_time_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_lp_cooldown_time_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateLpCooldownTimeAccounts<'_, '_>,
    args: UpdateLpCooldownTimeIxArgs,
) -> ProgramResult {
    let keys: UpdateLpCooldownTimeKeys = accounts.into();
    let ix = update_lp_cooldown_time_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_lp_cooldown_time_invoke(
    accounts: UpdateLpCooldownTimeAccounts<'_, '_>,
    args: UpdateLpCooldownTimeIxArgs,
) -> ProgramResult {
    update_lp_cooldown_time_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_lp_cooldown_time_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateLpCooldownTimeAccounts<'_, '_>,
    args: UpdateLpCooldownTimeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateLpCooldownTimeKeys = accounts.into();
    let ix = update_lp_cooldown_time_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_lp_cooldown_time_invoke_signed(
    accounts: UpdateLpCooldownTimeAccounts<'_, '_>,
    args: UpdateLpCooldownTimeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_lp_cooldown_time_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_lp_cooldown_time_verify_account_keys(
    accounts: UpdateLpCooldownTimeAccounts<'_, '_>,
    keys: UpdateLpCooldownTimeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_lp_cooldown_time_verify_writable_privileges<'me, 'info>(
    accounts: UpdateLpCooldownTimeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_lp_cooldown_time_verify_signer_privileges<'me, 'info>(
    accounts: UpdateLpCooldownTimeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_lp_cooldown_time_verify_account_privileges<'me, 'info>(
    accounts: UpdateLpCooldownTimeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_lp_cooldown_time_verify_writable_privileges(accounts)?;
    update_lp_cooldown_time_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpFeeStructureAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpFeeStructureKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdatePerpFeeStructureAccounts<'_, '_>> for UpdatePerpFeeStructureKeys {
    fn from(accounts: UpdatePerpFeeStructureAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdatePerpFeeStructureKeys>
for [AccountMeta; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpFeeStructureKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN]>
for UpdatePerpFeeStructureKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdatePerpFeeStructureAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpFeeStructureAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN]>
for UpdatePerpFeeStructureAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_PERP_FEE_STRUCTURE_IX_DISCM: [u8; 8] = [
    23,
    178,
    111,
    203,
    73,
    22,
    140,
    75,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpFeeStructureIxArgs {
    pub fee_structure: FeeStructure,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpFeeStructureIxData(pub UpdatePerpFeeStructureIxArgs);
impl From<UpdatePerpFeeStructureIxArgs> for UpdatePerpFeeStructureIxData {
    fn from(args: UpdatePerpFeeStructureIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpFeeStructureIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_FEE_STRUCTURE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_FEE_STRUCTURE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpFeeStructureIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_FEE_STRUCTURE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_fee_structure_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpFeeStructureKeys,
    args: UpdatePerpFeeStructureIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_FEE_STRUCTURE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpFeeStructureIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_fee_structure_ix(
    keys: UpdatePerpFeeStructureKeys,
    args: UpdatePerpFeeStructureIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_fee_structure_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_fee_structure_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpFeeStructureAccounts<'_, '_>,
    args: UpdatePerpFeeStructureIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpFeeStructureKeys = accounts.into();
    let ix = update_perp_fee_structure_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_fee_structure_invoke(
    accounts: UpdatePerpFeeStructureAccounts<'_, '_>,
    args: UpdatePerpFeeStructureIxArgs,
) -> ProgramResult {
    update_perp_fee_structure_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_fee_structure_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpFeeStructureAccounts<'_, '_>,
    args: UpdatePerpFeeStructureIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpFeeStructureKeys = accounts.into();
    let ix = update_perp_fee_structure_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_fee_structure_invoke_signed(
    accounts: UpdatePerpFeeStructureAccounts<'_, '_>,
    args: UpdatePerpFeeStructureIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_fee_structure_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_fee_structure_verify_account_keys(
    accounts: UpdatePerpFeeStructureAccounts<'_, '_>,
    keys: UpdatePerpFeeStructureKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_fee_structure_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpFeeStructureAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_fee_structure_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpFeeStructureAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_fee_structure_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpFeeStructureAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_fee_structure_verify_writable_privileges(accounts)?;
    update_perp_fee_structure_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotFeeStructureAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotFeeStructureKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateSpotFeeStructureAccounts<'_, '_>> for UpdateSpotFeeStructureKeys {
    fn from(accounts: UpdateSpotFeeStructureAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateSpotFeeStructureKeys>
for [AccountMeta; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotFeeStructureKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN]>
for UpdateSpotFeeStructureKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateSpotFeeStructureAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotFeeStructureAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN]>
for UpdateSpotFeeStructureAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_SPOT_FEE_STRUCTURE_IX_DISCM: [u8; 8] = [
    97,
    216,
    105,
    131,
    113,
    246,
    142,
    141,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotFeeStructureIxArgs {
    pub fee_structure: FeeStructure,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotFeeStructureIxData(pub UpdateSpotFeeStructureIxArgs);
impl From<UpdateSpotFeeStructureIxArgs> for UpdateSpotFeeStructureIxData {
    fn from(args: UpdateSpotFeeStructureIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotFeeStructureIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_FEE_STRUCTURE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_FEE_STRUCTURE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotFeeStructureIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_FEE_STRUCTURE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_fee_structure_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotFeeStructureKeys,
    args: UpdateSpotFeeStructureIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_FEE_STRUCTURE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotFeeStructureIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_fee_structure_ix(
    keys: UpdateSpotFeeStructureKeys,
    args: UpdateSpotFeeStructureIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_fee_structure_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_fee_structure_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotFeeStructureAccounts<'_, '_>,
    args: UpdateSpotFeeStructureIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotFeeStructureKeys = accounts.into();
    let ix = update_spot_fee_structure_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_fee_structure_invoke(
    accounts: UpdateSpotFeeStructureAccounts<'_, '_>,
    args: UpdateSpotFeeStructureIxArgs,
) -> ProgramResult {
    update_spot_fee_structure_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_fee_structure_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotFeeStructureAccounts<'_, '_>,
    args: UpdateSpotFeeStructureIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotFeeStructureKeys = accounts.into();
    let ix = update_spot_fee_structure_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_fee_structure_invoke_signed(
    accounts: UpdateSpotFeeStructureAccounts<'_, '_>,
    args: UpdateSpotFeeStructureIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_fee_structure_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_fee_structure_verify_account_keys(
    accounts: UpdateSpotFeeStructureAccounts<'_, '_>,
    keys: UpdateSpotFeeStructureKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_fee_structure_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotFeeStructureAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_fee_structure_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotFeeStructureAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_fee_structure_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotFeeStructureAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_fee_structure_verify_writable_privileges(accounts)?;
    update_spot_fee_structure_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateInitialPctToLiquidateAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateInitialPctToLiquidateKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateInitialPctToLiquidateAccounts<'_, '_>>
for UpdateInitialPctToLiquidateKeys {
    fn from(accounts: UpdateInitialPctToLiquidateAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateInitialPctToLiquidateKeys>
for [AccountMeta; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateInitialPctToLiquidateKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN]>
for UpdateInitialPctToLiquidateKeys {
    fn from(pubkeys: [Pubkey; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateInitialPctToLiquidateAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateInitialPctToLiquidateAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN]>
for UpdateInitialPctToLiquidateAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_DISCM: [u8; 8] = [
    210,
    133,
    225,
    128,
    194,
    50,
    13,
    109,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateInitialPctToLiquidateIxArgs {
    pub initial_pct_to_liquidate: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateInitialPctToLiquidateIxData(pub UpdateInitialPctToLiquidateIxArgs);
impl From<UpdateInitialPctToLiquidateIxArgs> for UpdateInitialPctToLiquidateIxData {
    fn from(args: UpdateInitialPctToLiquidateIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateInitialPctToLiquidateIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateInitialPctToLiquidateIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_initial_pct_to_liquidate_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateInitialPctToLiquidateKeys,
    args: UpdateInitialPctToLiquidateIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_INITIAL_PCT_TO_LIQUIDATE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateInitialPctToLiquidateIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_initial_pct_to_liquidate_ix(
    keys: UpdateInitialPctToLiquidateKeys,
    args: UpdateInitialPctToLiquidateIxArgs,
) -> std::io::Result<Instruction> {
    update_initial_pct_to_liquidate_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_initial_pct_to_liquidate_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateInitialPctToLiquidateAccounts<'_, '_>,
    args: UpdateInitialPctToLiquidateIxArgs,
) -> ProgramResult {
    let keys: UpdateInitialPctToLiquidateKeys = accounts.into();
    let ix = update_initial_pct_to_liquidate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_initial_pct_to_liquidate_invoke(
    accounts: UpdateInitialPctToLiquidateAccounts<'_, '_>,
    args: UpdateInitialPctToLiquidateIxArgs,
) -> ProgramResult {
    update_initial_pct_to_liquidate_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_initial_pct_to_liquidate_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateInitialPctToLiquidateAccounts<'_, '_>,
    args: UpdateInitialPctToLiquidateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateInitialPctToLiquidateKeys = accounts.into();
    let ix = update_initial_pct_to_liquidate_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_initial_pct_to_liquidate_invoke_signed(
    accounts: UpdateInitialPctToLiquidateAccounts<'_, '_>,
    args: UpdateInitialPctToLiquidateIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_initial_pct_to_liquidate_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_initial_pct_to_liquidate_verify_account_keys(
    accounts: UpdateInitialPctToLiquidateAccounts<'_, '_>,
    keys: UpdateInitialPctToLiquidateKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_initial_pct_to_liquidate_verify_writable_privileges<'me, 'info>(
    accounts: UpdateInitialPctToLiquidateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_initial_pct_to_liquidate_verify_signer_privileges<'me, 'info>(
    accounts: UpdateInitialPctToLiquidateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_initial_pct_to_liquidate_verify_account_privileges<'me, 'info>(
    accounts: UpdateInitialPctToLiquidateAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_initial_pct_to_liquidate_verify_writable_privileges(accounts)?;
    update_initial_pct_to_liquidate_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateLiquidationDurationAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateLiquidationDurationKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateLiquidationDurationAccounts<'_, '_>> for UpdateLiquidationDurationKeys {
    fn from(accounts: UpdateLiquidationDurationAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateLiquidationDurationKeys>
for [AccountMeta; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateLiquidationDurationKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN]>
for UpdateLiquidationDurationKeys {
    fn from(pubkeys: [Pubkey; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateLiquidationDurationAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateLiquidationDurationAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN]>
for UpdateLiquidationDurationAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_LIQUIDATION_DURATION_IX_DISCM: [u8; 8] = [
    28,
    154,
    20,
    249,
    102,
    192,
    73,
    71,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateLiquidationDurationIxArgs {
    pub liquidation_duration: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateLiquidationDurationIxData(pub UpdateLiquidationDurationIxArgs);
impl From<UpdateLiquidationDurationIxArgs> for UpdateLiquidationDurationIxData {
    fn from(args: UpdateLiquidationDurationIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateLiquidationDurationIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_LIQUIDATION_DURATION_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_LIQUIDATION_DURATION_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateLiquidationDurationIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_LIQUIDATION_DURATION_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_liquidation_duration_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateLiquidationDurationKeys,
    args: UpdateLiquidationDurationIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_LIQUIDATION_DURATION_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateLiquidationDurationIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_liquidation_duration_ix(
    keys: UpdateLiquidationDurationKeys,
    args: UpdateLiquidationDurationIxArgs,
) -> std::io::Result<Instruction> {
    update_liquidation_duration_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_liquidation_duration_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateLiquidationDurationAccounts<'_, '_>,
    args: UpdateLiquidationDurationIxArgs,
) -> ProgramResult {
    let keys: UpdateLiquidationDurationKeys = accounts.into();
    let ix = update_liquidation_duration_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_liquidation_duration_invoke(
    accounts: UpdateLiquidationDurationAccounts<'_, '_>,
    args: UpdateLiquidationDurationIxArgs,
) -> ProgramResult {
    update_liquidation_duration_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_liquidation_duration_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateLiquidationDurationAccounts<'_, '_>,
    args: UpdateLiquidationDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateLiquidationDurationKeys = accounts.into();
    let ix = update_liquidation_duration_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_liquidation_duration_invoke_signed(
    accounts: UpdateLiquidationDurationAccounts<'_, '_>,
    args: UpdateLiquidationDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_liquidation_duration_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_liquidation_duration_verify_account_keys(
    accounts: UpdateLiquidationDurationAccounts<'_, '_>,
    keys: UpdateLiquidationDurationKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_liquidation_duration_verify_writable_privileges<'me, 'info>(
    accounts: UpdateLiquidationDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_liquidation_duration_verify_signer_privileges<'me, 'info>(
    accounts: UpdateLiquidationDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_liquidation_duration_verify_account_privileges<'me, 'info>(
    accounts: UpdateLiquidationDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_liquidation_duration_verify_writable_privileges(accounts)?;
    update_liquidation_duration_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateLiquidationMarginBufferRatioAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateLiquidationMarginBufferRatioKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateLiquidationMarginBufferRatioAccounts<'_, '_>>
for UpdateLiquidationMarginBufferRatioKeys {
    fn from(accounts: UpdateLiquidationMarginBufferRatioAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateLiquidationMarginBufferRatioKeys>
for [AccountMeta; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateLiquidationMarginBufferRatioKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN]>
for UpdateLiquidationMarginBufferRatioKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateLiquidationMarginBufferRatioAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateLiquidationMarginBufferRatioAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN]>
for UpdateLiquidationMarginBufferRatioAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_DISCM: [u8; 8] = [
    132,
    224,
    243,
    160,
    154,
    82,
    97,
    215,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateLiquidationMarginBufferRatioIxArgs {
    pub liquidation_margin_buffer_ratio: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateLiquidationMarginBufferRatioIxData(
    pub UpdateLiquidationMarginBufferRatioIxArgs,
);
impl From<UpdateLiquidationMarginBufferRatioIxArgs>
for UpdateLiquidationMarginBufferRatioIxData {
    fn from(args: UpdateLiquidationMarginBufferRatioIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateLiquidationMarginBufferRatioIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateLiquidationMarginBufferRatioIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_liquidation_margin_buffer_ratio_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateLiquidationMarginBufferRatioKeys,
    args: UpdateLiquidationMarginBufferRatioIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_LIQUIDATION_MARGIN_BUFFER_RATIO_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateLiquidationMarginBufferRatioIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_liquidation_margin_buffer_ratio_ix(
    keys: UpdateLiquidationMarginBufferRatioKeys,
    args: UpdateLiquidationMarginBufferRatioIxArgs,
) -> std::io::Result<Instruction> {
    update_liquidation_margin_buffer_ratio_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_liquidation_margin_buffer_ratio_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'_, '_>,
    args: UpdateLiquidationMarginBufferRatioIxArgs,
) -> ProgramResult {
    let keys: UpdateLiquidationMarginBufferRatioKeys = accounts.into();
    let ix = update_liquidation_margin_buffer_ratio_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_liquidation_margin_buffer_ratio_invoke(
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'_, '_>,
    args: UpdateLiquidationMarginBufferRatioIxArgs,
) -> ProgramResult {
    update_liquidation_margin_buffer_ratio_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_liquidation_margin_buffer_ratio_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'_, '_>,
    args: UpdateLiquidationMarginBufferRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateLiquidationMarginBufferRatioKeys = accounts.into();
    let ix = update_liquidation_margin_buffer_ratio_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_liquidation_margin_buffer_ratio_invoke_signed(
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'_, '_>,
    args: UpdateLiquidationMarginBufferRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_liquidation_margin_buffer_ratio_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_liquidation_margin_buffer_ratio_verify_account_keys(
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'_, '_>,
    keys: UpdateLiquidationMarginBufferRatioKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_liquidation_margin_buffer_ratio_verify_writable_privileges<'me, 'info>(
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_liquidation_margin_buffer_ratio_verify_signer_privileges<'me, 'info>(
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_liquidation_margin_buffer_ratio_verify_account_privileges<'me, 'info>(
    accounts: UpdateLiquidationMarginBufferRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_liquidation_margin_buffer_ratio_verify_writable_privileges(accounts)?;
    update_liquidation_margin_buffer_ratio_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateOracleGuardRailsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateOracleGuardRailsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateOracleGuardRailsAccounts<'_, '_>> for UpdateOracleGuardRailsKeys {
    fn from(accounts: UpdateOracleGuardRailsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateOracleGuardRailsKeys>
for [AccountMeta; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateOracleGuardRailsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN]>
for UpdateOracleGuardRailsKeys {
    fn from(pubkeys: [Pubkey; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateOracleGuardRailsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateOracleGuardRailsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN]>
for UpdateOracleGuardRailsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_ORACLE_GUARD_RAILS_IX_DISCM: [u8; 8] = [
    131,
    112,
    10,
    59,
    32,
    54,
    40,
    164,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateOracleGuardRailsIxArgs {
    pub oracle_guard_rails: OracleGuardRails,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateOracleGuardRailsIxData(pub UpdateOracleGuardRailsIxArgs);
impl From<UpdateOracleGuardRailsIxArgs> for UpdateOracleGuardRailsIxData {
    fn from(args: UpdateOracleGuardRailsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateOracleGuardRailsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_ORACLE_GUARD_RAILS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_ORACLE_GUARD_RAILS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateOracleGuardRailsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_ORACLE_GUARD_RAILS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_oracle_guard_rails_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateOracleGuardRailsKeys,
    args: UpdateOracleGuardRailsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_ORACLE_GUARD_RAILS_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateOracleGuardRailsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_oracle_guard_rails_ix(
    keys: UpdateOracleGuardRailsKeys,
    args: UpdateOracleGuardRailsIxArgs,
) -> std::io::Result<Instruction> {
    update_oracle_guard_rails_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_oracle_guard_rails_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateOracleGuardRailsAccounts<'_, '_>,
    args: UpdateOracleGuardRailsIxArgs,
) -> ProgramResult {
    let keys: UpdateOracleGuardRailsKeys = accounts.into();
    let ix = update_oracle_guard_rails_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_oracle_guard_rails_invoke(
    accounts: UpdateOracleGuardRailsAccounts<'_, '_>,
    args: UpdateOracleGuardRailsIxArgs,
) -> ProgramResult {
    update_oracle_guard_rails_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_oracle_guard_rails_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateOracleGuardRailsAccounts<'_, '_>,
    args: UpdateOracleGuardRailsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateOracleGuardRailsKeys = accounts.into();
    let ix = update_oracle_guard_rails_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_oracle_guard_rails_invoke_signed(
    accounts: UpdateOracleGuardRailsAccounts<'_, '_>,
    args: UpdateOracleGuardRailsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_oracle_guard_rails_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_oracle_guard_rails_verify_account_keys(
    accounts: UpdateOracleGuardRailsAccounts<'_, '_>,
    keys: UpdateOracleGuardRailsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_oracle_guard_rails_verify_writable_privileges<'me, 'info>(
    accounts: UpdateOracleGuardRailsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_oracle_guard_rails_verify_signer_privileges<'me, 'info>(
    accounts: UpdateOracleGuardRailsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_oracle_guard_rails_verify_account_privileges<'me, 'info>(
    accounts: UpdateOracleGuardRailsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_oracle_guard_rails_verify_writable_privileges(accounts)?;
    update_oracle_guard_rails_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateStateSettlementDurationAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateStateSettlementDurationKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateStateSettlementDurationAccounts<'_, '_>>
for UpdateStateSettlementDurationKeys {
    fn from(accounts: UpdateStateSettlementDurationAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateStateSettlementDurationKeys>
for [AccountMeta; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateStateSettlementDurationKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN]>
for UpdateStateSettlementDurationKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateStateSettlementDurationAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateStateSettlementDurationAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN]>
for UpdateStateSettlementDurationAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_STATE_SETTLEMENT_DURATION_IX_DISCM: [u8; 8] = [
    97,
    68,
    199,
    235,
    131,
    80,
    61,
    173,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateStateSettlementDurationIxArgs {
    pub settlement_duration: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateStateSettlementDurationIxData(pub UpdateStateSettlementDurationIxArgs);
impl From<UpdateStateSettlementDurationIxArgs> for UpdateStateSettlementDurationIxData {
    fn from(args: UpdateStateSettlementDurationIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateStateSettlementDurationIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_STATE_SETTLEMENT_DURATION_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_STATE_SETTLEMENT_DURATION_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateStateSettlementDurationIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_STATE_SETTLEMENT_DURATION_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_state_settlement_duration_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateStateSettlementDurationKeys,
    args: UpdateStateSettlementDurationIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_STATE_SETTLEMENT_DURATION_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateStateSettlementDurationIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_state_settlement_duration_ix(
    keys: UpdateStateSettlementDurationKeys,
    args: UpdateStateSettlementDurationIxArgs,
) -> std::io::Result<Instruction> {
    update_state_settlement_duration_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_state_settlement_duration_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateStateSettlementDurationAccounts<'_, '_>,
    args: UpdateStateSettlementDurationIxArgs,
) -> ProgramResult {
    let keys: UpdateStateSettlementDurationKeys = accounts.into();
    let ix = update_state_settlement_duration_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_state_settlement_duration_invoke(
    accounts: UpdateStateSettlementDurationAccounts<'_, '_>,
    args: UpdateStateSettlementDurationIxArgs,
) -> ProgramResult {
    update_state_settlement_duration_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_state_settlement_duration_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateStateSettlementDurationAccounts<'_, '_>,
    args: UpdateStateSettlementDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateStateSettlementDurationKeys = accounts.into();
    let ix = update_state_settlement_duration_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_state_settlement_duration_invoke_signed(
    accounts: UpdateStateSettlementDurationAccounts<'_, '_>,
    args: UpdateStateSettlementDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_state_settlement_duration_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_state_settlement_duration_verify_account_keys(
    accounts: UpdateStateSettlementDurationAccounts<'_, '_>,
    keys: UpdateStateSettlementDurationKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_state_settlement_duration_verify_writable_privileges<'me, 'info>(
    accounts: UpdateStateSettlementDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_state_settlement_duration_verify_signer_privileges<'me, 'info>(
    accounts: UpdateStateSettlementDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_state_settlement_duration_verify_account_privileges<'me, 'info>(
    accounts: UpdateStateSettlementDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_state_settlement_duration_verify_writable_privileges(accounts)?;
    update_state_settlement_duration_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateStateMaxNumberOfSubAccountsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateStateMaxNumberOfSubAccountsKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateStateMaxNumberOfSubAccountsAccounts<'_, '_>>
for UpdateStateMaxNumberOfSubAccountsKeys {
    fn from(accounts: UpdateStateMaxNumberOfSubAccountsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateStateMaxNumberOfSubAccountsKeys>
for [AccountMeta; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateStateMaxNumberOfSubAccountsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN]>
for UpdateStateMaxNumberOfSubAccountsKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateStateMaxNumberOfSubAccountsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN],
> for UpdateStateMaxNumberOfSubAccountsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_DISCM: [u8; 8] = [
    155,
    123,
    214,
    2,
    221,
    166,
    204,
    85,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateStateMaxNumberOfSubAccountsIxArgs {
    pub max_number_of_sub_accounts: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateStateMaxNumberOfSubAccountsIxData(
    pub UpdateStateMaxNumberOfSubAccountsIxArgs,
);
impl From<UpdateStateMaxNumberOfSubAccountsIxArgs>
for UpdateStateMaxNumberOfSubAccountsIxData {
    fn from(args: UpdateStateMaxNumberOfSubAccountsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateStateMaxNumberOfSubAccountsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateStateMaxNumberOfSubAccountsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_state_max_number_of_sub_accounts_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateStateMaxNumberOfSubAccountsKeys,
    args: UpdateStateMaxNumberOfSubAccountsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_STATE_MAX_NUMBER_OF_SUB_ACCOUNTS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateStateMaxNumberOfSubAccountsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_state_max_number_of_sub_accounts_ix(
    keys: UpdateStateMaxNumberOfSubAccountsKeys,
    args: UpdateStateMaxNumberOfSubAccountsIxArgs,
) -> std::io::Result<Instruction> {
    update_state_max_number_of_sub_accounts_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_state_max_number_of_sub_accounts_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'_, '_>,
    args: UpdateStateMaxNumberOfSubAccountsIxArgs,
) -> ProgramResult {
    let keys: UpdateStateMaxNumberOfSubAccountsKeys = accounts.into();
    let ix = update_state_max_number_of_sub_accounts_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_state_max_number_of_sub_accounts_invoke(
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'_, '_>,
    args: UpdateStateMaxNumberOfSubAccountsIxArgs,
) -> ProgramResult {
    update_state_max_number_of_sub_accounts_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_state_max_number_of_sub_accounts_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'_, '_>,
    args: UpdateStateMaxNumberOfSubAccountsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateStateMaxNumberOfSubAccountsKeys = accounts.into();
    let ix = update_state_max_number_of_sub_accounts_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_state_max_number_of_sub_accounts_invoke_signed(
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'_, '_>,
    args: UpdateStateMaxNumberOfSubAccountsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_state_max_number_of_sub_accounts_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_state_max_number_of_sub_accounts_verify_account_keys(
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'_, '_>,
    keys: UpdateStateMaxNumberOfSubAccountsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_state_max_number_of_sub_accounts_verify_writable_privileges<'me, 'info>(
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_state_max_number_of_sub_accounts_verify_signer_privileges<'me, 'info>(
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_state_max_number_of_sub_accounts_verify_account_privileges<'me, 'info>(
    accounts: UpdateStateMaxNumberOfSubAccountsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_state_max_number_of_sub_accounts_verify_writable_privileges(accounts)?;
    update_state_max_number_of_sub_accounts_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateStateMaxInitializeUserFeeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateStateMaxInitializeUserFeeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateStateMaxInitializeUserFeeAccounts<'_, '_>>
for UpdateStateMaxInitializeUserFeeKeys {
    fn from(accounts: UpdateStateMaxInitializeUserFeeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateStateMaxInitializeUserFeeKeys>
for [AccountMeta; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateStateMaxInitializeUserFeeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN]>
for UpdateStateMaxInitializeUserFeeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateStateMaxInitializeUserFeeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateStateMaxInitializeUserFeeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN]>
for UpdateStateMaxInitializeUserFeeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_DISCM: [u8; 8] = [
    237,
    225,
    25,
    237,
    193,
    45,
    77,
    97,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateStateMaxInitializeUserFeeIxArgs {
    pub max_initialize_user_fee: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateStateMaxInitializeUserFeeIxData(
    pub UpdateStateMaxInitializeUserFeeIxArgs,
);
impl From<UpdateStateMaxInitializeUserFeeIxArgs>
for UpdateStateMaxInitializeUserFeeIxData {
    fn from(args: UpdateStateMaxInitializeUserFeeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateStateMaxInitializeUserFeeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateStateMaxInitializeUserFeeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_state_max_initialize_user_fee_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateStateMaxInitializeUserFeeKeys,
    args: UpdateStateMaxInitializeUserFeeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_STATE_MAX_INITIALIZE_USER_FEE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateStateMaxInitializeUserFeeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_state_max_initialize_user_fee_ix(
    keys: UpdateStateMaxInitializeUserFeeKeys,
    args: UpdateStateMaxInitializeUserFeeIxArgs,
) -> std::io::Result<Instruction> {
    update_state_max_initialize_user_fee_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_state_max_initialize_user_fee_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'_, '_>,
    args: UpdateStateMaxInitializeUserFeeIxArgs,
) -> ProgramResult {
    let keys: UpdateStateMaxInitializeUserFeeKeys = accounts.into();
    let ix = update_state_max_initialize_user_fee_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_state_max_initialize_user_fee_invoke(
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'_, '_>,
    args: UpdateStateMaxInitializeUserFeeIxArgs,
) -> ProgramResult {
    update_state_max_initialize_user_fee_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_state_max_initialize_user_fee_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'_, '_>,
    args: UpdateStateMaxInitializeUserFeeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateStateMaxInitializeUserFeeKeys = accounts.into();
    let ix = update_state_max_initialize_user_fee_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_state_max_initialize_user_fee_invoke_signed(
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'_, '_>,
    args: UpdateStateMaxInitializeUserFeeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_state_max_initialize_user_fee_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_state_max_initialize_user_fee_verify_account_keys(
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'_, '_>,
    keys: UpdateStateMaxInitializeUserFeeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_state_max_initialize_user_fee_verify_writable_privileges<'me, 'info>(
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_state_max_initialize_user_fee_verify_signer_privileges<'me, 'info>(
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_state_max_initialize_user_fee_verify_account_privileges<'me, 'info>(
    accounts: UpdateStateMaxInitializeUserFeeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_state_max_initialize_user_fee_verify_writable_privileges(accounts)?;
    update_state_max_initialize_user_fee_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketOracleAccounts<'me, 'info> {
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub oracle: &'me AccountInfo<'info>,
    pub admin: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketOracleKeys {
    pub state: Pubkey,
    pub perp_market: Pubkey,
    pub oracle: Pubkey,
    pub admin: Pubkey,
}
impl From<UpdatePerpMarketOracleAccounts<'_, '_>> for UpdatePerpMarketOracleKeys {
    fn from(accounts: UpdatePerpMarketOracleAccounts) -> Self {
        Self {
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
            oracle: *accounts.oracle.key,
            admin: *accounts.admin.key,
        }
    }
}
impl From<UpdatePerpMarketOracleKeys>
for [AccountMeta; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.oracle,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketOracleKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            state: pubkeys[0],
            perp_market: pubkeys[1],
            oracle: pubkeys[2],
            admin: pubkeys[3],
        }
    }
}
impl<'info> From<UpdatePerpMarketOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketOracleAccounts<'_, 'info>) -> Self {
        [
            accounts.state.clone(),
            accounts.perp_market.clone(),
            accounts.oracle.clone(),
            accounts.admin.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            state: &arr[0],
            perp_market: &arr[1],
            oracle: &arr[2],
            admin: &arr[3],
        }
    }
}
pub const UPDATE_PERP_MARKET_ORACLE_IX_DISCM: [u8; 8] = [
    182,
    113,
    111,
    160,
    67,
    174,
    89,
    191,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketOracleIxArgs {
    pub oracle: Pubkey,
    pub oracle_source: OracleSource,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketOracleIxData(pub UpdatePerpMarketOracleIxArgs);
impl From<UpdatePerpMarketOracleIxArgs> for UpdatePerpMarketOracleIxData {
    fn from(args: UpdatePerpMarketOracleIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketOracleIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_ORACLE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketOracleKeys,
    args: UpdatePerpMarketOracleIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpMarketOracleIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_oracle_ix(
    keys: UpdatePerpMarketOracleKeys,
    args: UpdatePerpMarketOracleIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_oracle_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketOracleAccounts<'_, '_>,
    args: UpdatePerpMarketOracleIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketOracleKeys = accounts.into();
    let ix = update_perp_market_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_oracle_invoke(
    accounts: UpdatePerpMarketOracleAccounts<'_, '_>,
    args: UpdatePerpMarketOracleIxArgs,
) -> ProgramResult {
    update_perp_market_oracle_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketOracleAccounts<'_, '_>,
    args: UpdatePerpMarketOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketOracleKeys = accounts.into();
    let ix = update_perp_market_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_oracle_invoke_signed(
    accounts: UpdatePerpMarketOracleAccounts<'_, '_>,
    args: UpdatePerpMarketOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_oracle_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_oracle_verify_account_keys(
    accounts: UpdatePerpMarketOracleAccounts<'_, '_>,
    keys: UpdatePerpMarketOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.oracle.key, keys.oracle),
        (*accounts.admin.key, keys.admin),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_oracle_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_oracle_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_oracle_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_oracle_verify_writable_privileges(accounts)?;
    update_perp_market_oracle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketBaseSpreadAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketBaseSpreadKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketBaseSpreadAccounts<'_, '_>>
for UpdatePerpMarketBaseSpreadKeys {
    fn from(accounts: UpdatePerpMarketBaseSpreadAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketBaseSpreadKeys>
for [AccountMeta; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketBaseSpreadKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketBaseSpreadKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketBaseSpreadAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketBaseSpreadAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketBaseSpreadAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_BASE_SPREAD_IX_DISCM: [u8; 8] = [
    71,
    95,
    84,
    168,
    9,
    157,
    198,
    65,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketBaseSpreadIxArgs {
    pub base_spread: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketBaseSpreadIxData(pub UpdatePerpMarketBaseSpreadIxArgs);
impl From<UpdatePerpMarketBaseSpreadIxArgs> for UpdatePerpMarketBaseSpreadIxData {
    fn from(args: UpdatePerpMarketBaseSpreadIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketBaseSpreadIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_BASE_SPREAD_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_BASE_SPREAD_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketBaseSpreadIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_BASE_SPREAD_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_base_spread_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketBaseSpreadKeys,
    args: UpdatePerpMarketBaseSpreadIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_BASE_SPREAD_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketBaseSpreadIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_base_spread_ix(
    keys: UpdatePerpMarketBaseSpreadKeys,
    args: UpdatePerpMarketBaseSpreadIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_base_spread_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_base_spread_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketBaseSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketBaseSpreadIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketBaseSpreadKeys = accounts.into();
    let ix = update_perp_market_base_spread_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_base_spread_invoke(
    accounts: UpdatePerpMarketBaseSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketBaseSpreadIxArgs,
) -> ProgramResult {
    update_perp_market_base_spread_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_base_spread_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketBaseSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketBaseSpreadIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketBaseSpreadKeys = accounts.into();
    let ix = update_perp_market_base_spread_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_base_spread_invoke_signed(
    accounts: UpdatePerpMarketBaseSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketBaseSpreadIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_base_spread_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_base_spread_verify_account_keys(
    accounts: UpdatePerpMarketBaseSpreadAccounts<'_, '_>,
    keys: UpdatePerpMarketBaseSpreadKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_base_spread_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketBaseSpreadAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_base_spread_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketBaseSpreadAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_base_spread_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketBaseSpreadAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_base_spread_verify_writable_privileges(accounts)?;
    update_perp_market_base_spread_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateAmmJitIntensityAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateAmmJitIntensityKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdateAmmJitIntensityAccounts<'_, '_>> for UpdateAmmJitIntensityKeys {
    fn from(accounts: UpdateAmmJitIntensityAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdateAmmJitIntensityKeys>
for [AccountMeta; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateAmmJitIntensityKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN]>
for UpdateAmmJitIntensityKeys {
    fn from(pubkeys: [Pubkey; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateAmmJitIntensityAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateAmmJitIntensityAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN]>
for UpdateAmmJitIntensityAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_AMM_JIT_INTENSITY_IX_DISCM: [u8; 8] = [
    181,
    191,
    53,
    109,
    166,
    249,
    55,
    142,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateAmmJitIntensityIxArgs {
    pub amm_jit_intensity: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateAmmJitIntensityIxData(pub UpdateAmmJitIntensityIxArgs);
impl From<UpdateAmmJitIntensityIxArgs> for UpdateAmmJitIntensityIxData {
    fn from(args: UpdateAmmJitIntensityIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateAmmJitIntensityIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_AMM_JIT_INTENSITY_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_AMM_JIT_INTENSITY_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateAmmJitIntensityIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_AMM_JIT_INTENSITY_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_amm_jit_intensity_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateAmmJitIntensityKeys,
    args: UpdateAmmJitIntensityIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_AMM_JIT_INTENSITY_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateAmmJitIntensityIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_amm_jit_intensity_ix(
    keys: UpdateAmmJitIntensityKeys,
    args: UpdateAmmJitIntensityIxArgs,
) -> std::io::Result<Instruction> {
    update_amm_jit_intensity_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_amm_jit_intensity_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateAmmJitIntensityAccounts<'_, '_>,
    args: UpdateAmmJitIntensityIxArgs,
) -> ProgramResult {
    let keys: UpdateAmmJitIntensityKeys = accounts.into();
    let ix = update_amm_jit_intensity_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_amm_jit_intensity_invoke(
    accounts: UpdateAmmJitIntensityAccounts<'_, '_>,
    args: UpdateAmmJitIntensityIxArgs,
) -> ProgramResult {
    update_amm_jit_intensity_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_amm_jit_intensity_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateAmmJitIntensityAccounts<'_, '_>,
    args: UpdateAmmJitIntensityIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateAmmJitIntensityKeys = accounts.into();
    let ix = update_amm_jit_intensity_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_amm_jit_intensity_invoke_signed(
    accounts: UpdateAmmJitIntensityAccounts<'_, '_>,
    args: UpdateAmmJitIntensityIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_amm_jit_intensity_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_amm_jit_intensity_verify_account_keys(
    accounts: UpdateAmmJitIntensityAccounts<'_, '_>,
    keys: UpdateAmmJitIntensityKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_amm_jit_intensity_verify_writable_privileges<'me, 'info>(
    accounts: UpdateAmmJitIntensityAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_amm_jit_intensity_verify_signer_privileges<'me, 'info>(
    accounts: UpdateAmmJitIntensityAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_amm_jit_intensity_verify_account_privileges<'me, 'info>(
    accounts: UpdateAmmJitIntensityAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_amm_jit_intensity_verify_writable_privileges(accounts)?;
    update_amm_jit_intensity_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMaxSpreadAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxSpreadKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMaxSpreadAccounts<'_, '_>> for UpdatePerpMarketMaxSpreadKeys {
    fn from(accounts: UpdatePerpMarketMaxSpreadAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMaxSpreadKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMaxSpreadKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxSpreadKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMaxSpreadAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketMaxSpreadAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxSpreadAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MAX_SPREAD_IX_DISCM: [u8; 8] = [
    80,
    252,
    122,
    62,
    40,
    218,
    91,
    100,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMaxSpreadIxArgs {
    pub max_spread: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxSpreadIxData(pub UpdatePerpMarketMaxSpreadIxArgs);
impl From<UpdatePerpMarketMaxSpreadIxArgs> for UpdatePerpMarketMaxSpreadIxData {
    fn from(args: UpdatePerpMarketMaxSpreadIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMaxSpreadIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MAX_SPREAD_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MAX_SPREAD_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMaxSpreadIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MAX_SPREAD_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_max_spread_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMaxSpreadKeys,
    args: UpdatePerpMarketMaxSpreadIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MAX_SPREAD_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMaxSpreadIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_max_spread_ix(
    keys: UpdatePerpMarketMaxSpreadKeys,
    args: UpdatePerpMarketMaxSpreadIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_max_spread_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_max_spread_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSpreadIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxSpreadKeys = accounts.into();
    let ix = update_perp_market_max_spread_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_max_spread_invoke(
    accounts: UpdatePerpMarketMaxSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSpreadIxArgs,
) -> ProgramResult {
    update_perp_market_max_spread_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_max_spread_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSpreadIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxSpreadKeys = accounts.into();
    let ix = update_perp_market_max_spread_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_max_spread_invoke_signed(
    accounts: UpdatePerpMarketMaxSpreadAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSpreadIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_max_spread_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_max_spread_verify_account_keys(
    accounts: UpdatePerpMarketMaxSpreadAccounts<'_, '_>,
    keys: UpdatePerpMarketMaxSpreadKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_spread_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxSpreadAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_spread_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxSpreadAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_spread_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxSpreadAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_max_spread_verify_writable_privileges(accounts)?;
    update_perp_market_max_spread_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketStepSizeAndTickSizeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketStepSizeAndTickSizeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, '_>>
for UpdatePerpMarketStepSizeAndTickSizeKeys {
    fn from(accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketStepSizeAndTickSizeKeys>
for [AccountMeta; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketStepSizeAndTickSizeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketStepSizeAndTickSizeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN],
> for UpdatePerpMarketStepSizeAndTickSizeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM: [u8; 8] = [
    231,
    255,
    97,
    25,
    146,
    139,
    174,
    4,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketStepSizeAndTickSizeIxArgs {
    pub step_size: u64,
    pub tick_size: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketStepSizeAndTickSizeIxData(
    pub UpdatePerpMarketStepSizeAndTickSizeIxArgs,
);
impl From<UpdatePerpMarketStepSizeAndTickSizeIxArgs>
for UpdatePerpMarketStepSizeAndTickSizeIxData {
    fn from(args: UpdatePerpMarketStepSizeAndTickSizeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketStepSizeAndTickSizeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketStepSizeAndTickSizeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_step_size_and_tick_size_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketStepSizeAndTickSizeKeys,
    args: UpdatePerpMarketStepSizeAndTickSizeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_STEP_SIZE_AND_TICK_SIZE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketStepSizeAndTickSizeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_step_size_and_tick_size_ix(
    keys: UpdatePerpMarketStepSizeAndTickSizeKeys,
    args: UpdatePerpMarketStepSizeAndTickSizeIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_step_size_and_tick_size_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_step_size_and_tick_size_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdatePerpMarketStepSizeAndTickSizeIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketStepSizeAndTickSizeKeys = accounts.into();
    let ix = update_perp_market_step_size_and_tick_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_step_size_and_tick_size_invoke(
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdatePerpMarketStepSizeAndTickSizeIxArgs,
) -> ProgramResult {
    update_perp_market_step_size_and_tick_size_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_step_size_and_tick_size_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdatePerpMarketStepSizeAndTickSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketStepSizeAndTickSizeKeys = accounts.into();
    let ix = update_perp_market_step_size_and_tick_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_step_size_and_tick_size_invoke_signed(
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, '_>,
    args: UpdatePerpMarketStepSizeAndTickSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_step_size_and_tick_size_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_step_size_and_tick_size_verify_account_keys(
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'_, '_>,
    keys: UpdatePerpMarketStepSizeAndTickSizeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_step_size_and_tick_size_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_step_size_and_tick_size_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_step_size_and_tick_size_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketStepSizeAndTickSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_step_size_and_tick_size_verify_writable_privileges(accounts)?;
    update_perp_market_step_size_and_tick_size_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketNameAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketNameKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketNameAccounts<'_, '_>> for UpdatePerpMarketNameKeys {
    fn from(accounts: UpdatePerpMarketNameAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketNameKeys>
for [AccountMeta; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketNameKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketNameKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketNameAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketNameAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketNameAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_NAME_IX_DISCM: [u8; 8] = [
    211,
    31,
    21,
    210,
    64,
    108,
    66,
    201,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketNameIxArgs {
    pub name: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketNameIxData(pub UpdatePerpMarketNameIxArgs);
impl From<UpdatePerpMarketNameIxArgs> for UpdatePerpMarketNameIxData {
    fn from(args: UpdatePerpMarketNameIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketNameIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_NAME_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_NAME_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketNameIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_NAME_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_name_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketNameKeys,
    args: UpdatePerpMarketNameIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_NAME_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpMarketNameIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_name_ix(
    keys: UpdatePerpMarketNameKeys,
    args: UpdatePerpMarketNameIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_name_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_name_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketNameAccounts<'_, '_>,
    args: UpdatePerpMarketNameIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketNameKeys = accounts.into();
    let ix = update_perp_market_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_name_invoke(
    accounts: UpdatePerpMarketNameAccounts<'_, '_>,
    args: UpdatePerpMarketNameIxArgs,
) -> ProgramResult {
    update_perp_market_name_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_name_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketNameAccounts<'_, '_>,
    args: UpdatePerpMarketNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketNameKeys = accounts.into();
    let ix = update_perp_market_name_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_name_invoke_signed(
    accounts: UpdatePerpMarketNameAccounts<'_, '_>,
    args: UpdatePerpMarketNameIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_name_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_name_verify_account_keys(
    accounts: UpdatePerpMarketNameAccounts<'_, '_>,
    keys: UpdatePerpMarketNameKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_name_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_name_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_name_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketNameAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_name_verify_writable_privileges(accounts)?;
    update_perp_market_name_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMinOrderSizeAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMinOrderSizeKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMinOrderSizeAccounts<'_, '_>>
for UpdatePerpMarketMinOrderSizeKeys {
    fn from(accounts: UpdatePerpMarketMinOrderSizeAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMinOrderSizeKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMinOrderSizeKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMinOrderSizeKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMinOrderSizeAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketMinOrderSizeAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMinOrderSizeAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_DISCM: [u8; 8] = [
    226,
    74,
    5,
    89,
    108,
    223,
    46,
    141,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMinOrderSizeIxArgs {
    pub order_size: u64,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMinOrderSizeIxData(pub UpdatePerpMarketMinOrderSizeIxArgs);
impl From<UpdatePerpMarketMinOrderSizeIxArgs> for UpdatePerpMarketMinOrderSizeIxData {
    fn from(args: UpdatePerpMarketMinOrderSizeIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMinOrderSizeIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMinOrderSizeIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_min_order_size_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMinOrderSizeKeys,
    args: UpdatePerpMarketMinOrderSizeIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MIN_ORDER_SIZE_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMinOrderSizeIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_min_order_size_ix(
    keys: UpdatePerpMarketMinOrderSizeKeys,
    args: UpdatePerpMarketMinOrderSizeIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_min_order_size_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_min_order_size_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdatePerpMarketMinOrderSizeIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMinOrderSizeKeys = accounts.into();
    let ix = update_perp_market_min_order_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_min_order_size_invoke(
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdatePerpMarketMinOrderSizeIxArgs,
) -> ProgramResult {
    update_perp_market_min_order_size_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_min_order_size_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdatePerpMarketMinOrderSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMinOrderSizeKeys = accounts.into();
    let ix = update_perp_market_min_order_size_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_min_order_size_invoke_signed(
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'_, '_>,
    args: UpdatePerpMarketMinOrderSizeIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_min_order_size_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_min_order_size_verify_account_keys(
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'_, '_>,
    keys: UpdatePerpMarketMinOrderSizeKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_min_order_size_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_min_order_size_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_min_order_size_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMinOrderSizeAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_min_order_size_verify_writable_privileges(accounts)?;
    update_perp_market_min_order_size_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMaxSlippageRatioAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxSlippageRatioKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMaxSlippageRatioAccounts<'_, '_>>
for UpdatePerpMarketMaxSlippageRatioKeys {
    fn from(accounts: UpdatePerpMarketMaxSlippageRatioAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMaxSlippageRatioKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMaxSlippageRatioKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxSlippageRatioKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMaxSlippageRatioAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxSlippageRatioAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_DISCM: [u8; 8] = [
    235,
    37,
    40,
    196,
    70,
    146,
    54,
    201,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMaxSlippageRatioIxArgs {
    pub max_slippage_ratio: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxSlippageRatioIxData(
    pub UpdatePerpMarketMaxSlippageRatioIxArgs,
);
impl From<UpdatePerpMarketMaxSlippageRatioIxArgs>
for UpdatePerpMarketMaxSlippageRatioIxData {
    fn from(args: UpdatePerpMarketMaxSlippageRatioIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMaxSlippageRatioIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMaxSlippageRatioIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_max_slippage_ratio_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMaxSlippageRatioKeys,
    args: UpdatePerpMarketMaxSlippageRatioIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MAX_SLIPPAGE_RATIO_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMaxSlippageRatioIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_max_slippage_ratio_ix(
    keys: UpdatePerpMarketMaxSlippageRatioKeys,
    args: UpdatePerpMarketMaxSlippageRatioIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_max_slippage_ratio_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_max_slippage_ratio_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSlippageRatioIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxSlippageRatioKeys = accounts.into();
    let ix = update_perp_market_max_slippage_ratio_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_max_slippage_ratio_invoke(
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSlippageRatioIxArgs,
) -> ProgramResult {
    update_perp_market_max_slippage_ratio_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_max_slippage_ratio_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSlippageRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxSlippageRatioKeys = accounts.into();
    let ix = update_perp_market_max_slippage_ratio_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_max_slippage_ratio_invoke_signed(
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'_, '_>,
    args: UpdatePerpMarketMaxSlippageRatioIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_max_slippage_ratio_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_max_slippage_ratio_verify_account_keys(
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'_, '_>,
    keys: UpdatePerpMarketMaxSlippageRatioKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_slippage_ratio_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_slippage_ratio_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_slippage_ratio_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxSlippageRatioAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_max_slippage_ratio_verify_writable_privileges(accounts)?;
    update_perp_market_max_slippage_ratio_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMaxFillReserveFractionAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxFillReserveFractionKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMaxFillReserveFractionAccounts<'_, '_>>
for UpdatePerpMarketMaxFillReserveFractionKeys {
    fn from(accounts: UpdatePerpMarketMaxFillReserveFractionAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMaxFillReserveFractionKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMaxFillReserveFractionKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxFillReserveFractionKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMaxFillReserveFractionAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN] {
    fn from(
        accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'_, 'info>,
    ) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<
        'info,
    >; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN],
> for UpdatePerpMarketMaxFillReserveFractionAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_DISCM: [u8; 8] = [
    19,
    172,
    114,
    154,
    42,
    135,
    161,
    133,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMaxFillReserveFractionIxArgs {
    pub max_fill_reserve_fraction: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxFillReserveFractionIxData(
    pub UpdatePerpMarketMaxFillReserveFractionIxArgs,
);
impl From<UpdatePerpMarketMaxFillReserveFractionIxArgs>
for UpdatePerpMarketMaxFillReserveFractionIxData {
    fn from(args: UpdatePerpMarketMaxFillReserveFractionIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMaxFillReserveFractionIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_DISCM,
                        maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMaxFillReserveFractionIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_max_fill_reserve_fraction_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMaxFillReserveFractionKeys,
    args: UpdatePerpMarketMaxFillReserveFractionIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MAX_FILL_RESERVE_FRACTION_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMaxFillReserveFractionIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_max_fill_reserve_fraction_ix(
    keys: UpdatePerpMarketMaxFillReserveFractionKeys,
    args: UpdatePerpMarketMaxFillReserveFractionIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_max_fill_reserve_fraction_ix_with_program_id(
        crate::ID,
        keys,
        args,
    )
}
pub fn update_perp_market_max_fill_reserve_fraction_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'_, '_>,
    args: UpdatePerpMarketMaxFillReserveFractionIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxFillReserveFractionKeys = accounts.into();
    let ix = update_perp_market_max_fill_reserve_fraction_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_max_fill_reserve_fraction_invoke(
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'_, '_>,
    args: UpdatePerpMarketMaxFillReserveFractionIxArgs,
) -> ProgramResult {
    update_perp_market_max_fill_reserve_fraction_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_max_fill_reserve_fraction_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'_, '_>,
    args: UpdatePerpMarketMaxFillReserveFractionIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxFillReserveFractionKeys = accounts.into();
    let ix = update_perp_market_max_fill_reserve_fraction_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_max_fill_reserve_fraction_invoke_signed(
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'_, '_>,
    args: UpdatePerpMarketMaxFillReserveFractionIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_max_fill_reserve_fraction_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_max_fill_reserve_fraction_verify_account_keys(
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'_, '_>,
    keys: UpdatePerpMarketMaxFillReserveFractionKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_fill_reserve_fraction_verify_writable_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_fill_reserve_fraction_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_fill_reserve_fraction_verify_account_privileges<
    'me,
    'info,
>(
    accounts: UpdatePerpMarketMaxFillReserveFractionAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_max_fill_reserve_fraction_verify_writable_privileges(accounts)?;
    update_perp_market_max_fill_reserve_fraction_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketMaxOpenInterestAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxOpenInterestKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketMaxOpenInterestAccounts<'_, '_>>
for UpdatePerpMarketMaxOpenInterestKeys {
    fn from(accounts: UpdatePerpMarketMaxOpenInterestAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketMaxOpenInterestKeys>
for [AccountMeta; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketMaxOpenInterestKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxOpenInterestKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketMaxOpenInterestAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketMaxOpenInterestAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketMaxOpenInterestAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_DISCM: [u8; 8] = [
    194,
    79,
    149,
    224,
    246,
    102,
    186,
    140,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketMaxOpenInterestIxArgs {
    pub max_open_interest: u128,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketMaxOpenInterestIxData(
    pub UpdatePerpMarketMaxOpenInterestIxArgs,
);
impl From<UpdatePerpMarketMaxOpenInterestIxArgs>
for UpdatePerpMarketMaxOpenInterestIxData {
    fn from(args: UpdatePerpMarketMaxOpenInterestIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketMaxOpenInterestIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketMaxOpenInterestIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_max_open_interest_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketMaxOpenInterestKeys,
    args: UpdatePerpMarketMaxOpenInterestIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_MAX_OPEN_INTEREST_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketMaxOpenInterestIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_max_open_interest_ix(
    keys: UpdatePerpMarketMaxOpenInterestKeys,
    args: UpdatePerpMarketMaxOpenInterestIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_max_open_interest_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_max_open_interest_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'_, '_>,
    args: UpdatePerpMarketMaxOpenInterestIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxOpenInterestKeys = accounts.into();
    let ix = update_perp_market_max_open_interest_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_max_open_interest_invoke(
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'_, '_>,
    args: UpdatePerpMarketMaxOpenInterestIxArgs,
) -> ProgramResult {
    update_perp_market_max_open_interest_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_perp_market_max_open_interest_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'_, '_>,
    args: UpdatePerpMarketMaxOpenInterestIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketMaxOpenInterestKeys = accounts.into();
    let ix = update_perp_market_max_open_interest_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_max_open_interest_invoke_signed(
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'_, '_>,
    args: UpdatePerpMarketMaxOpenInterestIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_max_open_interest_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_max_open_interest_verify_account_keys(
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'_, '_>,
    keys: UpdatePerpMarketMaxOpenInterestKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_open_interest_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_open_interest_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_max_open_interest_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketMaxOpenInterestAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_max_open_interest_verify_writable_privileges(accounts)?;
    update_perp_market_max_open_interest_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketNumberOfUsersAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketNumberOfUsersKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketNumberOfUsersAccounts<'_, '_>>
for UpdatePerpMarketNumberOfUsersKeys {
    fn from(accounts: UpdatePerpMarketNumberOfUsersAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketNumberOfUsersKeys>
for [AccountMeta; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketNumberOfUsersKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketNumberOfUsersKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketNumberOfUsersAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketNumberOfUsersAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketNumberOfUsersAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_DISCM: [u8; 8] = [
    35,
    62,
    144,
    177,
    180,
    62,
    215,
    196,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketNumberOfUsersIxArgs {
    pub number_of_users: Option<u32>,
    pub number_of_users_with_base: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketNumberOfUsersIxData(pub UpdatePerpMarketNumberOfUsersIxArgs);
impl From<UpdatePerpMarketNumberOfUsersIxArgs> for UpdatePerpMarketNumberOfUsersIxData {
    fn from(args: UpdatePerpMarketNumberOfUsersIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketNumberOfUsersIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketNumberOfUsersIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_number_of_users_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketNumberOfUsersKeys,
    args: UpdatePerpMarketNumberOfUsersIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_NUMBER_OF_USERS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketNumberOfUsersIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_number_of_users_ix(
    keys: UpdatePerpMarketNumberOfUsersKeys,
    args: UpdatePerpMarketNumberOfUsersIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_number_of_users_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_number_of_users_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'_, '_>,
    args: UpdatePerpMarketNumberOfUsersIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketNumberOfUsersKeys = accounts.into();
    let ix = update_perp_market_number_of_users_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_number_of_users_invoke(
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'_, '_>,
    args: UpdatePerpMarketNumberOfUsersIxArgs,
) -> ProgramResult {
    update_perp_market_number_of_users_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_number_of_users_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'_, '_>,
    args: UpdatePerpMarketNumberOfUsersIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketNumberOfUsersKeys = accounts.into();
    let ix = update_perp_market_number_of_users_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_number_of_users_invoke_signed(
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'_, '_>,
    args: UpdatePerpMarketNumberOfUsersIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_number_of_users_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_number_of_users_verify_account_keys(
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'_, '_>,
    keys: UpdatePerpMarketNumberOfUsersKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_number_of_users_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_number_of_users_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_number_of_users_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketNumberOfUsersAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_number_of_users_verify_writable_privileges(accounts)?;
    update_perp_market_number_of_users_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketFeeAdjustmentAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketFeeAdjustmentKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketFeeAdjustmentAccounts<'_, '_>>
for UpdatePerpMarketFeeAdjustmentKeys {
    fn from(accounts: UpdatePerpMarketFeeAdjustmentAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketFeeAdjustmentKeys>
for [AccountMeta; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketFeeAdjustmentKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketFeeAdjustmentKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketFeeAdjustmentAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketFeeAdjustmentAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketFeeAdjustmentAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_DISCM: [u8; 8] = [
    194,
    174,
    87,
    102,
    43,
    148,
    32,
    112,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketFeeAdjustmentIxArgs {
    pub fee_adjustment: i16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketFeeAdjustmentIxData(pub UpdatePerpMarketFeeAdjustmentIxArgs);
impl From<UpdatePerpMarketFeeAdjustmentIxArgs> for UpdatePerpMarketFeeAdjustmentIxData {
    fn from(args: UpdatePerpMarketFeeAdjustmentIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketFeeAdjustmentIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketFeeAdjustmentIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_fee_adjustment_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketFeeAdjustmentKeys,
    args: UpdatePerpMarketFeeAdjustmentIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePerpMarketFeeAdjustmentIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_fee_adjustment_ix(
    keys: UpdatePerpMarketFeeAdjustmentKeys,
    args: UpdatePerpMarketFeeAdjustmentIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_fee_adjustment_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_fee_adjustment_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdatePerpMarketFeeAdjustmentIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketFeeAdjustmentKeys = accounts.into();
    let ix = update_perp_market_fee_adjustment_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_fee_adjustment_invoke(
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdatePerpMarketFeeAdjustmentIxArgs,
) -> ProgramResult {
    update_perp_market_fee_adjustment_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_fee_adjustment_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdatePerpMarketFeeAdjustmentIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketFeeAdjustmentKeys = accounts.into();
    let ix = update_perp_market_fee_adjustment_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_fee_adjustment_invoke_signed(
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdatePerpMarketFeeAdjustmentIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_fee_adjustment_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_fee_adjustment_verify_account_keys(
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'_, '_>,
    keys: UpdatePerpMarketFeeAdjustmentKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_fee_adjustment_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_fee_adjustment_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_fee_adjustment_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFeeAdjustmentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_fee_adjustment_verify_writable_privileges(accounts)?;
    update_perp_market_fee_adjustment_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketFeeAdjustmentAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketFeeAdjustmentKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketFeeAdjustmentAccounts<'_, '_>>
for UpdateSpotMarketFeeAdjustmentKeys {
    fn from(accounts: UpdateSpotMarketFeeAdjustmentAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketFeeAdjustmentKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketFeeAdjustmentKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketFeeAdjustmentKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketFeeAdjustmentAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketFeeAdjustmentAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketFeeAdjustmentAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_DISCM: [u8; 8] = [
    148,
    182,
    3,
    126,
    157,
    114,
    220,
    99,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketFeeAdjustmentIxArgs {
    pub fee_adjustment: i16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketFeeAdjustmentIxData(pub UpdateSpotMarketFeeAdjustmentIxArgs);
impl From<UpdateSpotMarketFeeAdjustmentIxArgs> for UpdateSpotMarketFeeAdjustmentIxData {
    fn from(args: UpdateSpotMarketFeeAdjustmentIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketFeeAdjustmentIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketFeeAdjustmentIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_fee_adjustment_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketFeeAdjustmentKeys,
    args: UpdateSpotMarketFeeAdjustmentIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_FEE_ADJUSTMENT_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateSpotMarketFeeAdjustmentIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_fee_adjustment_ix(
    keys: UpdateSpotMarketFeeAdjustmentKeys,
    args: UpdateSpotMarketFeeAdjustmentIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_fee_adjustment_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_fee_adjustment_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdateSpotMarketFeeAdjustmentIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketFeeAdjustmentKeys = accounts.into();
    let ix = update_spot_market_fee_adjustment_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_fee_adjustment_invoke(
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdateSpotMarketFeeAdjustmentIxArgs,
) -> ProgramResult {
    update_spot_market_fee_adjustment_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_fee_adjustment_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdateSpotMarketFeeAdjustmentIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketFeeAdjustmentKeys = accounts.into();
    let ix = update_spot_market_fee_adjustment_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_fee_adjustment_invoke_signed(
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'_, '_>,
    args: UpdateSpotMarketFeeAdjustmentIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_fee_adjustment_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_fee_adjustment_verify_account_keys(
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'_, '_>,
    keys: UpdateSpotMarketFeeAdjustmentKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_fee_adjustment_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_fee_adjustment_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_fee_adjustment_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketFeeAdjustmentAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_fee_adjustment_verify_writable_privileges(accounts)?;
    update_spot_market_fee_adjustment_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpMarketFuelAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketFuelKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub perp_market: Pubkey,
}
impl From<UpdatePerpMarketFuelAccounts<'_, '_>> for UpdatePerpMarketFuelKeys {
    fn from(accounts: UpdatePerpMarketFuelAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            perp_market: *accounts.perp_market.key,
        }
    }
}
impl From<UpdatePerpMarketFuelKeys>
for [AccountMeta; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpMarketFuelKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketFuelKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            perp_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdatePerpMarketFuelAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpMarketFuelAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.perp_market.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN]>
for UpdatePerpMarketFuelAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            perp_market: &arr[2],
        }
    }
}
pub const UPDATE_PERP_MARKET_FUEL_IX_DISCM: [u8; 8] = [
    252,
    141,
    110,
    101,
    27,
    99,
    182,
    21,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpMarketFuelIxArgs {
    pub fuel_boost_taker: Option<u8>,
    pub fuel_boost_maker: Option<u8>,
    pub fuel_boost_position: Option<u8>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpMarketFuelIxData(pub UpdatePerpMarketFuelIxArgs);
impl From<UpdatePerpMarketFuelIxArgs> for UpdatePerpMarketFuelIxData {
    fn from(args: UpdatePerpMarketFuelIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpMarketFuelIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_MARKET_FUEL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_MARKET_FUEL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpMarketFuelIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_MARKET_FUEL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_market_fuel_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpMarketFuelKeys,
    args: UpdatePerpMarketFuelIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_MARKET_FUEL_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpMarketFuelIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_market_fuel_ix(
    keys: UpdatePerpMarketFuelKeys,
    args: UpdatePerpMarketFuelIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_market_fuel_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_market_fuel_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketFuelAccounts<'_, '_>,
    args: UpdatePerpMarketFuelIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpMarketFuelKeys = accounts.into();
    let ix = update_perp_market_fuel_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_market_fuel_invoke(
    accounts: UpdatePerpMarketFuelAccounts<'_, '_>,
    args: UpdatePerpMarketFuelIxArgs,
) -> ProgramResult {
    update_perp_market_fuel_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_market_fuel_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpMarketFuelAccounts<'_, '_>,
    args: UpdatePerpMarketFuelIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpMarketFuelKeys = accounts.into();
    let ix = update_perp_market_fuel_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_market_fuel_invoke_signed(
    accounts: UpdatePerpMarketFuelAccounts<'_, '_>,
    args: UpdatePerpMarketFuelIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_market_fuel_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_market_fuel_verify_account_keys(
    accounts: UpdatePerpMarketFuelAccounts<'_, '_>,
    keys: UpdatePerpMarketFuelKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.perp_market.key, keys.perp_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_market_fuel_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.perp_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_market_fuel_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_market_fuel_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpMarketFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_market_fuel_verify_writable_privileges(accounts)?;
    update_perp_market_fuel_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotMarketFuelAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub spot_market: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketFuelKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub spot_market: Pubkey,
}
impl From<UpdateSpotMarketFuelAccounts<'_, '_>> for UpdateSpotMarketFuelKeys {
    fn from(accounts: UpdateSpotMarketFuelAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            spot_market: *accounts.spot_market.key,
        }
    }
}
impl From<UpdateSpotMarketFuelKeys>
for [AccountMeta; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotMarketFuelKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.spot_market,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketFuelKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            spot_market: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateSpotMarketFuelAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotMarketFuelAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone(), accounts.spot_market.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN]>
for UpdateSpotMarketFuelAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            spot_market: &arr[2],
        }
    }
}
pub const UPDATE_SPOT_MARKET_FUEL_IX_DISCM: [u8; 8] = [
    226,
    253,
    76,
    71,
    17,
    2,
    171,
    169,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotMarketFuelIxArgs {
    pub fuel_boost_deposits: Option<u8>,
    pub fuel_boost_borrows: Option<u8>,
    pub fuel_boost_taker: Option<u8>,
    pub fuel_boost_maker: Option<u8>,
    pub fuel_boost_insurance: Option<u8>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotMarketFuelIxData(pub UpdateSpotMarketFuelIxArgs);
impl From<UpdateSpotMarketFuelIxArgs> for UpdateSpotMarketFuelIxData {
    fn from(args: UpdateSpotMarketFuelIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotMarketFuelIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_MARKET_FUEL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_MARKET_FUEL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotMarketFuelIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_MARKET_FUEL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_market_fuel_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotMarketFuelKeys,
    args: UpdateSpotMarketFuelIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_MARKET_FUEL_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotMarketFuelIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_market_fuel_ix(
    keys: UpdateSpotMarketFuelKeys,
    args: UpdateSpotMarketFuelIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_market_fuel_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_market_fuel_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketFuelAccounts<'_, '_>,
    args: UpdateSpotMarketFuelIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotMarketFuelKeys = accounts.into();
    let ix = update_spot_market_fuel_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_market_fuel_invoke(
    accounts: UpdateSpotMarketFuelAccounts<'_, '_>,
    args: UpdateSpotMarketFuelIxArgs,
) -> ProgramResult {
    update_spot_market_fuel_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_market_fuel_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotMarketFuelAccounts<'_, '_>,
    args: UpdateSpotMarketFuelIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotMarketFuelKeys = accounts.into();
    let ix = update_spot_market_fuel_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_market_fuel_invoke_signed(
    accounts: UpdateSpotMarketFuelAccounts<'_, '_>,
    args: UpdateSpotMarketFuelIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_market_fuel_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_market_fuel_verify_account_keys(
    accounts: UpdateSpotMarketFuelAccounts<'_, '_>,
    keys: UpdateSpotMarketFuelKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.spot_market.key, keys.spot_market),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_market_fuel_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotMarketFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.spot_market] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_market_fuel_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotMarketFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_market_fuel_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotMarketFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_market_fuel_verify_writable_privileges(accounts)?;
    update_spot_market_fuel_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INIT_USER_FUEL_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct InitUserFuelAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub user: &'me AccountInfo<'info>,
    pub user_stats: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitUserFuelKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
    pub user: Pubkey,
    pub user_stats: Pubkey,
}
impl From<InitUserFuelAccounts<'_, '_>> for InitUserFuelKeys {
    fn from(accounts: InitUserFuelAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
            user: *accounts.user.key,
            user_stats: *accounts.user_stats.key,
        }
    }
}
impl From<InitUserFuelKeys> for [AccountMeta; INIT_USER_FUEL_IX_ACCOUNTS_LEN] {
    fn from(keys: InitUserFuelKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.user,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.user_stats,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; INIT_USER_FUEL_IX_ACCOUNTS_LEN]> for InitUserFuelKeys {
    fn from(pubkeys: [Pubkey; INIT_USER_FUEL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
            user: pubkeys[2],
            user_stats: pubkeys[3],
        }
    }
}
impl<'info> From<InitUserFuelAccounts<'_, 'info>>
for [AccountInfo<'info>; INIT_USER_FUEL_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitUserFuelAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.state.clone(),
            accounts.user.clone(),
            accounts.user_stats.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; INIT_USER_FUEL_IX_ACCOUNTS_LEN]>
for InitUserFuelAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; INIT_USER_FUEL_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
            user: &arr[2],
            user_stats: &arr[3],
        }
    }
}
pub const INIT_USER_FUEL_IX_DISCM: [u8; 8] = [132, 191, 228, 141, 201, 138, 60, 48];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitUserFuelIxArgs {
    pub fuel_boost_deposits: Option<u32>,
    pub fuel_boost_borrows: Option<u32>,
    pub fuel_boost_taker: Option<u32>,
    pub fuel_boost_maker: Option<u32>,
    pub fuel_boost_insurance: Option<u32>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitUserFuelIxData(pub InitUserFuelIxArgs);
impl From<InitUserFuelIxArgs> for InitUserFuelIxData {
    fn from(args: InitUserFuelIxArgs) -> Self {
        Self(args)
    }
}
impl InitUserFuelIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INIT_USER_FUEL_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INIT_USER_FUEL_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitUserFuelIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INIT_USER_FUEL_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn init_user_fuel_ix_with_program_id(
    program_id: Pubkey,
    keys: InitUserFuelKeys,
    args: InitUserFuelIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INIT_USER_FUEL_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitUserFuelIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn init_user_fuel_ix(
    keys: InitUserFuelKeys,
    args: InitUserFuelIxArgs,
) -> std::io::Result<Instruction> {
    init_user_fuel_ix_with_program_id(crate::ID, keys, args)
}
pub fn init_user_fuel_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitUserFuelAccounts<'_, '_>,
    args: InitUserFuelIxArgs,
) -> ProgramResult {
    let keys: InitUserFuelKeys = accounts.into();
    let ix = init_user_fuel_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn init_user_fuel_invoke(
    accounts: InitUserFuelAccounts<'_, '_>,
    args: InitUserFuelIxArgs,
) -> ProgramResult {
    init_user_fuel_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn init_user_fuel_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitUserFuelAccounts<'_, '_>,
    args: InitUserFuelIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitUserFuelKeys = accounts.into();
    let ix = init_user_fuel_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn init_user_fuel_invoke_signed(
    accounts: InitUserFuelAccounts<'_, '_>,
    args: InitUserFuelIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    init_user_fuel_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn init_user_fuel_verify_account_keys(
    accounts: InitUserFuelAccounts<'_, '_>,
    keys: InitUserFuelKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
        (*accounts.user.key, keys.user),
        (*accounts.user_stats.key, keys.user_stats),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn init_user_fuel_verify_writable_privileges<'me, 'info>(
    accounts: InitUserFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.user, accounts.user_stats] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn init_user_fuel_verify_signer_privileges<'me, 'info>(
    accounts: InitUserFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn init_user_fuel_verify_account_privileges<'me, 'info>(
    accounts: InitUserFuelAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    init_user_fuel_verify_writable_privileges(accounts)?;
    init_user_fuel_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_ADMIN_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateAdminAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateAdminKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateAdminAccounts<'_, '_>> for UpdateAdminKeys {
    fn from(accounts: UpdateAdminAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateAdminKeys> for [AccountMeta; UPDATE_ADMIN_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateAdminKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_ADMIN_IX_ACCOUNTS_LEN]> for UpdateAdminKeys {
    fn from(pubkeys: [Pubkey; UPDATE_ADMIN_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateAdminAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_ADMIN_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateAdminAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_ADMIN_IX_ACCOUNTS_LEN]>
for UpdateAdminAccounts<'me, 'info> {
    fn from(arr: &'me [AccountInfo<'info>; UPDATE_ADMIN_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_ADMIN_IX_DISCM: [u8; 8] = [161, 176, 40, 213, 60, 184, 179, 228];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateAdminIxArgs {
    pub admin: Pubkey,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateAdminIxData(pub UpdateAdminIxArgs);
impl From<UpdateAdminIxArgs> for UpdateAdminIxData {
    fn from(args: UpdateAdminIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateAdminIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_ADMIN_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_ADMIN_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateAdminIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_ADMIN_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_admin_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateAdminKeys,
    args: UpdateAdminIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_ADMIN_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateAdminIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_admin_ix(
    keys: UpdateAdminKeys,
    args: UpdateAdminIxArgs,
) -> std::io::Result<Instruction> {
    update_admin_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_admin_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateAdminAccounts<'_, '_>,
    args: UpdateAdminIxArgs,
) -> ProgramResult {
    let keys: UpdateAdminKeys = accounts.into();
    let ix = update_admin_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_admin_invoke(
    accounts: UpdateAdminAccounts<'_, '_>,
    args: UpdateAdminIxArgs,
) -> ProgramResult {
    update_admin_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_admin_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateAdminAccounts<'_, '_>,
    args: UpdateAdminIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateAdminKeys = accounts.into();
    let ix = update_admin_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_admin_invoke_signed(
    accounts: UpdateAdminAccounts<'_, '_>,
    args: UpdateAdminIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_admin_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_admin_verify_account_keys(
    accounts: UpdateAdminAccounts<'_, '_>,
    keys: UpdateAdminKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_admin_verify_writable_privileges<'me, 'info>(
    accounts: UpdateAdminAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_admin_verify_signer_privileges<'me, 'info>(
    accounts: UpdateAdminAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_admin_verify_account_privileges<'me, 'info>(
    accounts: UpdateAdminAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_admin_verify_writable_privileges(accounts)?;
    update_admin_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateWhitelistMintAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateWhitelistMintKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateWhitelistMintAccounts<'_, '_>> for UpdateWhitelistMintKeys {
    fn from(accounts: UpdateWhitelistMintAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateWhitelistMintKeys>
for [AccountMeta; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateWhitelistMintKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN]> for UpdateWhitelistMintKeys {
    fn from(pubkeys: [Pubkey; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateWhitelistMintAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateWhitelistMintAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN]>
for UpdateWhitelistMintAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_WHITELIST_MINT_IX_DISCM: [u8; 8] = [
    161,
    15,
    162,
    19,
    148,
    120,
    144,
    151,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateWhitelistMintIxArgs {
    pub whitelist_mint: Pubkey,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateWhitelistMintIxData(pub UpdateWhitelistMintIxArgs);
impl From<UpdateWhitelistMintIxArgs> for UpdateWhitelistMintIxData {
    fn from(args: UpdateWhitelistMintIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateWhitelistMintIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_WHITELIST_MINT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_WHITELIST_MINT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateWhitelistMintIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_WHITELIST_MINT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_whitelist_mint_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateWhitelistMintKeys,
    args: UpdateWhitelistMintIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_WHITELIST_MINT_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateWhitelistMintIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_whitelist_mint_ix(
    keys: UpdateWhitelistMintKeys,
    args: UpdateWhitelistMintIxArgs,
) -> std::io::Result<Instruction> {
    update_whitelist_mint_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_whitelist_mint_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateWhitelistMintAccounts<'_, '_>,
    args: UpdateWhitelistMintIxArgs,
) -> ProgramResult {
    let keys: UpdateWhitelistMintKeys = accounts.into();
    let ix = update_whitelist_mint_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_whitelist_mint_invoke(
    accounts: UpdateWhitelistMintAccounts<'_, '_>,
    args: UpdateWhitelistMintIxArgs,
) -> ProgramResult {
    update_whitelist_mint_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_whitelist_mint_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateWhitelistMintAccounts<'_, '_>,
    args: UpdateWhitelistMintIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateWhitelistMintKeys = accounts.into();
    let ix = update_whitelist_mint_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_whitelist_mint_invoke_signed(
    accounts: UpdateWhitelistMintAccounts<'_, '_>,
    args: UpdateWhitelistMintIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_whitelist_mint_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_whitelist_mint_verify_account_keys(
    accounts: UpdateWhitelistMintAccounts<'_, '_>,
    keys: UpdateWhitelistMintKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_whitelist_mint_verify_writable_privileges<'me, 'info>(
    accounts: UpdateWhitelistMintAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_whitelist_mint_verify_signer_privileges<'me, 'info>(
    accounts: UpdateWhitelistMintAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_whitelist_mint_verify_account_privileges<'me, 'info>(
    accounts: UpdateWhitelistMintAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_whitelist_mint_verify_writable_privileges(accounts)?;
    update_whitelist_mint_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateDiscountMintAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateDiscountMintKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateDiscountMintAccounts<'_, '_>> for UpdateDiscountMintKeys {
    fn from(accounts: UpdateDiscountMintAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateDiscountMintKeys>
for [AccountMeta; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateDiscountMintKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN]> for UpdateDiscountMintKeys {
    fn from(pubkeys: [Pubkey; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateDiscountMintAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateDiscountMintAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN]>
for UpdateDiscountMintAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_DISCOUNT_MINT_IX_DISCM: [u8; 8] = [32, 252, 122, 211, 66, 31, 47, 241];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateDiscountMintIxArgs {
    pub discount_mint: Pubkey,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateDiscountMintIxData(pub UpdateDiscountMintIxArgs);
impl From<UpdateDiscountMintIxArgs> for UpdateDiscountMintIxData {
    fn from(args: UpdateDiscountMintIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateDiscountMintIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_DISCOUNT_MINT_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_DISCOUNT_MINT_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateDiscountMintIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_DISCOUNT_MINT_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_discount_mint_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateDiscountMintKeys,
    args: UpdateDiscountMintIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_DISCOUNT_MINT_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateDiscountMintIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_discount_mint_ix(
    keys: UpdateDiscountMintKeys,
    args: UpdateDiscountMintIxArgs,
) -> std::io::Result<Instruction> {
    update_discount_mint_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_discount_mint_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateDiscountMintAccounts<'_, '_>,
    args: UpdateDiscountMintIxArgs,
) -> ProgramResult {
    let keys: UpdateDiscountMintKeys = accounts.into();
    let ix = update_discount_mint_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_discount_mint_invoke(
    accounts: UpdateDiscountMintAccounts<'_, '_>,
    args: UpdateDiscountMintIxArgs,
) -> ProgramResult {
    update_discount_mint_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_discount_mint_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateDiscountMintAccounts<'_, '_>,
    args: UpdateDiscountMintIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateDiscountMintKeys = accounts.into();
    let ix = update_discount_mint_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_discount_mint_invoke_signed(
    accounts: UpdateDiscountMintAccounts<'_, '_>,
    args: UpdateDiscountMintIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_discount_mint_invoke_signed_with_program_id(crate::ID, accounts, args, seeds)
}
pub fn update_discount_mint_verify_account_keys(
    accounts: UpdateDiscountMintAccounts<'_, '_>,
    keys: UpdateDiscountMintKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_discount_mint_verify_writable_privileges<'me, 'info>(
    accounts: UpdateDiscountMintAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_discount_mint_verify_signer_privileges<'me, 'info>(
    accounts: UpdateDiscountMintAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_discount_mint_verify_account_privileges<'me, 'info>(
    accounts: UpdateDiscountMintAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_discount_mint_verify_writable_privileges(accounts)?;
    update_discount_mint_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateExchangeStatusAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateExchangeStatusKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateExchangeStatusAccounts<'_, '_>> for UpdateExchangeStatusKeys {
    fn from(accounts: UpdateExchangeStatusAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateExchangeStatusKeys>
for [AccountMeta; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateExchangeStatusKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN]>
for UpdateExchangeStatusKeys {
    fn from(pubkeys: [Pubkey; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateExchangeStatusAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateExchangeStatusAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN]>
for UpdateExchangeStatusAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_EXCHANGE_STATUS_IX_DISCM: [u8; 8] = [
    83,
    160,
    252,
    250,
    129,
    116,
    49,
    223,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateExchangeStatusIxArgs {
    pub exchange_status: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateExchangeStatusIxData(pub UpdateExchangeStatusIxArgs);
impl From<UpdateExchangeStatusIxArgs> for UpdateExchangeStatusIxData {
    fn from(args: UpdateExchangeStatusIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateExchangeStatusIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_EXCHANGE_STATUS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_EXCHANGE_STATUS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateExchangeStatusIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_EXCHANGE_STATUS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_exchange_status_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateExchangeStatusKeys,
    args: UpdateExchangeStatusIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_EXCHANGE_STATUS_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateExchangeStatusIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_exchange_status_ix(
    keys: UpdateExchangeStatusKeys,
    args: UpdateExchangeStatusIxArgs,
) -> std::io::Result<Instruction> {
    update_exchange_status_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_exchange_status_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateExchangeStatusAccounts<'_, '_>,
    args: UpdateExchangeStatusIxArgs,
) -> ProgramResult {
    let keys: UpdateExchangeStatusKeys = accounts.into();
    let ix = update_exchange_status_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_exchange_status_invoke(
    accounts: UpdateExchangeStatusAccounts<'_, '_>,
    args: UpdateExchangeStatusIxArgs,
) -> ProgramResult {
    update_exchange_status_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_exchange_status_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateExchangeStatusAccounts<'_, '_>,
    args: UpdateExchangeStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateExchangeStatusKeys = accounts.into();
    let ix = update_exchange_status_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_exchange_status_invoke_signed(
    accounts: UpdateExchangeStatusAccounts<'_, '_>,
    args: UpdateExchangeStatusIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_exchange_status_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_exchange_status_verify_account_keys(
    accounts: UpdateExchangeStatusAccounts<'_, '_>,
    keys: UpdateExchangeStatusKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_exchange_status_verify_writable_privileges<'me, 'info>(
    accounts: UpdateExchangeStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_exchange_status_verify_signer_privileges<'me, 'info>(
    accounts: UpdateExchangeStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_exchange_status_verify_account_privileges<'me, 'info>(
    accounts: UpdateExchangeStatusAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_exchange_status_verify_writable_privileges(accounts)?;
    update_exchange_status_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePerpAuctionDurationAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePerpAuctionDurationKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdatePerpAuctionDurationAccounts<'_, '_>> for UpdatePerpAuctionDurationKeys {
    fn from(accounts: UpdatePerpAuctionDurationAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdatePerpAuctionDurationKeys>
for [AccountMeta; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePerpAuctionDurationKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN]>
for UpdatePerpAuctionDurationKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdatePerpAuctionDurationAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePerpAuctionDurationAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN]>
for UpdatePerpAuctionDurationAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_PERP_AUCTION_DURATION_IX_DISCM: [u8; 8] = [
    126,
    110,
    52,
    174,
    30,
    206,
    215,
    90,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePerpAuctionDurationIxArgs {
    pub min_perp_auction_duration: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePerpAuctionDurationIxData(pub UpdatePerpAuctionDurationIxArgs);
impl From<UpdatePerpAuctionDurationIxArgs> for UpdatePerpAuctionDurationIxData {
    fn from(args: UpdatePerpAuctionDurationIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePerpAuctionDurationIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PERP_AUCTION_DURATION_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PERP_AUCTION_DURATION_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePerpAuctionDurationIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PERP_AUCTION_DURATION_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_perp_auction_duration_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePerpAuctionDurationKeys,
    args: UpdatePerpAuctionDurationIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PERP_AUCTION_DURATION_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdatePerpAuctionDurationIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_perp_auction_duration_ix(
    keys: UpdatePerpAuctionDurationKeys,
    args: UpdatePerpAuctionDurationIxArgs,
) -> std::io::Result<Instruction> {
    update_perp_auction_duration_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_perp_auction_duration_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpAuctionDurationAccounts<'_, '_>,
    args: UpdatePerpAuctionDurationIxArgs,
) -> ProgramResult {
    let keys: UpdatePerpAuctionDurationKeys = accounts.into();
    let ix = update_perp_auction_duration_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_perp_auction_duration_invoke(
    accounts: UpdatePerpAuctionDurationAccounts<'_, '_>,
    args: UpdatePerpAuctionDurationIxArgs,
) -> ProgramResult {
    update_perp_auction_duration_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_perp_auction_duration_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePerpAuctionDurationAccounts<'_, '_>,
    args: UpdatePerpAuctionDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePerpAuctionDurationKeys = accounts.into();
    let ix = update_perp_auction_duration_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_perp_auction_duration_invoke_signed(
    accounts: UpdatePerpAuctionDurationAccounts<'_, '_>,
    args: UpdatePerpAuctionDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_perp_auction_duration_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_perp_auction_duration_verify_account_keys(
    accounts: UpdatePerpAuctionDurationAccounts<'_, '_>,
    keys: UpdatePerpAuctionDurationKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_perp_auction_duration_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePerpAuctionDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_perp_auction_duration_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePerpAuctionDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_perp_auction_duration_verify_account_privileges<'me, 'info>(
    accounts: UpdatePerpAuctionDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_perp_auction_duration_verify_writable_privileges(accounts)?;
    update_perp_auction_duration_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN: usize = 2;
#[derive(Copy, Clone, Debug)]
pub struct UpdateSpotAuctionDurationAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateSpotAuctionDurationKeys {
    pub admin: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateSpotAuctionDurationAccounts<'_, '_>> for UpdateSpotAuctionDurationKeys {
    fn from(accounts: UpdateSpotAuctionDurationAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateSpotAuctionDurationKeys>
for [AccountMeta; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateSpotAuctionDurationKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: true,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN]>
for UpdateSpotAuctionDurationKeys {
    fn from(pubkeys: [Pubkey; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            state: pubkeys[1],
        }
    }
}
impl<'info> From<UpdateSpotAuctionDurationAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateSpotAuctionDurationAccounts<'_, 'info>) -> Self {
        [accounts.admin.clone(), accounts.state.clone()]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN]>
for UpdateSpotAuctionDurationAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            state: &arr[1],
        }
    }
}
pub const UPDATE_SPOT_AUCTION_DURATION_IX_DISCM: [u8; 8] = [
    182,
    178,
    203,
    72,
    187,
    143,
    157,
    107,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateSpotAuctionDurationIxArgs {
    pub default_spot_auction_duration: u8,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateSpotAuctionDurationIxData(pub UpdateSpotAuctionDurationIxArgs);
impl From<UpdateSpotAuctionDurationIxArgs> for UpdateSpotAuctionDurationIxData {
    fn from(args: UpdateSpotAuctionDurationIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateSpotAuctionDurationIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_SPOT_AUCTION_DURATION_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_SPOT_AUCTION_DURATION_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateSpotAuctionDurationIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_SPOT_AUCTION_DURATION_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_spot_auction_duration_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateSpotAuctionDurationKeys,
    args: UpdateSpotAuctionDurationIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_SPOT_AUCTION_DURATION_IX_ACCOUNTS_LEN] = keys.into();
    let data: UpdateSpotAuctionDurationIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_spot_auction_duration_ix(
    keys: UpdateSpotAuctionDurationKeys,
    args: UpdateSpotAuctionDurationIxArgs,
) -> std::io::Result<Instruction> {
    update_spot_auction_duration_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_spot_auction_duration_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotAuctionDurationAccounts<'_, '_>,
    args: UpdateSpotAuctionDurationIxArgs,
) -> ProgramResult {
    let keys: UpdateSpotAuctionDurationKeys = accounts.into();
    let ix = update_spot_auction_duration_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_spot_auction_duration_invoke(
    accounts: UpdateSpotAuctionDurationAccounts<'_, '_>,
    args: UpdateSpotAuctionDurationIxArgs,
) -> ProgramResult {
    update_spot_auction_duration_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_spot_auction_duration_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateSpotAuctionDurationAccounts<'_, '_>,
    args: UpdateSpotAuctionDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateSpotAuctionDurationKeys = accounts.into();
    let ix = update_spot_auction_duration_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_spot_auction_duration_invoke_signed(
    accounts: UpdateSpotAuctionDurationAccounts<'_, '_>,
    args: UpdateSpotAuctionDurationIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_spot_auction_duration_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_spot_auction_duration_verify_account_keys(
    accounts: UpdateSpotAuctionDurationAccounts<'_, '_>,
    keys: UpdateSpotAuctionDurationKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_spot_auction_duration_verify_writable_privileges<'me, 'info>(
    accounts: UpdateSpotAuctionDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.state] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_spot_auction_duration_verify_signer_privileges<'me, 'info>(
    accounts: UpdateSpotAuctionDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_spot_auction_duration_verify_account_privileges<'me, 'info>(
    accounts: UpdateSpotAuctionDurationAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_spot_auction_duration_verify_writable_privileges(accounts)?;
    update_spot_auction_duration_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct InitializeProtocolIfSharesTransferConfigAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub protocol_if_shares_transfer_config: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeProtocolIfSharesTransferConfigKeys {
    pub admin: Pubkey,
    pub protocol_if_shares_transfer_config: Pubkey,
    pub state: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeProtocolIfSharesTransferConfigAccounts<'_, '_>>
for InitializeProtocolIfSharesTransferConfigKeys {
    fn from(accounts: InitializeProtocolIfSharesTransferConfigAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            protocol_if_shares_transfer_config: *accounts
                .protocol_if_shares_transfer_config
                .key,
            state: *accounts.state.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeProtocolIfSharesTransferConfigKeys>
for [AccountMeta; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeProtocolIfSharesTransferConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.protocol_if_shares_transfer_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN]>
for InitializeProtocolIfSharesTransferConfigKeys {
    fn from(
        pubkeys: [Pubkey; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            protocol_if_shares_transfer_config: pubkeys[1],
            state: pubkeys[2],
            rent: pubkeys[3],
            system_program: pubkeys[4],
        }
    }
}
impl<'info> From<InitializeProtocolIfSharesTransferConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(
        accounts: InitializeProtocolIfSharesTransferConfigAccounts<'_, 'info>,
    ) -> Self {
        [
            accounts.admin.clone(),
            accounts.protocol_if_shares_transfer_config.clone(),
            accounts.state.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<
        'info,
    >; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN],
> for InitializeProtocolIfSharesTransferConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            protocol_if_shares_transfer_config: &arr[1],
            state: &arr[2],
            rent: &arr[3],
            system_program: &arr[4],
        }
    }
}
pub const INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM: [u8; 8] = [
    89,
    131,
    239,
    200,
    178,
    141,
    106,
    194,
];
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeProtocolIfSharesTransferConfigIxData;
impl InitializeProtocolIfSharesTransferConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM,
                        maybe_discm
                    ),
                ),
            );
        }
        Ok(Self)
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_protocol_if_shares_transfer_config_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeProtocolIfSharesTransferConfigKeys,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: InitializeProtocolIfSharesTransferConfigIxData.try_to_vec()?,
    })
}
pub fn initialize_protocol_if_shares_transfer_config_ix(
    keys: InitializeProtocolIfSharesTransferConfigKeys,
) -> std::io::Result<Instruction> {
    initialize_protocol_if_shares_transfer_config_ix_with_program_id(crate::ID, keys)
}
pub fn initialize_protocol_if_shares_transfer_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'_, '_>,
) -> ProgramResult {
    let keys: InitializeProtocolIfSharesTransferConfigKeys = accounts.into();
    let ix = initialize_protocol_if_shares_transfer_config_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_protocol_if_shares_transfer_config_invoke(
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'_, '_>,
) -> ProgramResult {
    initialize_protocol_if_shares_transfer_config_invoke_with_program_id(
        crate::ID,
        accounts,
    )
}
pub fn initialize_protocol_if_shares_transfer_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeProtocolIfSharesTransferConfigKeys = accounts.into();
    let ix = initialize_protocol_if_shares_transfer_config_ix_with_program_id(
        program_id,
        keys,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_protocol_if_shares_transfer_config_invoke_signed(
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'_, '_>,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_protocol_if_shares_transfer_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        seeds,
    )
}
pub fn initialize_protocol_if_shares_transfer_config_verify_account_keys(
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'_, '_>,
    keys: InitializeProtocolIfSharesTransferConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (
            *accounts.protocol_if_shares_transfer_config.key,
            keys.protocol_if_shares_transfer_config,
        ),
        (*accounts.state.key, keys.state),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_protocol_if_shares_transfer_config_verify_writable_privileges<
    'me,
    'info,
>(
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.admin,
        accounts.protocol_if_shares_transfer_config,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_protocol_if_shares_transfer_config_verify_signer_privileges<
    'me,
    'info,
>(
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_protocol_if_shares_transfer_config_verify_account_privileges<
    'me,
    'info,
>(
    accounts: InitializeProtocolIfSharesTransferConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_protocol_if_shares_transfer_config_verify_writable_privileges(accounts)?;
    initialize_protocol_if_shares_transfer_config_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateProtocolIfSharesTransferConfigAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub protocol_if_shares_transfer_config: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateProtocolIfSharesTransferConfigKeys {
    pub admin: Pubkey,
    pub protocol_if_shares_transfer_config: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateProtocolIfSharesTransferConfigAccounts<'_, '_>>
for UpdateProtocolIfSharesTransferConfigKeys {
    fn from(accounts: UpdateProtocolIfSharesTransferConfigAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            protocol_if_shares_transfer_config: *accounts
                .protocol_if_shares_transfer_config
                .key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateProtocolIfSharesTransferConfigKeys>
for [AccountMeta; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateProtocolIfSharesTransferConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.protocol_if_shares_transfer_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN]>
for UpdateProtocolIfSharesTransferConfigKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            protocol_if_shares_transfer_config: pubkeys[1],
            state: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateProtocolIfSharesTransferConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateProtocolIfSharesTransferConfigAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.protocol_if_shares_transfer_config.clone(),
            accounts.state.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<
    &'me [AccountInfo<'info>; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN],
> for UpdateProtocolIfSharesTransferConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            protocol_if_shares_transfer_config: &arr[1],
            state: &arr[2],
        }
    }
}
pub const UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM: [u8; 8] = [
    34,
    135,
    47,
    91,
    220,
    24,
    212,
    53,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateProtocolIfSharesTransferConfigIxArgs {
    pub whitelisted_signers: Option<[Pubkey; 4]>,
    pub max_transfer_per_epoch: Option<u128>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateProtocolIfSharesTransferConfigIxData(
    pub UpdateProtocolIfSharesTransferConfigIxArgs,
);
impl From<UpdateProtocolIfSharesTransferConfigIxArgs>
for UpdateProtocolIfSharesTransferConfigIxData {
    fn from(args: UpdateProtocolIfSharesTransferConfigIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateProtocolIfSharesTransferConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateProtocolIfSharesTransferConfigIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_protocol_if_shares_transfer_config_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateProtocolIfSharesTransferConfigKeys,
    args: UpdateProtocolIfSharesTransferConfigIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PROTOCOL_IF_SHARES_TRANSFER_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateProtocolIfSharesTransferConfigIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_protocol_if_shares_transfer_config_ix(
    keys: UpdateProtocolIfSharesTransferConfigKeys,
    args: UpdateProtocolIfSharesTransferConfigIxArgs,
) -> std::io::Result<Instruction> {
    update_protocol_if_shares_transfer_config_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_protocol_if_shares_transfer_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'_, '_>,
    args: UpdateProtocolIfSharesTransferConfigIxArgs,
) -> ProgramResult {
    let keys: UpdateProtocolIfSharesTransferConfigKeys = accounts.into();
    let ix = update_protocol_if_shares_transfer_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_protocol_if_shares_transfer_config_invoke(
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'_, '_>,
    args: UpdateProtocolIfSharesTransferConfigIxArgs,
) -> ProgramResult {
    update_protocol_if_shares_transfer_config_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn update_protocol_if_shares_transfer_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'_, '_>,
    args: UpdateProtocolIfSharesTransferConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateProtocolIfSharesTransferConfigKeys = accounts.into();
    let ix = update_protocol_if_shares_transfer_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_protocol_if_shares_transfer_config_invoke_signed(
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'_, '_>,
    args: UpdateProtocolIfSharesTransferConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_protocol_if_shares_transfer_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_protocol_if_shares_transfer_config_verify_account_keys(
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'_, '_>,
    keys: UpdateProtocolIfSharesTransferConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (
            *accounts.protocol_if_shares_transfer_config.key,
            keys.protocol_if_shares_transfer_config,
        ),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_protocol_if_shares_transfer_config_verify_writable_privileges<'me, 'info>(
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.admin,
        accounts.protocol_if_shares_transfer_config,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_protocol_if_shares_transfer_config_verify_signer_privileges<'me, 'info>(
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_protocol_if_shares_transfer_config_verify_account_privileges<'me, 'info>(
    accounts: UpdateProtocolIfSharesTransferConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_protocol_if_shares_transfer_config_verify_writable_privileges(accounts)?;
    update_protocol_if_shares_transfer_config_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct InitializePrelaunchOracleAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub prelaunch_oracle: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializePrelaunchOracleKeys {
    pub admin: Pubkey,
    pub prelaunch_oracle: Pubkey,
    pub state: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializePrelaunchOracleAccounts<'_, '_>> for InitializePrelaunchOracleKeys {
    fn from(accounts: InitializePrelaunchOracleAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            prelaunch_oracle: *accounts.prelaunch_oracle.key,
            state: *accounts.state.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializePrelaunchOracleKeys>
for [AccountMeta; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializePrelaunchOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.prelaunch_oracle,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]>
for InitializePrelaunchOracleKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            prelaunch_oracle: pubkeys[1],
            state: pubkeys[2],
            rent: pubkeys[3],
            system_program: pubkeys[4],
        }
    }
}
impl<'info> From<InitializePrelaunchOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializePrelaunchOracleAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.prelaunch_oracle.clone(),
            accounts.state.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]>
for InitializePrelaunchOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            prelaunch_oracle: &arr[1],
            state: &arr[2],
            rent: &arr[3],
            system_program: &arr[4],
        }
    }
}
pub const INITIALIZE_PRELAUNCH_ORACLE_IX_DISCM: [u8; 8] = [
    169,
    178,
    84,
    25,
    175,
    62,
    29,
    247,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializePrelaunchOracleIxArgs {
    pub params: PrelaunchOracleParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializePrelaunchOracleIxData(pub InitializePrelaunchOracleIxArgs);
impl From<InitializePrelaunchOracleIxArgs> for InitializePrelaunchOracleIxData {
    fn from(args: InitializePrelaunchOracleIxArgs) -> Self {
        Self(args)
    }
}
impl InitializePrelaunchOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_PRELAUNCH_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_PRELAUNCH_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializePrelaunchOracleIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_PRELAUNCH_ORACLE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_prelaunch_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializePrelaunchOracleKeys,
    args: InitializePrelaunchOracleIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitializePrelaunchOracleIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_prelaunch_oracle_ix(
    keys: InitializePrelaunchOracleKeys,
    args: InitializePrelaunchOracleIxArgs,
) -> std::io::Result<Instruction> {
    initialize_prelaunch_oracle_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_prelaunch_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializePrelaunchOracleAccounts<'_, '_>,
    args: InitializePrelaunchOracleIxArgs,
) -> ProgramResult {
    let keys: InitializePrelaunchOracleKeys = accounts.into();
    let ix = initialize_prelaunch_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_prelaunch_oracle_invoke(
    accounts: InitializePrelaunchOracleAccounts<'_, '_>,
    args: InitializePrelaunchOracleIxArgs,
) -> ProgramResult {
    initialize_prelaunch_oracle_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_prelaunch_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializePrelaunchOracleAccounts<'_, '_>,
    args: InitializePrelaunchOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializePrelaunchOracleKeys = accounts.into();
    let ix = initialize_prelaunch_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_prelaunch_oracle_invoke_signed(
    accounts: InitializePrelaunchOracleAccounts<'_, '_>,
    args: InitializePrelaunchOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_prelaunch_oracle_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_prelaunch_oracle_verify_account_keys(
    accounts: InitializePrelaunchOracleAccounts<'_, '_>,
    keys: InitializePrelaunchOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.prelaunch_oracle.key, keys.prelaunch_oracle),
        (*accounts.state.key, keys.state),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_prelaunch_oracle_verify_writable_privileges<'me, 'info>(
    accounts: InitializePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.prelaunch_oracle] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_prelaunch_oracle_verify_signer_privileges<'me, 'info>(
    accounts: InitializePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_prelaunch_oracle_verify_account_privileges<'me, 'info>(
    accounts: InitializePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_prelaunch_oracle_verify_writable_privileges(accounts)?;
    initialize_prelaunch_oracle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct UpdatePrelaunchOracleParamsAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub prelaunch_oracle: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdatePrelaunchOracleParamsKeys {
    pub admin: Pubkey,
    pub prelaunch_oracle: Pubkey,
    pub perp_market: Pubkey,
    pub state: Pubkey,
}
impl From<UpdatePrelaunchOracleParamsAccounts<'_, '_>>
for UpdatePrelaunchOracleParamsKeys {
    fn from(accounts: UpdatePrelaunchOracleParamsAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            prelaunch_oracle: *accounts.prelaunch_oracle.key,
            perp_market: *accounts.perp_market.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdatePrelaunchOracleParamsKeys>
for [AccountMeta; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdatePrelaunchOracleParamsKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.prelaunch_oracle,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN]>
for UpdatePrelaunchOracleParamsKeys {
    fn from(pubkeys: [Pubkey; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            prelaunch_oracle: pubkeys[1],
            perp_market: pubkeys[2],
            state: pubkeys[3],
        }
    }
}
impl<'info> From<UpdatePrelaunchOracleParamsAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdatePrelaunchOracleParamsAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.prelaunch_oracle.clone(),
            accounts.perp_market.clone(),
            accounts.state.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN]>
for UpdatePrelaunchOracleParamsAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            prelaunch_oracle: &arr[1],
            perp_market: &arr[2],
            state: &arr[3],
        }
    }
}
pub const UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_DISCM: [u8; 8] = [
    98,
    205,
    147,
    243,
    18,
    75,
    83,
    207,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdatePrelaunchOracleParamsIxArgs {
    pub params: PrelaunchOracleParams,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdatePrelaunchOracleParamsIxData(pub UpdatePrelaunchOracleParamsIxArgs);
impl From<UpdatePrelaunchOracleParamsIxArgs> for UpdatePrelaunchOracleParamsIxData {
    fn from(args: UpdatePrelaunchOracleParamsIxArgs) -> Self {
        Self(args)
    }
}
impl UpdatePrelaunchOracleParamsIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdatePrelaunchOracleParamsIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_prelaunch_oracle_params_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdatePrelaunchOracleParamsKeys,
    args: UpdatePrelaunchOracleParamsIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_PRELAUNCH_ORACLE_PARAMS_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdatePrelaunchOracleParamsIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_prelaunch_oracle_params_ix(
    keys: UpdatePrelaunchOracleParamsKeys,
    args: UpdatePrelaunchOracleParamsIxArgs,
) -> std::io::Result<Instruction> {
    update_prelaunch_oracle_params_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_prelaunch_oracle_params_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePrelaunchOracleParamsAccounts<'_, '_>,
    args: UpdatePrelaunchOracleParamsIxArgs,
) -> ProgramResult {
    let keys: UpdatePrelaunchOracleParamsKeys = accounts.into();
    let ix = update_prelaunch_oracle_params_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn update_prelaunch_oracle_params_invoke(
    accounts: UpdatePrelaunchOracleParamsAccounts<'_, '_>,
    args: UpdatePrelaunchOracleParamsIxArgs,
) -> ProgramResult {
    update_prelaunch_oracle_params_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_prelaunch_oracle_params_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdatePrelaunchOracleParamsAccounts<'_, '_>,
    args: UpdatePrelaunchOracleParamsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdatePrelaunchOracleParamsKeys = accounts.into();
    let ix = update_prelaunch_oracle_params_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_prelaunch_oracle_params_invoke_signed(
    accounts: UpdatePrelaunchOracleParamsAccounts<'_, '_>,
    args: UpdatePrelaunchOracleParamsIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_prelaunch_oracle_params_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_prelaunch_oracle_params_verify_account_keys(
    accounts: UpdatePrelaunchOracleParamsAccounts<'_, '_>,
    keys: UpdatePrelaunchOracleParamsKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.prelaunch_oracle.key, keys.prelaunch_oracle),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_prelaunch_oracle_params_verify_writable_privileges<'me, 'info>(
    accounts: UpdatePrelaunchOracleParamsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [
        accounts.admin,
        accounts.prelaunch_oracle,
        accounts.perp_market,
    ] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_prelaunch_oracle_params_verify_signer_privileges<'me, 'info>(
    accounts: UpdatePrelaunchOracleParamsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_prelaunch_oracle_params_verify_account_privileges<'me, 'info>(
    accounts: UpdatePrelaunchOracleParamsAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_prelaunch_oracle_params_verify_writable_privileges(accounts)?;
    update_prelaunch_oracle_params_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN: usize = 4;
#[derive(Copy, Clone, Debug)]
pub struct DeletePrelaunchOracleAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub prelaunch_oracle: &'me AccountInfo<'info>,
    pub perp_market: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct DeletePrelaunchOracleKeys {
    pub admin: Pubkey,
    pub prelaunch_oracle: Pubkey,
    pub perp_market: Pubkey,
    pub state: Pubkey,
}
impl From<DeletePrelaunchOracleAccounts<'_, '_>> for DeletePrelaunchOracleKeys {
    fn from(accounts: DeletePrelaunchOracleAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            prelaunch_oracle: *accounts.prelaunch_oracle.key,
            perp_market: *accounts.perp_market.key,
            state: *accounts.state.key,
        }
    }
}
impl From<DeletePrelaunchOracleKeys>
for [AccountMeta; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: DeletePrelaunchOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.prelaunch_oracle,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.perp_market,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]>
for DeletePrelaunchOracleKeys {
    fn from(pubkeys: [Pubkey; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            prelaunch_oracle: pubkeys[1],
            perp_market: pubkeys[2],
            state: pubkeys[3],
        }
    }
}
impl<'info> From<DeletePrelaunchOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: DeletePrelaunchOracleAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.prelaunch_oracle.clone(),
            accounts.perp_market.clone(),
            accounts.state.clone(),
        ]
    }
}
impl<'me, 'info> From<&'me [AccountInfo<'info>; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN]>
for DeletePrelaunchOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            prelaunch_oracle: &arr[1],
            perp_market: &arr[2],
            state: &arr[3],
        }
    }
}
pub const DELETE_PRELAUNCH_ORACLE_IX_DISCM: [u8; 8] = [
    59,
    169,
    100,
    49,
    69,
    17,
    173,
    253,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DeletePrelaunchOracleIxArgs {
    pub perp_market_index: u16,
}
#[derive(Clone, Debug, PartialEq)]
pub struct DeletePrelaunchOracleIxData(pub DeletePrelaunchOracleIxArgs);
impl From<DeletePrelaunchOracleIxArgs> for DeletePrelaunchOracleIxData {
    fn from(args: DeletePrelaunchOracleIxArgs) -> Self {
        Self(args)
    }
}
impl DeletePrelaunchOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != DELETE_PRELAUNCH_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        DELETE_PRELAUNCH_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(DeletePrelaunchOracleIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&DELETE_PRELAUNCH_ORACLE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn delete_prelaunch_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: DeletePrelaunchOracleKeys,
    args: DeletePrelaunchOracleIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; DELETE_PRELAUNCH_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    let data: DeletePrelaunchOracleIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn delete_prelaunch_oracle_ix(
    keys: DeletePrelaunchOracleKeys,
    args: DeletePrelaunchOracleIxArgs,
) -> std::io::Result<Instruction> {
    delete_prelaunch_oracle_ix_with_program_id(crate::ID, keys, args)
}
pub fn delete_prelaunch_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: DeletePrelaunchOracleAccounts<'_, '_>,
    args: DeletePrelaunchOracleIxArgs,
) -> ProgramResult {
    let keys: DeletePrelaunchOracleKeys = accounts.into();
    let ix = delete_prelaunch_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn delete_prelaunch_oracle_invoke(
    accounts: DeletePrelaunchOracleAccounts<'_, '_>,
    args: DeletePrelaunchOracleIxArgs,
) -> ProgramResult {
    delete_prelaunch_oracle_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn delete_prelaunch_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: DeletePrelaunchOracleAccounts<'_, '_>,
    args: DeletePrelaunchOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: DeletePrelaunchOracleKeys = accounts.into();
    let ix = delete_prelaunch_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn delete_prelaunch_oracle_invoke_signed(
    accounts: DeletePrelaunchOracleAccounts<'_, '_>,
    args: DeletePrelaunchOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    delete_prelaunch_oracle_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn delete_prelaunch_oracle_verify_account_keys(
    accounts: DeletePrelaunchOracleAccounts<'_, '_>,
    keys: DeletePrelaunchOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.prelaunch_oracle.key, keys.prelaunch_oracle),
        (*accounts.perp_market.key, keys.perp_market),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn delete_prelaunch_oracle_verify_writable_privileges<'me, 'info>(
    accounts: DeletePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.prelaunch_oracle] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn delete_prelaunch_oracle_verify_signer_privileges<'me, 'info>(
    accounts: DeletePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn delete_prelaunch_oracle_verify_account_privileges<'me, 'info>(
    accounts: DeletePrelaunchOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    delete_prelaunch_oracle_verify_writable_privileges(accounts)?;
    delete_prelaunch_oracle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct InitializePythPullOracleAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub pyth_solana_receiver: &'me AccountInfo<'info>,
    pub price_feed: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializePythPullOracleKeys {
    pub admin: Pubkey,
    pub pyth_solana_receiver: Pubkey,
    pub price_feed: Pubkey,
    pub system_program: Pubkey,
    pub state: Pubkey,
}
impl From<InitializePythPullOracleAccounts<'_, '_>> for InitializePythPullOracleKeys {
    fn from(accounts: InitializePythPullOracleAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            pyth_solana_receiver: *accounts.pyth_solana_receiver.key,
            price_feed: *accounts.price_feed.key,
            system_program: *accounts.system_program.key,
            state: *accounts.state.key,
        }
    }
}
impl From<InitializePythPullOracleKeys>
for [AccountMeta; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializePythPullOracleKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.pyth_solana_receiver,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.price_feed,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN]>
for InitializePythPullOracleKeys {
    fn from(pubkeys: [Pubkey; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN]) -> Self {
        Self {
            admin: pubkeys[0],
            pyth_solana_receiver: pubkeys[1],
            price_feed: pubkeys[2],
            system_program: pubkeys[3],
            state: pubkeys[4],
        }
    }
}
impl<'info> From<InitializePythPullOracleAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializePythPullOracleAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.pyth_solana_receiver.clone(),
            accounts.price_feed.clone(),
            accounts.system_program.clone(),
            accounts.state.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN]>
for InitializePythPullOracleAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            pyth_solana_receiver: &arr[1],
            price_feed: &arr[2],
            system_program: &arr[3],
            state: &arr[4],
        }
    }
}
pub const INITIALIZE_PYTH_PULL_ORACLE_IX_DISCM: [u8; 8] = [
    249,
    140,
    253,
    243,
    248,
    74,
    240,
    238,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializePythPullOracleIxArgs {
    pub feed_id: [u8; 32],
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializePythPullOracleIxData(pub InitializePythPullOracleIxArgs);
impl From<InitializePythPullOracleIxArgs> for InitializePythPullOracleIxData {
    fn from(args: InitializePythPullOracleIxArgs) -> Self {
        Self(args)
    }
}
impl InitializePythPullOracleIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_PYTH_PULL_ORACLE_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_PYTH_PULL_ORACLE_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializePythPullOracleIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_PYTH_PULL_ORACLE_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_pyth_pull_oracle_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializePythPullOracleKeys,
    args: InitializePythPullOracleIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_PYTH_PULL_ORACLE_IX_ACCOUNTS_LEN] = keys.into();
    let data: InitializePythPullOracleIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_pyth_pull_oracle_ix(
    keys: InitializePythPullOracleKeys,
    args: InitializePythPullOracleIxArgs,
) -> std::io::Result<Instruction> {
    initialize_pyth_pull_oracle_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_pyth_pull_oracle_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializePythPullOracleAccounts<'_, '_>,
    args: InitializePythPullOracleIxArgs,
) -> ProgramResult {
    let keys: InitializePythPullOracleKeys = accounts.into();
    let ix = initialize_pyth_pull_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_pyth_pull_oracle_invoke(
    accounts: InitializePythPullOracleAccounts<'_, '_>,
    args: InitializePythPullOracleIxArgs,
) -> ProgramResult {
    initialize_pyth_pull_oracle_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn initialize_pyth_pull_oracle_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializePythPullOracleAccounts<'_, '_>,
    args: InitializePythPullOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializePythPullOracleKeys = accounts.into();
    let ix = initialize_pyth_pull_oracle_ix_with_program_id(program_id, keys, args)?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_pyth_pull_oracle_invoke_signed(
    accounts: InitializePythPullOracleAccounts<'_, '_>,
    args: InitializePythPullOracleIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_pyth_pull_oracle_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_pyth_pull_oracle_verify_account_keys(
    accounts: InitializePythPullOracleAccounts<'_, '_>,
    keys: InitializePythPullOracleKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.pyth_solana_receiver.key, keys.pyth_solana_receiver),
        (*accounts.price_feed.key, keys.price_feed),
        (*accounts.system_program.key, keys.system_program),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_pyth_pull_oracle_verify_writable_privileges<'me, 'info>(
    accounts: InitializePythPullOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.price_feed] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_pyth_pull_oracle_verify_signer_privileges<'me, 'info>(
    accounts: InitializePythPullOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_pyth_pull_oracle_verify_account_privileges<'me, 'info>(
    accounts: InitializePythPullOracleAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_pyth_pull_oracle_verify_writable_privileges(accounts)?;
    initialize_pyth_pull_oracle_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN: usize = 5;
#[derive(Copy, Clone, Debug)]
pub struct InitializeHighLeverageModeConfigAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub high_leverage_mode_config: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
    pub rent: &'me AccountInfo<'info>,
    pub system_program: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct InitializeHighLeverageModeConfigKeys {
    pub admin: Pubkey,
    pub high_leverage_mode_config: Pubkey,
    pub state: Pubkey,
    pub rent: Pubkey,
    pub system_program: Pubkey,
}
impl From<InitializeHighLeverageModeConfigAccounts<'_, '_>>
for InitializeHighLeverageModeConfigKeys {
    fn from(accounts: InitializeHighLeverageModeConfigAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            high_leverage_mode_config: *accounts.high_leverage_mode_config.key,
            state: *accounts.state.key,
            rent: *accounts.rent.key,
            system_program: *accounts.system_program.key,
        }
    }
}
impl From<InitializeHighLeverageModeConfigKeys>
for [AccountMeta; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: InitializeHighLeverageModeConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.high_leverage_mode_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.rent,
                is_signer: false,
                is_writable: false,
            },
            AccountMeta {
                pubkey: keys.system_program,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN]>
for InitializeHighLeverageModeConfigKeys {
    fn from(
        pubkeys: [Pubkey; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            high_leverage_mode_config: pubkeys[1],
            state: pubkeys[2],
            rent: pubkeys[3],
            system_program: pubkeys[4],
        }
    }
}
impl<'info> From<InitializeHighLeverageModeConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(accounts: InitializeHighLeverageModeConfigAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.high_leverage_mode_config.clone(),
            accounts.state.clone(),
            accounts.rent.clone(),
            accounts.system_program.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN]>
for InitializeHighLeverageModeConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<
            'info,
        >; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            high_leverage_mode_config: &arr[1],
            state: &arr[2],
            rent: &arr[3],
            system_program: &arr[4],
        }
    }
}
pub const INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM: [u8; 8] = [
    213,
    167,
    93,
    246,
    208,
    130,
    90,
    248,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeHighLeverageModeConfigIxArgs {
    pub max_users: u32,
}
#[derive(Clone, Debug, PartialEq)]
pub struct InitializeHighLeverageModeConfigIxData(
    pub InitializeHighLeverageModeConfigIxArgs,
);
impl From<InitializeHighLeverageModeConfigIxArgs>
for InitializeHighLeverageModeConfigIxData {
    fn from(args: InitializeHighLeverageModeConfigIxArgs) -> Self {
        Self(args)
    }
}
impl InitializeHighLeverageModeConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(InitializeHighLeverageModeConfigIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn initialize_high_leverage_mode_config_ix_with_program_id(
    program_id: Pubkey,
    keys: InitializeHighLeverageModeConfigKeys,
    args: InitializeHighLeverageModeConfigIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; INITIALIZE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: InitializeHighLeverageModeConfigIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn initialize_high_leverage_mode_config_ix(
    keys: InitializeHighLeverageModeConfigKeys,
    args: InitializeHighLeverageModeConfigIxArgs,
) -> std::io::Result<Instruction> {
    initialize_high_leverage_mode_config_ix_with_program_id(crate::ID, keys, args)
}
pub fn initialize_high_leverage_mode_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: InitializeHighLeverageModeConfigAccounts<'_, '_>,
    args: InitializeHighLeverageModeConfigIxArgs,
) -> ProgramResult {
    let keys: InitializeHighLeverageModeConfigKeys = accounts.into();
    let ix = initialize_high_leverage_mode_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn initialize_high_leverage_mode_config_invoke(
    accounts: InitializeHighLeverageModeConfigAccounts<'_, '_>,
    args: InitializeHighLeverageModeConfigIxArgs,
) -> ProgramResult {
    initialize_high_leverage_mode_config_invoke_with_program_id(
        crate::ID,
        accounts,
        args,
    )
}
pub fn initialize_high_leverage_mode_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: InitializeHighLeverageModeConfigAccounts<'_, '_>,
    args: InitializeHighLeverageModeConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: InitializeHighLeverageModeConfigKeys = accounts.into();
    let ix = initialize_high_leverage_mode_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn initialize_high_leverage_mode_config_invoke_signed(
    accounts: InitializeHighLeverageModeConfigAccounts<'_, '_>,
    args: InitializeHighLeverageModeConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    initialize_high_leverage_mode_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn initialize_high_leverage_mode_config_verify_account_keys(
    accounts: InitializeHighLeverageModeConfigAccounts<'_, '_>,
    keys: InitializeHighLeverageModeConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.high_leverage_mode_config.key, keys.high_leverage_mode_config),
        (*accounts.state.key, keys.state),
        (*accounts.rent.key, keys.rent),
        (*accounts.system_program.key, keys.system_program),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn initialize_high_leverage_mode_config_verify_writable_privileges<'me, 'info>(
    accounts: InitializeHighLeverageModeConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.high_leverage_mode_config] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn initialize_high_leverage_mode_config_verify_signer_privileges<'me, 'info>(
    accounts: InitializeHighLeverageModeConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn initialize_high_leverage_mode_config_verify_account_privileges<'me, 'info>(
    accounts: InitializeHighLeverageModeConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    initialize_high_leverage_mode_config_verify_writable_privileges(accounts)?;
    initialize_high_leverage_mode_config_verify_signer_privileges(accounts)?;
    Ok(())
}
pub const UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN: usize = 3;
#[derive(Copy, Clone, Debug)]
pub struct UpdateHighLeverageModeConfigAccounts<'me, 'info> {
    pub admin: &'me AccountInfo<'info>,
    pub high_leverage_mode_config: &'me AccountInfo<'info>,
    pub state: &'me AccountInfo<'info>,
}
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct UpdateHighLeverageModeConfigKeys {
    pub admin: Pubkey,
    pub high_leverage_mode_config: Pubkey,
    pub state: Pubkey,
}
impl From<UpdateHighLeverageModeConfigAccounts<'_, '_>>
for UpdateHighLeverageModeConfigKeys {
    fn from(accounts: UpdateHighLeverageModeConfigAccounts) -> Self {
        Self {
            admin: *accounts.admin.key,
            high_leverage_mode_config: *accounts.high_leverage_mode_config.key,
            state: *accounts.state.key,
        }
    }
}
impl From<UpdateHighLeverageModeConfigKeys>
for [AccountMeta; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(keys: UpdateHighLeverageModeConfigKeys) -> Self {
        [
            AccountMeta {
                pubkey: keys.admin,
                is_signer: true,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.high_leverage_mode_config,
                is_signer: false,
                is_writable: true,
            },
            AccountMeta {
                pubkey: keys.state,
                is_signer: false,
                is_writable: false,
            },
        ]
    }
}
impl From<[Pubkey; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN]>
for UpdateHighLeverageModeConfigKeys {
    fn from(
        pubkeys: [Pubkey; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: pubkeys[0],
            high_leverage_mode_config: pubkeys[1],
            state: pubkeys[2],
        }
    }
}
impl<'info> From<UpdateHighLeverageModeConfigAccounts<'_, 'info>>
for [AccountInfo<'info>; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN] {
    fn from(accounts: UpdateHighLeverageModeConfigAccounts<'_, 'info>) -> Self {
        [
            accounts.admin.clone(),
            accounts.high_leverage_mode_config.clone(),
            accounts.state.clone(),
        ]
    }
}
impl<
    'me,
    'info,
> From<&'me [AccountInfo<'info>; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN]>
for UpdateHighLeverageModeConfigAccounts<'me, 'info> {
    fn from(
        arr: &'me [AccountInfo<'info>; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN],
    ) -> Self {
        Self {
            admin: &arr[0],
            high_leverage_mode_config: &arr[1],
            state: &arr[2],
        }
    }
}
pub const UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM: [u8; 8] = [
    64,
    122,
    212,
    93,
    141,
    217,
    202,
    55,
];
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UpdateHighLeverageModeConfigIxArgs {
    pub max_users: u32,
    pub reduce_only: bool,
}
#[derive(Clone, Debug, PartialEq)]
pub struct UpdateHighLeverageModeConfigIxData(pub UpdateHighLeverageModeConfigIxArgs);
impl From<UpdateHighLeverageModeConfigIxArgs> for UpdateHighLeverageModeConfigIxData {
    fn from(args: UpdateHighLeverageModeConfigIxArgs) -> Self {
        Self(args)
    }
}
impl UpdateHighLeverageModeConfigIxData {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        if maybe_discm != UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM {
            return Err(
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!(
                        "discm does not match. Expected: {:?}. Received: {:?}",
                        UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM, maybe_discm
                    ),
                ),
            );
        }
        Ok(Self(UpdateHighLeverageModeConfigIxArgs::deserialize(&mut reader)?))
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_DISCM)?;
        self.0.serialize(&mut writer)
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
pub fn update_high_leverage_mode_config_ix_with_program_id(
    program_id: Pubkey,
    keys: UpdateHighLeverageModeConfigKeys,
    args: UpdateHighLeverageModeConfigIxArgs,
) -> std::io::Result<Instruction> {
    let metas: [AccountMeta; UPDATE_HIGH_LEVERAGE_MODE_CONFIG_IX_ACCOUNTS_LEN] = keys
        .into();
    let data: UpdateHighLeverageModeConfigIxData = args.into();
    Ok(Instruction {
        program_id,
        accounts: Vec::from(metas),
        data: data.try_to_vec()?,
    })
}
pub fn update_high_leverage_mode_config_ix(
    keys: UpdateHighLeverageModeConfigKeys,
    args: UpdateHighLeverageModeConfigIxArgs,
) -> std::io::Result<Instruction> {
    update_high_leverage_mode_config_ix_with_program_id(crate::ID, keys, args)
}
pub fn update_high_leverage_mode_config_invoke_with_program_id(
    program_id: Pubkey,
    accounts: UpdateHighLeverageModeConfigAccounts<'_, '_>,
    args: UpdateHighLeverageModeConfigIxArgs,
) -> ProgramResult {
    let keys: UpdateHighLeverageModeConfigKeys = accounts.into();
    let ix = update_high_leverage_mode_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction(&ix, accounts)
}
pub fn update_high_leverage_mode_config_invoke(
    accounts: UpdateHighLeverageModeConfigAccounts<'_, '_>,
    args: UpdateHighLeverageModeConfigIxArgs,
) -> ProgramResult {
    update_high_leverage_mode_config_invoke_with_program_id(crate::ID, accounts, args)
}
pub fn update_high_leverage_mode_config_invoke_signed_with_program_id(
    program_id: Pubkey,
    accounts: UpdateHighLeverageModeConfigAccounts<'_, '_>,
    args: UpdateHighLeverageModeConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let keys: UpdateHighLeverageModeConfigKeys = accounts.into();
    let ix = update_high_leverage_mode_config_ix_with_program_id(
        program_id,
        keys,
        args,
    )?;
    invoke_instruction_signed(&ix, accounts, seeds)
}
pub fn update_high_leverage_mode_config_invoke_signed(
    accounts: UpdateHighLeverageModeConfigAccounts<'_, '_>,
    args: UpdateHighLeverageModeConfigIxArgs,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    update_high_leverage_mode_config_invoke_signed_with_program_id(
        crate::ID,
        accounts,
        args,
        seeds,
    )
}
pub fn update_high_leverage_mode_config_verify_account_keys(
    accounts: UpdateHighLeverageModeConfigAccounts<'_, '_>,
    keys: UpdateHighLeverageModeConfigKeys,
) -> Result<(), (Pubkey, Pubkey)> {
    for (actual, expected) in [
        (*accounts.admin.key, keys.admin),
        (*accounts.high_leverage_mode_config.key, keys.high_leverage_mode_config),
        (*accounts.state.key, keys.state),
    ] {
        if actual != expected {
            return Err((actual, expected));
        }
    }
    Ok(())
}
pub fn update_high_leverage_mode_config_verify_writable_privileges<'me, 'info>(
    accounts: UpdateHighLeverageModeConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_writable in [accounts.admin, accounts.high_leverage_mode_config] {
        if !should_be_writable.is_writable {
            return Err((should_be_writable, ProgramError::InvalidAccountData));
        }
    }
    Ok(())
}
pub fn update_high_leverage_mode_config_verify_signer_privileges<'me, 'info>(
    accounts: UpdateHighLeverageModeConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    for should_be_signer in [accounts.admin] {
        if !should_be_signer.is_signer {
            return Err((should_be_signer, ProgramError::MissingRequiredSignature));
        }
    }
    Ok(())
}
pub fn update_high_leverage_mode_config_verify_account_privileges<'me, 'info>(
    accounts: UpdateHighLeverageModeConfigAccounts<'me, 'info>,
) -> Result<(), (&'me AccountInfo<'info>, ProgramError)> {
    update_high_leverage_mode_config_verify_writable_privileges(accounts)?;
    update_high_leverage_mode_config_verify_signer_privileges(accounts)?;
    Ok(())
}
